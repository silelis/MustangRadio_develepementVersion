Core  0 register dump:
PC      : 0x40083fd3  PS      : 0x00050f35  A0      : 0x40082967  A1      : 0x3ffbf470  
A2      : 0x00001000  A3      : 0x3ffd97a0  A4      : 0x000010ff  A5      : 0x3ffbf450  
A6      : 0x3ffd7a58  A7      : 0x00000001  A8      : 0x00000000  A9      : 0x40095706  
A10     : 0x3ffd78b8  A11     : 0x00000000  A12     : 0x80082967  A13     : 0x3ffbf430  
A14     : 0x3ffbdbec  A15     : 0xffffffff  SAR     : 0x0000001b  EXCCAUSE: 0x00000005  
EXCVADDR: 0x00000000  LBEG    : 0x4000c2e0  LEND    : 0x4000c2f6  LCOUNT  : 0xffffffff  
Core  0 was running in ISR context:
EPC1    : 0x400d4a23  EPC2    : 0x00000000  EPC3    : 0x40082967  EPC4    : 0x40080049


Backtrace: 0x40083fd0:0x3ffbf470 0x40082964:0x3ffd97a0 0x40095657:0x3ffd97b0 0x40107401:0x3ffd97d0 0x400dc8d9:0x3ffd9800 0x400db10c:0x3ffd9830 0x400952b5:0x3ffd9850


Core  1 register dump:
PC      : 0x400920a2  PS      : 0x00060b35  A0      : 0x800d482a  A1      : 0x3ffd6e60  
A2      : 0x00000000  A3      : 0x00000001  A4      : 0x3ffba8a0  A5      : 0x3ffba880  
A6      : 0x40082118  A7      : 0x00000001  A8      : 0x800fc00e  A9      : 0x3ffd6e20  
A10     : 0x00000000  A11     : 0x00000000  A12     : 0x3ffba880  A13     : 0x3ffba860  
A14     : 0x00000001  A15     : 0x3ffd6f48  SAR     : 0x00000000  EXCCAUSE: 0x00000005  
EXCVADDR: 0x00000000  LBEG    : 0x00000000  LEND    : 0x00000000  LCOUNT  : 0x00000000  


Backtrace: 0x4009209f:0x3ffd6e60 0x400d4827:0x3ffd6e80 0x40096131:0x3ffd6ea0 0x400952b5:0x3ffd6ec0


0x4009209f: xt_utils_wait_for_intr at C:/SysGCC/esp32/esp-idf/v5.3.1/components/xtensa/include/xt_utils.h:82
 (inlined by) esp_cpu_wait_for_intr at C:/SysGCC/esp32/esp-idf/v5.3.1/components/esp_hw_support/cpu.c:55
0x400d4827: esp_vApplicationIdleHook at C:/SysGCC/esp32/esp-idf/v5.3.1/components/esp_system/freertos_hooks.c:58
0x40096131: prvIdleTask at C:/SysGCC/esp32/esp-idf/v5.3.1/components/freertos/FreeRTOS-Kernel/tasks.c:4344 (discriminator 1)
0x400952b5: vPortTaskWrapper at C:/SysGCC/esp32/esp-idf/v5.3.1/components/freertos/FreeRTOS-Kernel/portable/xtensa/port.c:134
0x40083fd0: _xt_lowint1 at C:/SysGCC/esp32/esp-idf/v5.3.1/components/xtensa/xtensa_vectors.S:1240
0x40082964: shared_intr_isr at C:/SysGCC/esp32/esp-idf/v5.3.1/components/esp_hw_support/intr_alloc.c:454
0x40095657: vPortClearInterruptMaskFromISR at C:/SysGCC/esp32/esp-idf/v5.3.1/components/freertos/FreeRTOS-Kernel/portable/xtensa/include/freertos/portmacro.h:560
 (inlined by) vPortExitCritical at C:/SysGCC/esp32/esp-idf/v5.3.1/components/freertos/FreeRTOS-Kernel/portable/xtensa/port.c:505
0x40107401: i2c_slave_transmit at C:/SysGCC/esp32/esp-idf/v5.3.1/components/esp_driver_i2c/i2c_slave.c:336
0x400dc8d9: i2cEngin_slave::i2cSlaveTransmit() at D:/!!!__GitHUB_repositories/MustangRadio_develepementVersion/02_Firmware/01_ESP32/HMI_and_bluetooth/main/i2c_engine/i2c_engine.cpp:326
0x400db10c: i2cSlaveTransmit(void*) at D:/!!!__GitHUB_repositories/MustangRadio_develepementVersion/02_Firmware/01_ESP32/HMI_and_bluetooth/main/tasksFunctions/tasksFunctions.cpp:587 (discriminator 1)
0x400952b5: vPortTaskWrapper at C:/SysGCC/esp32/esp-idf/v5.3.1/components/freertos/FreeRTOS-Kernel/portable/xtensa/port.c:134

mój i2c_engine.cpp to:
#include "i2c_engine.h"

static i2c_master_bus_handle_t handler_i2c_bus_master;
static i2c_master_bus_config_t i2c_bus_config_master;
 
static i2c_slave_dev_handle_t handler_i2c_dev_slave;
static i2c_slave_config_t i2c_config_slave;




#include "soc/i2c_struct.h"
extern i2c_dev_t I2C0;


#include "driver/i2c.h"
//----------------------------------------------
// Enumy i zmienne globalne (z volatile dla ISR)
//----------------------------------------------
typedef enum {
	recpeptionNotToMe, // 0 - dane nie były do ESP32
	recpeptionToMe, // 1 - ESP32 odebrało dane
	transmition         // 2 - ESP32 wysłało dane
} i2cCallbackState;

volatile static i2cCallbackState rxToEsp32 = recpeptionNotToMe;
volatile static uint32_t rx_fifo_end_addrLast = 0;


//----------------------------------------------
// Callback dla zdarzeń I2C Slave
//----------------------------------------------
static IRAM_ATTR bool i2c_slave_rx_done_callback(
    i2c_slave_dev_handle_t channel,
	const i2c_slave_rx_done_event_data_t *edata,
	void *user_data) {
	BaseType_t high_task_wakeup = pdFALSE;
	QueueHandle_t receive_queue = (QueueHandle_t)user_data;

	// 1. Sprawdź kierunek transmisji
	if (I2C0.status_reg.slave_rw == 0) {
		// Master -> Slave (ESP32 odbiera)
		if (rx_fifo_end_addrLast != I2C0.fifo_st.rx_fifo_end_addr) {
			rxToEsp32 = recpeptionToMe; // Nowe dane dla ESP32
		}
		else {
			rxToEsp32 = recpeptionNotToMe; // Dane były dla innego slave'a
		}
		rx_fifo_end_addrLast = I2C0.fifo_st.rx_fifo_end_addr;
	} 
	else {
		// Slave -> Master (ESP32 wysyła)
		rxToEsp32 = transmition;
	}

	// 2. Wyślij zdarzenie do kolejki (z zabezpieczeniem przed NULL)
	if (receive_queue != NULL && edata != NULL) {
		xQueueSendFromISR(receive_queue, edata, &high_task_wakeup);
	}

	return high_task_wakeup == pdTRUE;
}




/*---------------------------------------------------------------
 * Konstruktor klasy odpwiadającej za komunikację ESP32 po i2c z
 * urządzeniami i2c master.
 * Parameters:
 * i2c_port_num_t i2c_port	- numer portu i2c w kontrolerze ESP32
 * gpio_num_t sda_io_num	- numer pinu kontrolera ESP32 do którego
 *							  przypisano sygnał SDA szyny i2c
 * gpio_num_t scl_io_num	- numer pinu kontrolera ESP32 do którego
 *							  przypisano sygnał SCL szyny i2c
 uint32_t slave_addr		- adres esp32 jako slave na magistrali
							  i2c
 i2c_addr_bit_len_t slave_addr_bit_len - długość (w bitach) adresu
							  i2c slave
 gpio_num_t intRequestPin   - numer GPIO w esp32, który odpowiada 
								za zgłoszenie do slave konieczności
								komunikacji po i2c
 * Returns:
 * NONE
*---------------------------------------------------------------*/
i2cEngin_slave::i2cEngin_slave(i2c_port_num_t i2c_port, gpio_num_t sda_io_num, gpio_num_t scl_io_num, uint32_t slave_addr, i2c_addr_bit_len_t slave_addr_bit_len, gpio_num_t intRequestPin)
{
	i2c_config_slave.addr_bit_len =slave_addr_bit_len;
	i2c_config_slave.clk_source = I2C_CLK_SRC_DEFAULT;
	i2c_config_slave.i2c_port = i2c_port;
	i2c_config_slave.send_buf_depth = 2*ESP32_SLAVE_RECEIVE_BUFFER_LEN; //1024;
	
	i2c_config_slave.scl_io_num = scl_io_num;
	i2c_config_slave.sda_io_num = sda_io_num;
	i2c_config_slave.slave_addr = slave_addr;
	
	this->i2cSlave_intRequestPin = intRequestPin;
	gpio_config_t I2C_slave_IntRequestPinConfig;
	I2C_slave_IntRequestPinConfig.intr_type = GPIO_INTR_DISABLE;
	I2C_slave_IntRequestPinConfig.mode = GPIO_MODE_OUTPUT;
	I2C_slave_IntRequestPinConfig.pin_bit_mask = 0x1 << this->i2cSlave_intRequestPin;
	I2C_slave_IntRequestPinConfig.pull_down_en = GPIO_PULLDOWN_DISABLE;
	I2C_slave_IntRequestPinConfig.pull_up_en = GPIO_PULLUP_ENABLE;
	this->interruptRequestReset();			//ustawiam wyjście na wysokie przed inicjalizacją GPIO, aby nie wywołać niepotrzebnie interrupt request
	ESP_ERROR_CHECK(gpio_config(&I2C_slave_IntRequestPinConfig));
	//this->interruptRequestReset();
	printf("%s bus interrupt request GPIO has been initialised on GPIO_num_%d.\n", this->TAG , this->i2cSlave_intRequestPin);
	
	ESP_ERROR_CHECK(i2c_new_slave_device(&i2c_config_slave, &handler_i2c_dev_slave));
	
	configASSERT(this->i2cSlaveReceiveDataToDataParserQueue = new i2cQueue4DynamicData(20));
	configASSERT(this->i2cSlaveTransmitDataQueue = new i2cQueue4DynamicData(20));
	printf("%s bus has been initialised on port %d with address %lx.\n", this->TAG, i2c_port, slave_addr);

	

	//Tworzenie kolejki nadawczej
	//this->pTransmitQueueObject = NULL;
	//configASSERT(this->pTransmitQueueObject = new i2cQueue4DynamicData(DEFAULT_TRANSMIT_QUEUE_SIZE));
	
	//Tworzenie kolejki odbiorczej
	configASSERT(this->s_receive_queue = xQueueCreate(10, sizeof(i2c_slave_rx_done_event_data_t))) ;
	i2c_slave_event_callbacks_t cbs = {
		.on_recv_done = i2c_slave_rx_done_callback,
	};
	
	rx_fifo_end_addrLast = I2C0.fifo_st.rx_fifo_end_addr;
	
	ESP_ERROR_CHECK(i2c_slave_register_event_callbacks(handler_i2c_dev_slave, &cbs, this->s_receive_queue));
	printf("%s bus has been initialised on port %d with address %lx.\n", this->TAG, i2c_port, slave_addr);
	
	this->i2cMasterCrcSumCounterErrorReset();

}


BaseType_t i2cEngin_slave::i2cMasterCrcSumCounterErrorIncrement(void)
{
	this->i2cMasterCrcSumCounterError++;
	if (this->i2cMasterCrcSumCounterError > 7)
	{
		return pdFALSE;
	}
	return pdTRUE;
}
void i2cEngin_slave::i2cMasterCrcSumCounterErrorReset(void)
{
	this->i2cMasterCrcSumCounterError = 0;
}

/*---------------------------------------------------------------
 * Metoda działa wewnątrz taska "i2cSlaveReceive" i jej zadanie
 * jest przesyłanie (przez kolejkę) otrzymanych z i2c master
 * danych do taska zajmującego się parsowaniem otrzymanych danych.
 * Parameters:
 * NONE
 * Returns:
 * NONE
*---------------------------------------------------------------*/
void i2cEngin_slave::i2cSlaveReceive(void)
{
	uint8_t *data_rd =  new uint8_t[ESP32_SLAVE_RECEIVE_BUFFER_LEN];
	
	//uint32_t size_rd = 0;
	i2c_slave_rx_done_event_data_t rx_data;
	ESP_ERROR_CHECK(i2c_slave_receive(handler_i2c_dev_slave, data_rd, ESP32_SLAVE_RECEIVE_BUFFER_LEN));
	this->esp32i2cBusInitialised(); //informuje i2c master poprzez pierwsze interrupt request, że szyna i2c jest zainicjowana
	
	i2cFrame_commonHeader* fakeCommHeader = (i2cFrame_commonHeader*)data_rd;	//potrzebny, aby przeczytać ilośc otrzymanych z i2c master byte'ów
	i2cFrame_transmitQueue tempFrameToParserQueue;
	while (1)
	{
		memset(data_rd, 0, ESP32_SLAVE_RECEIVE_BUFFER_LEN);
		
		if (xQueueReceive(this->s_receive_queue, &rx_data, portMAX_DELAY)==pdTRUE)
		{
			ESP_ERROR_CHECK(i2c_slave_receive(handler_i2c_dev_slave, data_rd, ESP32_SLAVE_RECEIVE_BUFFER_LEN));
			if (rxToEsp32 == recpeptionToMe)
			{
				void* tempData = static_cast<void*>(new char[fakeCommHeader->dataSize]);
				if (tempData != nullptr)
				{
								
					//i2cFrame_hmiLeds tempToDelete;
					
					tempFrameToParserQueue.dataSize = fakeCommHeader->dataSize;
					memcpy(tempData, data_rd, tempFrameToParserQueue.dataSize);
					tempFrameToParserQueue.pData = tempData;
			
					this->i2cSlaveReceiveDataToDataParserQueue->QueueSendFromISR(&tempFrameToParserQueue); //funkcja ma od razu sprawdzanie czy pdTure, jeśli nie to usuwa zmienną zadeklarowaną dynamicznie
				}
				else
				{
					assert(0);
				}
				//printf("Data len is%s\n", data_rd);
				//printf("I2C rec. len:%d\n", fakeCommHeader->dataSize);
				//printf("I2C rec\n");
			}	
		}
		
	
	}
}
/*---------------------------------------------------------------
 * Metoda informuje i2c master o tym, że esp32 (i2c slave) ma dane
 * do wysłania. Ten sygmnał to zbocze opadające GPIO.
 * Parameters:
 * NONE
 * Returns:
 * esp_err_t 				- ESP_OK lub ESP_FAIL
*---------------------------------------------------------------*/
esp_err_t i2cEngin_slave::interruptRequestSet(void)
{
	return gpio_set_level(this->i2cSlave_intRequestPin, 0); //interrupt request is SET when pin goes low
}

/*---------------------------------------------------------------
 * Metoda resetująca informuję do i2c master o tym, że esp32 (i2c
 * slave) ma dane do wysłania.
 * Parameters:
 * NONE
 * Returns:
 * esp_err_t 				- ESP_OK lub ESP_FAIL
*---------------------------------------------------------------*/
esp_err_t i2cEngin_slave::interruptRequestReset(void)
{
	return gpio_set_level(this->i2cSlave_intRequestPin, 1); //interrupt request is RESET when pin goes high
}




/*---------------------------------------------------------------
* Metoda poprzez pierwszy sygnał interrupt request (pusty) informuje
* master i2c, że szyna i2c jest zainicjowana.
* Parameters:
* NONE
* Returns:
* NONE
*---------------------------------------------------------------*/
void i2cEngin_slave::esp32i2cBusInitialised(void)
{
	this->interruptRequestSet();
	vTaskDelay(pdMS_TO_TICKS(100));
	this->interruptRequestReset();
}


BaseType_t i2cEngin_slave::i2cSendDataToTransisionQueue(i2cFrame_transmitQueue* tempFrameToParserQueue)
{
	return this->i2cSlaveTransmitDataQueue->QueueSendFromISR(tempFrameToParserQueue);
}



/*---------------------------------------------------------------
 * estruktor klasy.
 * Parameters:
 * NONE
 * Returns:
 * NONE
*---------------------------------------------------------------*/
i2cEngin_slave::~i2cEngin_slave()
{
	ESP_ERROR_CHECK(this->interruptRequestReset());

	ESP_ERROR_CHECK(i2c_del_slave_device(handler_i2c_dev_slave));
	printf("%s bus has been destructed.\r\n", this->TAG);
	
	//usuwanie kolejki nadawczej oraz danych, które są poinicjowane (danych, do których wskazują wskaźniki ze struktury i2cFrame_transmitQueue kolejki
	//delete this->pTransmitQueueObject;
}

/*---------------------------------------------------------------
 * Metoda wpisuje dane do bufora nadawczego esp32 po i2c w trybie
 * slave. Dane pobierane są z kolejki QueueReceive obiektu
 * pTransmitQueueObject.
 * Parameters:
 * NONE
 * Returns:
 * esp_err_t 				- ESP_OK lub ESP_FAIL
*---------------------------------------------------------------*/
//esp_err_t i2cEngin_slave::slaveTransmit()
//{
//	esp_err_t retVal =ESP_FAIL;
//	i2cFrame_transmitQueue ItemWithPointerToTransmit;
//	
//	if (pdPASS == this->pTransmitQueueObject->QueueReceive(&ItemWithPointerToTransmit, portMAX_DELAY)) //kolejka zawiera dane;
//	{
//		
//		
//		retVal = this->slaveTransmit(ItemWithPointerToTransmit);
//						/*
//		retVal= i2c_slave_transmit(handler_i2c_dev_slave, (const uint8_t*) &ItemWithPointerToTransmit.dataSize, sizeof(ItemWithPointerToTransmit.dataSize), this->tx_timeout_ms);
//		if (ESP_OK == retVal)
//		{
//			retVal = i2c_slave_transmit(handler_i2c_dev_slave, (const uint8_t*) ItemWithPointerToTransmit.pData, ItemWithPointerToTransmit.dataSize, this->tx_timeout_ms);
//		}
//		
//		this->interruptRequestSet();
//		this->interruptRequestReset();
//		this->pTransmitQueueObject->QueueDeleteDataFromPointer(ItemWithPointerToTransmit);		*/
//			
//	}
//	return retVal;	
//}




esp_err_t i2cEngin_slave::i2cSlaveTransmit(void)
{
	
	i2cFrame_transmitQueue dataToTransmit;
	esp_err_t retVal = ESP_FAIL;
	if (this->i2cSlaveTransmitDataQueue->QueueReceive(&dataToTransmit, portMAX_DELAY)	== pdTRUE)
	{
//		return this->slaveTransmit(dataToTransmit);
		
		
//		esp_err_t slaveTransmit(i2cFrame_transmitQueue ItemWithPointer);
		
		
//		esp_err_t retVal = ESP_FAIL;
		retVal = i2c_slave_transmit(handler_i2c_dev_slave, (const uint8_t*) &dataToTransmit.dataSize, sizeof(dataToTransmit.dataSize), this->tx_timeout_ms);
		if (ESP_OK == retVal)
		{
			retVal = i2c_slave_transmit(handler_i2c_dev_slave, (const uint8_t*) dataToTransmit.pData, dataToTransmit.dataSize, this->tx_timeout_ms);
		}
		
		this->interruptRequestSet();
		this->interruptRequestReset();
		delete[] static_cast<char*>(dataToTransmit.pData);
		return retVal;
		
		
	}
	return pdFALSE;
	
}



/*
esp_err_t i2cEngin_slave::slaveTransmit(i2cFrame_transmitQueue ItemWithPointer)
{
	esp_err_t retVal = ESP_FAIL;
	retVal = i2c_slave_transmit(handler_i2c_dev_slave, (const uint8_t*) &ItemWithPointer.dataSize, sizeof(ItemWithPointer.dataSize), this->tx_timeout_ms);
	if (ESP_OK == retVal)
	{
		retVal = i2c_slave_transmit(handler_i2c_dev_slave, (const uint8_t*) ItemWithPointer.pData, ItemWithPointer.dataSize, this->tx_timeout_ms);
	}
		
	this->interruptRequestSet();
	this->interruptRequestReset();
	delete[] static_cast<char*>(ItemWithPointer.pData);
	return retVal;
}	   */



/*---------------------------------------------------------------
 * Konstruktor klasy odpwiadającej za komunikację ESP32 po i2c z
 * urządzeniami i2c slave.
 * Parameters:
 * i2c_port_num_t i2c_port	- numer portu i2c w kontrolerze ESP32
 * gpio_num_t sda_io_num	- numer pinu kontrolera ESP32 do którego
 *							  przypisano sygnał SDA szyny i2c
 * gpio_num_t scl_io_num	- numer pinu kontrolera ESP32 do którego
 *							  przypisano sygnał SCL szyny i2c
 * Returns:
 * NONE
*---------------------------------------------------------------*/
i2cEngin_master::i2cEngin_master(i2c_port_num_t i2c_port, gpio_num_t sda_io_num, gpio_num_t scl_io_num)
{
	i2c_bus_config_master.clk_source = I2C_CLK_SRC_DEFAULT;
	i2c_bus_config_master.i2c_port = i2c_port;
	i2c_bus_config_master.scl_io_num = scl_io_num;
	i2c_bus_config_master.sda_io_num = sda_io_num;
	i2c_bus_config_master.glitch_ignore_cnt = 7;
	i2c_bus_config_master.flags.enable_internal_pullup = false;

	phandler_i2c_bus = &handler_i2c_bus_master;
	assert(!i2c_new_master_bus(&i2c_bus_config_master, phandler_i2c_bus));
	this->devicesOnBus = 0;
		
	vTaskDelay(pdMS_TO_TICKS(50));
	this->xI2CMasterMutex = NULL;
	this->xI2CMasterMutex = xSemaphoreCreateMutex();
	assert(this->xI2CMasterMutex);
	//xSemaphoreGive(this->xI2CMasterMutex);
	this->semaphoreGive();
	printf("%s bus has been initialised on port %d.\r\n", this->TAG, i2c_port);

}

/*---------------------------------------------------------------
 * Metoda pozwalająca sprawdzić czy urządzenie slave o adresie 	
 * i2c_address jest dostępne na szynie i2c.
 * Parameters:
 * uint8_t i2c_address	- adres i2c urządzenia slave 8-bit 
 * Returns:
 * esp_err_t ret		-  ESP_OK, ESP_FAIL, etc
*---------------------------------------------------------------*/
esp_err_t i2cEngin_master::i2cPing(uint8_t i2c_address)
{
	//xSemaphoreTake(this->xI2CMasterMutex, portMAX_DELAY);
	this->semaphoreTake();
	esp_err_t ret = i2c_master_probe(*phandler_i2c_bus, i2c_address, 150);
	//xSemaphoreGive(this->xI2CMasterMutex);
	this->semaphoreGive();
	if (ret == ESP_OK) {
		printf("%s, master have detected I2C slave device with address 0x%x.\r\n", this->TAG, i2c_address);
	}
	else {
		printf("%s master HAVE NOT detected I2C slave device with address 0x%x.\r\n", this->TAG, i2c_address);
	}
	return ret;
}


/*---------------------------------------------------------------
* Metoda rejestruje dodane do szyny i2c urządzenie typu slave.
* Jest to metoda pomocnicza dostarczająca dane wykorzystywane
* przy destruktorze obiektu.
* Parameters:
* NONE
* Returns:
* uint16 devicesOnBus	-  aktualna ilość urządzeń na szynie i2c
*---------------------------------------------------------------*/
uint16_t i2cEngin_master::devicesOnBusIncrement()
{
	if (this->devicesOnBus == UINT16_MAX)
		assert(0);
		#warning napisać jakąś leprzą pbsługę błędów
		//TODO:	 napisać jakąś leprzą pbsługę błędów
	else
		this->devicesOnBus++;	
	return this->devicesOnBus;
}


/*---------------------------------------------------------------
* Metoda rejestruje usunięte z szyny i2c urządzenie typu slave.
* Jest to metoda pomocnicza dostarczająca dane wykorzystywane
* przy destruktorze obiektu.
* Parameters:
* NONE
* Returns:
* uint16 devicesOnBus	-  aktualna ilość urządzeń na szynie i2c
*---------------------------------------------------------------*/
uint16_t i2cEngin_master::devicesOnBusDecrement()
{
	if (this->devicesOnBus == 0)
		assert(0);
		#warning napisać jakąś leprzą pbsługę błędów
		//TODO:	 napisać jakąś leprzą pbsługę błędów
	else
		this->devicesOnBus--;
	return this->devicesOnBus;
}

/*---------------------------------------------------------------
* Destruktor klasy odpwiadającej za komunikację ESP32 po i2c z
* urządzeniami i2c slave.
* Parameters:
* NONE
* Returns:
* NONE
*---------------------------------------------------------------*/
i2cEngin_master::~i2cEngin_master()
{
	if (this->devicesOnBus == 0) {
		//xSemaphoreTake(this->xI2CMasterMutex, portMAX_DELAY);
		this->semaphoreTake();
		i2c_del_master_bus(*phandler_i2c_bus);
		vSemaphoreDelete(this->xI2CMasterMutex);
		printf("%s bus has been destructed.\r\n", this->TAG);
	}
	else
	{
		printf("%s there is  %d devices on bus. You CAN NOT use object destructor \(~i2cEngin_master\).\r\n", this->TAG, this->devicesOnBus);
		assert(0);
	}	
}

BaseType_t i2cEngin_master::semaphoreTake(void)
{
	return xSemaphoreTake(this->xI2CMasterMutex, portMAX_DELAY);
}
BaseType_t i2cEngin_master::semaphoreGive(void)
{
	return xSemaphoreGive(this->xI2CMasterMutex);
}

mój taskFnctions.cpp to:
#include "tasksFunctions.h"
#include "tasksFunctions/tasksFunctionsLeds.h"
#include "tasksFunctions/tasksFunctionsStepperMotor.h"
#include "tasksFunctions/tasksFunctionsStorage.h"
#include "i2c_engine/i2c_engine.h"


//static QueueHandle_t handlerQueue_i2cSlaveSetBuffer_keyboard;		//wskaźnik do kolejki przechowującej dane jakie mają być wysłane po i2c z ESP32 do STM32
//static SemaphoreHandle_t handlerMutex_ledDisplay_Backlight;	//mutex synchronizujący wyświetlanie komunikatów ledów (source, equaliser, error) i podświetlenia (backlight);

//static NVS* pSTORAGE;					//obiekt zapisujący i czytający dane z NCS ESP32
//extern LEDS_BACKLIGHT *pLedDisplay;		//obiekt sterujący pracą ledów (diody i backlioght)
//static 	StepperOptoPowerOFF * pMotor;	//obiekt sterujący pracą silnika krokowego, jego krańcówej i power off radia
static i2cEngin_slave *p_i2cSlave;		//obiekt sterujący komunikacją z stm32 po szynie i2c


/*---------------------------------------------------------------
* Funkcja, która poowinna być wywołana jak najwcześniej, a której
* zadaniem jest zainicjowanie handlerów, które sa niezbedne do
* prawidłowego działania tasków. Handlery w obrębie includa są
* GLOBALNE, ale jako, że mają atrybut STATIC nie są widoczna poza
* jego obrębem.
* Parameters:
* NONE
* Returns:
* NONE
 *---------------------------------------------------------------*/ 
void taskFunctionsStaticHandlersInit(void)
{

	//tworzenie obiektu i2cSlave komunikującewgo się STM32 po szynie i2c
	printf("I2C slave bus init\n");
	p_i2cSlave = nullptr;
	assert(p_i2cSlave = 	new i2cEngin_slave(I2C_SLAVE_PORT, I2C_SLAVE_PIN_SDA, I2C_SLAVE_PIN_SCL, I2C_SLAVE_ADDRESS_ESP32, I2C_ADDR_BIT_LEN_7, I2C_SLAVE_INTERRUP_REQUEST_PIN));
	
	
	//assert(p_i2cSlave);
	
	//tworzenie kolejki bufora nadawczego i2c
	//handlerQueue_i2cSlaveSetBuffer_keyboard = NULL;
	//configASSERT(handlerQueue_i2cSlaveSetBuffer_keyboard = xQueueCreate(I2C_SLAVESET_BUFFER_KEYBOARD_LEN, sizeof(i2cFrame_keyboardFrame))); 
	//configASSERT(handlerQueue_i2cSlaveSetBuffer_keyboard);
	//configASSERT(p_i2cSlave->addQueueToSet(handlerQueue_i2cSlaveSetBuffer_keyboard));

	
	
	
	
	
	
	
/*
	//tworzenie semafora dla punktu aktualizacji zmiennych przechowujących dane o ledach
	handlerMutex_ledDisplay_Backlight = NULL; //czyści wskaźnik mutex'u dla podświetlenia	i diód sygnalizacyjnych, bo kilka tasków bedzi ekorzystać z linii komunikacyjnej WS2812 		
	configASSERT(handlerMutex_ledDisplay_Backlight = xSemaphoreCreateBinary()); //tworzy mutex dla podświetlenia
	xSemaphoreGive(handlerMutex_ledDisplay_Backlight);	
*/
	
	
	
	
	
	//tworzy obiekt obsługujący NVS flash radio
	printf("NVS storage init\n");
	assert(pSTORAGE = new NVS(NVS_RADIO_CONFIG_NAMESPACE));
	//storage->CAUTION_NVS_ereaseAndInit(NVS_EREASE_COUNTDOWN_TIME);
	
	//tworzy obiekt obsługujący ledy sygnalizacyjne i podświetlenia
	printf("Backlight and display leds init\n");
	assert(pLedDisplay = new LEDS_BACKLIGHT(LED_DISPLAY_GPIO, LED_DISPLAY_LEDS_QUANTITY, LED_PIXEL_FORMAT_GRB, LED_MODEL_WS2812));
	pLedDisplay->ledStripClearAll();
	
	//tworzy obiekt obsługujący szyne i2c master komunikującą się z  MCP23008
	printf("I2C master bus init\n");
	i2cEngin_master *p_i2cMaster = new i2cEngin_master(I2C_MASTER_PORT, I2C_MASTER_PIN_SDA, I2C_MASTER_PIN_SCL);
	assert(p_i2cMaster);
	// sprawdza czy MCP23008 jest dostępny na szynie i2c
	assert(!p_i2cMaster->i2cPing(MCP23008_I2C_DEVICE_OPCODE));
	//tworzy obiekt obsługujący transmisję danych z MCP23008
	printf("MCP23008 on I2C master bus init\n");
	MCP23008* p_MCP23008 = new MCP23008(MCP23008_I2C_DEVICE_OPCODE, p_i2cMaster, I2C_MASTER_SPEED);
	assert(p_MCP23008);
	
	
	
	//tworzy obiekt obsługujący silnik krokowy, krańsówki i power off radia
	printf("Stepper motor and powerOFF gpio init\n");
	assert(pMotor = new StepperOptoPowerOFF(p_MCP23008));
	
	
}


/*---------------------------------------------------------------
* Lokalna funkcja odpowiadająca za wyłaczenia zasilania hardware'u
* wykonane przez ESP32
* Parameters:
* NONE
* Returns:
* NONE
*---------------------------------------------------------------*/ 
//static void hardwarePowerOFF(void)
//{
//	pMotor->radioPowerOFF();
//}

/*---------------------------------------------------------------
* Lokalna funkcja potrzebna na etapie programownaia. Poprzez tę 
* funkcję sprawdzam czy do taska parsującego dane z klawiatury
* wpływają popraswen dane i dane sa poprawenie przetważane
* Parameters:
* keyboardUnion DataToParse - unia zawierająca dane na temat stanu
*				klawiszy
* Returns:
* NONE
*---------------------------------------------------------------*/ 
static void keyboardQueueParametersParserPrintf(keyboardUnion DataToParse)
{
	switch (DataToParse.array[0])
	{
	case HMI_INPUT_BUTTON:
	case HMI_INPUT_BUTTON_LONG_AND_PRESSED:	
		printf("KBRD %c: %x\n", DataToParse.array[0], DataToParse.kbrdValue.value);					
		break;	
	case HMI_INPUT_VOLUME:
	case HMI_INPUT_EQUALISER:
		//if ((DataToParse.encoderValue.value == ENCODER_PULSED_PER_DETANT) || (DataToParse.encoderValue.value == -ENCODER_PULSED_PER_DETANT))
		printf("ENC %c: %d\n", DataToParse.array[0], DataToParse.encoderValue.value);
		break;
	}
	
}


/*---------------------------------------------------------------
* Lokalna funkcja, ktora sprawdza czy dane otrzymane z obsługi
* przerwania klawiatury są poprawne (chodzi głównie o dane z
* enkodera, gdzie jeśli wartość nie jest równa +detand lub -detand
* to nastąpił błąd debounceowania enkodera i uszkodzonych danych
* nie warto wysyłać do MCU mastera).
* Parameters:
* keyboardUnion keyboardDataToCheck - unia zawierająca dane z
*		klawiatury jakie należy sprawdziź pod kątem ich poprawności
* Returns:
* bool - pdTrue jeśli dane są poprawne, pdFalse jeśli dane nie są
*		poprawne.
*---------------------------------------------------------------*/ 
static bool keyboardQueueParameters_isComunicationWithI2CMasterRequired(keyboardUnion keyboardDataToCheck)
{
	//sprawdza czy dane do parsowania pochodzą z przyciskow (short press/ long on press/ long press release)
	if ((keyboardDataToCheck.array[0] == HMI_INPUT_BUTTON) || (keyboardDataToCheck.array[0] == HMI_INPUT_BUTTON_LONG_AND_PRESSED))
	{
		return pdTRUE; 
	}
			
	//sprawdza czy dane do parsowania pochodzą z enkoderów
	if ((keyboardDataToCheck.array[0] == HMI_INPUT_VOLUME) || (keyboardDataToCheck.array[0] == HMI_INPUT_EQUALISER))
	{
		//sprawdza czy dane z enkoderów sa poprawne, tzn. czy są równie +/- encoder detant
		if ((keyboardDataToCheck.encoderValue.value == ENCODER_PULSED_PER_DETANT) || (keyboardDataToCheck.encoderValue.value == -ENCODER_PULSED_PER_DETANT)) {
			return pdTRUE;
		}
	}
	return pdFALSE;
}

/*---------------------------------------------------------------
* Lokalna funkcja, ktora sprawdza czy dane otrzymane z klawiatury
* to LONG BUT_0 lub LONG BUT0+BUT6. Jeśli tak to realizowany jest
* restart radio (bez zapisywania NVS) lub restart radio z resetem
* NVS.
* Parameters:
* keyboardUnion keyboardDataToCheck - unia zawierająca dane z
*		klawiatury jakie należy sprawdziź pod kątem ich poprawności
* Returns:
* NONE
*---------------------------------------------------------------*/ 
static void keyboardQueueParameters_isEmergencyResetRequired(keyboardUnion keyboardDataToCheck)
{
	printf("Queue feeding error\n");
	if (keyboardDataToCheck.kbrdValue.input == HMI_INPUT_BUTTON)	//long press release button event
	{
		switch (keyboardDataToCheck.kbrdValue.value)
		{
		case (0xfe):			//BUT0	long presses = musi być taki sam jak w keyboardToFunction_buttonDefinitions.h STM32 dla POWER_ON_OFF_LONG_PRESS
		//case (LONG_PRESS_BIT_MASK | (0xff & ~(1 << 0))):			//BUT0	presses	= emergency reset aka {'B', 0xfe}
			printf("Emergency hardware restart\n");
			//hardwarePowerOFF();
			pMotor->radioPowerOff();
			break;
		case (0xa3):			// BUT2_BUT3_BUT4_EQUALIZER_LONG_RELEASED = musi być taki sam jak w keyboardToFunction_buttonDefinitions.h STM32 dla RESET_TO_DEFAULT 
			//case (LONG_PRESS_BIT_MASK | (0xff & ~(1 << 2) & ~(1 << 3) & ~(1 << 4) & ~(1 << 6))): //BUT0+BUT6 presses = NVS reset + emergency reset  aka {'b', 0xa3}     BUT2_BUT3_BUT4_EQUALIZER_LONG_RELEASED
			printf("Emergency NVS reset\n");
			pSTORAGE->CAUTION_NVS_ereaseAndInit(10);
			printf("Please restart device\n");
			break;
		}
	}				
}


/*---------------------------------------------------------------
* Funkcja sprawdza czy wartości znajdujące się w kolejce klawiatury
* są poprawne (*głównie chodszi tutaj o wartości z enkoderów) i
* jeśli sa poprawne to przekazuje je do kolejki i2cFrame (kolejka
* z której dane są wysyłane do stm32).
* Parameters:
* void *parameters - uchwyt do kolejki zawiwerasjącej dane
*				z przerwania klawiatury
* Returns:
* NONE
*---------------------------------------------------------------*/ 
void keyboardQueueParametersParser(void *parameters)
{
	QueueHandle_t handlerParameterAsKeyboard = (QueueHandle_t) parameters; //uchwyt który przekazuje fo taska parametr z funkcji MAIN (handlerQueue_MainKeyboard
	//bool isComunicationWithI2CMasterRequired;// = pdFALSE;
	//BaseType_t queueFeedRetVal;
	keyboardUnion keyboardDataToParse;		//bufor do którego będa kopiowane dane z kolejki klawiatury, i który bedzi eporzetwarzany w pętli for
	//keyboardDataToParse.array[0] = 0;		//zerowanei bufora
	//keyboardDataToParse.array[1] = 0;		//zerowanei bufora
	i2cFrame_keyboardFrame kbrdDataToI2CSlaveTransmittQueueTemoraryVariable;
		
	//keyboardDataToI2cTransmittQueue.frameSize = sizeof(keyboardDataToI2cTransmittQueue.frameSize) + sizeof(keyboardDataToI2cTransmittQueue.commandGroup) + sizeof(keyboardDataToI2cTransmittQueue.commandData);
	kbrdDataToI2CSlaveTransmittQueueTemoraryVariable.i2cframeCommandHeader.commandGroup = I2C_COMMAND_GROUP_KEYBOARD;
	kbrdDataToI2CSlaveTransmittQueueTemoraryVariable.i2cframeCommandHeader.dataSize = sizeof(i2cFrame_keyboardFrame /*keyboardUnion*/ /*keyboardDataToParse*/);
	for (;;)
	{
		if (xQueueReceive(handlerParameterAsKeyboard, &keyboardDataToParse, portMAX_DELAY))
		{
			if (keyboardQueueParameters_isComunicationWithI2CMasterRequired(keyboardDataToParse))		//sprawdza czy dane z przerwania klawiatury są poprawne, jeśli tak to przystępuje do ich przesłania do kolejki nadawczej I2C slave
			{
				memcpy(&kbrdDataToI2CSlaveTransmittQueueTemoraryVariable.keyboardData, &keyboardDataToParse, sizeof(keyboardUnion));
				
				kbrdDataToI2CSlaveTransmittQueueTemoraryVariable.i2cframeCommandHeader.crcSum = (uint8_t) calculate_checksum(&kbrdDataToI2CSlaveTransmittQueueTemoraryVariable/*&keyboardDataToParse*/, sizeof(i2cFrame_keyboardFrame/*keyboardDataToParse*/));
				
				
				

				#warning zastanowić się jak poprawić funkcję "esp32PrepareKbrdDataAndSent_to_QueueSend" bo to proteza, która nie za bardzo mi się podoba
				//if (p_i2cSlave->pTransmitQueueObject->esp32PrepareKbrdDataAndSent_to_QueueSend(&kbrdDataToI2CSlaveTransmittQueueTemoraryVariable, sizeof(i2cFrame_keyboardFrame)) != pdTRUE/*ESP_OK*/)	//to nigdy nie zajdzie, bo kolejka zawsze będzie karmiona, bo zawsze karmi inną
				if(esp32PrepareKbrdDataAndSent_to_QueueSend(&kbrdDataToI2CSlaveTransmittQueueTemoraryVariable, sizeof(i2cFrame_keyboardFrame)) != pdTRUE/*ESP_OK*/)	//to nigdy nie zajdzie, bo kolejka zawsze będzie karmiona, bo zawsze karmi inną
				{
					#warning   obsługę błędów komunikacji (jeśli są błędy komunikacji i jeśli nie ma sygnału keep alive, nie wiem czy tutaj ale zrobnić
					keyboardQueueParameters_isEmergencyResetRequired(kbrdDataToI2CSlaveTransmittQueueTemoraryVariable.keyboardData/*keyboardDataToParse*/);
				}
				//----------------------------------------------------------------------//
				//poniższa funkcja jest tylko do celów debugowania poprawności programu
				//keyboardQueueParametersParserPrintf(keyboardDataToParse);
			}		
		}
	}
}

/*---------------------------------------------------------------
* Funkcja statyczna (lokalna) której zadaniem jest wpisane danych
* pochodzących z klawiatury do bufora nadawczego esp32 po i2c jako
* slave. Dane wysyłane są do i2c master.
* Parameters:
* const i2cFrame_keyboardFrame * pvItemToQueue - struktura zawierająca
							dane odczytane z klawiatury
* size_t itemSize		- rozmiar struktury i2cFrame_keyboardFrame
* Returns:
* BaseType_t  - pdTrue lub pdFALSE
*---------------------------------------------------------------*/ 
static BaseType_t esp32PrepareKbrdDataAndSent_to_QueueSend(const i2cFrame_keyboardFrame * pvItemToQueue, size_t itemSize)
{
	i2cFrame_transmitQueue dataToTransmitQueue;
	dataToTransmitQueue.pData = new char[sizeof(itemSize)];
	assert(dataToTransmitQueue.pData);
	if (dataToTransmitQueue.pData != NULL)
	{
		memcpy(dataToTransmitQueue.pData, pvItemToQueue, itemSize);
		dataToTransmitQueue.dataSize = itemSize;
		///*********************/
		/*			if (xQueueSend(this->handler_Queue, &dataToTransmitQueue, pdMS_TO_TICKS(700)) == pdTRUE)
					{
						return pdTRUE;
			}
			else
			{
				this->QueueDeleteDataFromPointer(dataToTransmitQueue);
				//delete[] static_cast<char*>(pointerToData);
				return pdFALSE;
			}	*/
			///*********************/			
		//return this->QueueSend(&dataToTransmitQueue);
		//return p_i2cSlave->pTransmitQueueObject->QueueSend(&dataToTransmitQueue);
		//return p_i2cSlave->slaveTransmit(dataToTransmitQueue);
		return p_i2cSlave->i2cSendDataToTransisionQueue(&dataToTransmitQueue);
		
		
/*		if (p_i2cSlave->slaveTransmit(dataToTransmitQueue) == ESP_OK)
			return pdTRUE;
		else
			return pdFALSE;		*/
	}
	else
	{
		return pdFALSE;
	}	
}

/*
void humanMahineBacklightLeds(void *lnothing)
{
	colorSet baclightLedsLocal;
	baclightLedsLocal.primary = { 120, 120, 120 };
	const uint8_t COLOR_DIFFERENCE = 50;
		
	//xSemaphoreTake(handlerMutex_ledDisplay_Backlight, portMAX_DELAY);
	pLedDisplay->SemaphoreTake(portMAX_DELAY);
	pLedDisplay->ledStripSet_backlightLeds(baclightLedsLocal.primary);
	pLedDisplay->ledStripRefresh();
	
	if (baclightLedsLocal.primary.red <= 127)
	{
		baclightLedsLocal.secondary.red = baclightLedsLocal.primary.red + COLOR_DIFFERENCE;
	}
	else
	{
		baclightLedsLocal.secondary.red = baclightLedsLocal.primary.red - COLOR_DIFFERENCE;
	}
	if (baclightLedsLocal.primary.green <= 127)
	{
		baclightLedsLocal.secondary.green = baclightLedsLocal.primary.green + COLOR_DIFFERENCE;
	}
	else
	{
		baclightLedsLocal.secondary.green = baclightLedsLocal.primary.green - COLOR_DIFFERENCE;
	}
	
	if (baclightLedsLocal.primary.blue <= 127)
	{
		baclightLedsLocal.secondary.blue = baclightLedsLocal.primary.blue + COLOR_DIFFERENCE;
	}
	else
	{
		baclightLedsLocal.secondary.blue = baclightLedsLocal.primary.blue - COLOR_DIFFERENCE;
	}
	//xSemaphoreGive(handlerMutex_ledDisplay_Backlight);
	pLedDisplay->SemaphoreGive();
	
	
		
	for (;;)
	{
		vTaskSuspend(NULL);
		//xSemaphoreTake(handlerMutex_ledDisplay_Backlight, portMAX_DELAY);
		pLedDisplay->SemaphoreTake(portMAX_DELAY);
		pLedDisplay->ledStripSet_backlightLeds(baclightLedsLocal.secondary);
		pLedDisplay->ledStripRefresh();
		//xSemaphoreGive(handlerMutex_ledDisplay_Backlight);
		pLedDisplay->SemaphoreGive();
		vTaskDelay(pdMS_TO_TICKS(150));
		
		//xSemaphoreTake(handlerMutex_ledDisplay_Backlight, portMAX_DELAY);
		pLedDisplay->SemaphoreTake(portMAX_DELAY);
		pLedDisplay->ledStripSet_backlightLeds(baclightLedsLocal.primary);
		pLedDisplay->ledStripRefresh();
		//xSemaphoreGive(handlerMutex_ledDisplay_Backlight);
		pLedDisplay->SemaphoreGive();
	}
}

void humanMahineDisplayLeds(void *nothiong)
{
	hmiLeds ledsLocal;
	const uint16_t blinkTime = LED_DISPLAY_BLINK_TIME;
	
	ledsLocal.errorLed.primary = { 128, 0, 0 };
	ledsLocal.errorLed.secondary = {0, 0, 0 };	
	
	ledsLocal.sourceLed.primary = { 0, 0, 0 };	
	ledsLocal.sourceLed.secondary = { 0, 0, 0 };	
	
	ledsLocal.equaliserLed.primary = { 0, 0, 0 };	
	ledsLocal.equaliserLed.secondary = { 0, 0, 0 };
	
	
	uint8_t ledsPrimarySecondary = 0;
	i2cFrame_transmitQueue tempBuffer;
	
	for (;;)
	{
		//xSemaphoreTake(handlerMutex_ledDisplay_Backlight, portMAX_DELAY);
		if (pLedDisplay->QueueReceiveFormI2cParsingTask(&tempBuffer, pdMS_TO_TICKS(LED_DISPLAY_BLINK_TIME)) == pdTRUE)
		{
			//i2cFrame_hmiLeds* tempHmiLedsFrame;
			//tempHmiLedsFrame = (i2cFrame_hmiLeds*) tempBuffer.pData; 
			//memcpy(&ledsLocal, &tempHmiLedsFrame->ledsData, sizeof(hmiLeds));
			memcpy(&ledsLocal, tempBuffer.pData + sizeof(i2cFrame_commonHeader), sizeof(hmiLeds));
			pLedDisplay->QueueDeleteDataFormI2cParsingTask(tempBuffer);
		}
		
		
		
		pLedDisplay->SemaphoreTake(portMAX_DELAY);
			
			if (pLedDisplay->areEqual(&ledsLocal.equaliserLed)&&
				pLedDisplay->areEqual(&ledsLocal.errorLed)&&
				pLedDisplay->areEqual(&ledsLocal.sourceLed))		//if all leds primary == secondary
		{
			pLedDisplay->ledStripSet_sourceLed(ledsLocal.sourceLed.primary);								
			pLedDisplay->ledStripSet_equaliserLed(ledsLocal.equaliserLed.primary);
			pLedDisplay->ledStripSet_errorLed(ledsLocal.errorLed.primary);

			pLedDisplay->ledStripRefresh();

			
			//xSemaphoreGive(handlerMutex_ledDisplay_Backlight);
			pLedDisplay->SemaphoreGive();
			if (pLedDisplay->QueueMessagesWaiting() == 0)
			{
				extern TaskHandle_t handlerTask_ledDisplay;
				//vTaskSuspend(NULL); //all primary == secondary so suspend this task
				vTaskSuspend(handlerTask_ledDisplay);
			}
		}
		else		
		{																										//if at least one led primary != secondary
			
			switch (ledsPrimarySecondary)
			{
			case 0:
				pLedDisplay->ledStripSet_equaliserLed(ledsLocal.equaliserLed.primary);
				pLedDisplay->ledStripSet_errorLed(ledsLocal.errorLed.primary);
				pLedDisplay->ledStripSet_sourceLed(ledsLocal.sourceLed.primary);
				ledsPrimarySecondary = 1; //next time leds flip to secondary color
				break;
			case 1:
				pLedDisplay->ledStripSet_equaliserLed(ledsLocal.equaliserLed.secondary);
				pLedDisplay->ledStripSet_errorLed(ledsLocal.errorLed.secondary);
				pLedDisplay->ledStripSet_sourceLed(ledsLocal.sourceLed.secondary);
				ledsPrimarySecondary = 0; //next time leds flip to primary color
				break;
				
			}
			
			pLedDisplay->ledStripRefresh();
			pLedDisplay->SemaphoreGive();
			pLedDisplay->blinkTimeDelayLoop();
			
			
			
			//vTaskDelay(pdMS_TO_TICKS(LED_DISPLAY_BLINK_TIME));													//wait 1s till change color
		}
	}
}
 */

/*
static TaskHandle_t handlerTask_stepperMotorCalibration = NULL;
static TaskHandle_t handlerTask_stepperMotorMove = NULL;

static void stepperMotorCalibration(void* nothing)
{	uint16_t beginOffest;
	uint16_t endOffset;
	
	if(pSTORAGE->get_u16(NVS_KEY_MOTOR_BEGIN_OFFSET, &beginOffest)!= ESP_OK){
		beginOffest = 0;
	} 	
	if (esp_err_t retVal1 = pSTORAGE->get_u16(NVS_KEY_MOTOR_END_OFFSET, &endOffset) != ESP_OK)
	{
		endOffset = UINT16_MAX;	
	}
	vTaskSuspend(handlerTask_stepperMotorCalibration);
	for (;;)
	{
		if (pMotor->isCalibrated() == pdFALSE)
		{
			pMotor->measureSliderRange(beginOffest, endOffset);
		}
		
	}
}

static void stepperMotorMove(void* nothing)
{
	vTaskSuspend(handlerTask_stepperMotorMove);
	for (;;)
	{
		if (pMotor->isPositionReached() != pdTRUE)
		{
			pMotor->moveToVolatileDestinationPosition();
		}
		
	}
}


void stepperMotorDataParser(void *TaskParameters)
{
	configASSERT(xTaskCreatePinnedToCore(stepperMotorCalibration, "StepMotCalib", 3048, NULL, tskIDLE_PRIORITY + 1, &handlerTask_stepperMotorCalibration, TASK_TO_CORE1));
	configASSERT(xTaskCreatePinnedToCore(stepperMotorMove, "StepMotMov", 3048, NULL, tskIDLE_PRIORITY + 1, &handlerTask_stepperMotorMove, TASK_TO_CORE1));
	
	i2cFrame_transmitQueue tempBuffer;
	i2cFrame_stepper loclaStepperMotorFrame;
	for (;;)
	{
		if (pMotor->QueueReceiveFormI2cParsingTask(&tempBuffer, pdMS_TO_TICKS(100)) == pdTRUE)
		{
			memcpy(&loclaStepperMotorFrame, tempBuffer.pData, sizeof(i2cFrame_stepper));
			pMotor->QueueDeleteDataFormI2cParsingTask(tempBuffer);
			
			switch (loclaStepperMotorFrame.stepperData.stepperSubcommand)
			{
			case MOTOR_SUBCOMMAND_CALIBRATION:			//0x00
				pMotor->calibrationReset();	
				break;
			case MOTOR_SUBCOMMAND_GOTO_ABSOLUT:		//0x01
				pMotor->volatileDestinationBy_GotoAbsolutRange(loclaStepperMotorFrame.stepperData.stepperUnion.gotoPosition);
				break;
			case MOTOR_SUBCOMMAND_GOTO_IN_BOARDERS:	//0x02
				pMotor->volatileDestinationBy_GotoBoardertRange(loclaStepperMotorFrame.stepperData.stepperUnion.gotoPosition);
				break;
			case MOTOR_SUBCOMMAND_MOVE_BY_ABSOLUT:		//0x03
				pMotor->volatileDestinationBy_MoveByAbsoluteRange(loclaStepperMotorFrame.stepperData.stepperUnion.moveBy);	
				break;
			case MOTOR_SUBCOMMAND_MOVE_BY_BOARDER:		//0x04
				pMotor->volatileDestinationBy_MoveByBoarderRange(loclaStepperMotorFrame.stepperData.stepperUnion.moveBy);	
				break;
			case MOTOR_SUBCOMMAND_PERCENTS_ABSOLUT:	//0x05
				pMotor->volatileDestinationBy_PercentageAbsoluteRange(loclaStepperMotorFrame.stepperData.stepperUnion.percents);	
				break;
			case MOTOR_SUBCOMMAND_PERCENTS_BOARDER:	//0x06
				pMotor->volatileDestinationBy_PercentageBoarderRange(loclaStepperMotorFrame.stepperData.stepperUnion.percents);
				break;
			case MOTOR_SUBCOMMAND_POWER_OFF:		//0x07
				pMotor->radioPowerOffInSecond(loclaStepperMotorFrame.stepperData.stepperUnion.radioRestartCountdown);
				break;
			default:
				assert(0);
			}	
		}
		else
		{
			//sprawdza czy praca tasku zostałą zakończona
			if (
				eTaskGetState(handlerTask_stepperMotorCalibration) == eSuspended && pMotor->isCalibrated() &&
				eTaskGetState(handlerTask_stepperMotorMove) == eSuspended && pMotor->isPositionReached()) {
				//na wszelki wypadek sprawdza czy w kolejce do tasku nie ma żadnych nowych danych
				if (pMotor->QueueMessagesWaiting() == 0)
				{
					extern TaskHandle_t handlerTask_stepperMotorDataPasrser;
					//vTaskSuspend(NULL);
					//				vTaskSuspend(handlerTask_stepperMotorDataPasrser);
				}
			}
		}

		
		
		//sprawdza czy slider jest skalibrowany (jeśli NIE TO:)
		if (pMotor->isCalibrated() == pdFALSE)
		{
			// Sprawdź, czy task kalibracji nie jest zawieszony															
			if (eTaskGetState(handlerTask_stepperMotorCalibration) == eSuspended)
			{
				vTaskResume(handlerTask_stepperMotorCalibration);
			}
		}
		else //((pMotor->isCalibrated() == pdTRUE)
		{
			if (eTaskGetState(handlerTask_stepperMotorCalibration) != eSuspended)
			{
				vTaskSuspend(handlerTask_stepperMotorCalibration);
			}
			else if (!pMotor->isPositionReached() && eTaskGetState(handlerTask_stepperMotorMove) == eSuspended)
			{
				vTaskResume(handlerTask_stepperMotorMove);
			}
			else if (pMotor->isPositionReached() && (eTaskGetState(handlerTask_stepperMotorMove) != eSuspended))
			{
				vTaskSuspend(handlerTask_stepperMotorMove);
			}		
		}
	}
}

 */


void i2cSlaveTransmit(void *nothing)
{
	while (true)
	{
		p_i2cSlave->i2cSlaveTransmit();
	}
	
	
}

//Funkcja tasku zajmującego się odbieraniem otrzymanych przez i2c slave danych i przesyłaniem do kolejki danych.
// Dane trafiają do funkcji parsera i2c.
void i2cSlaveReceive(void *nothing)
{	
	p_i2cSlave->i2cSlaveReceive();
}

//Funkcja zajmuje się parsowaniem otrzymanych z i2cSlaveReceive danych
void i2cReceivedDataParser(void *nothing)
{	
	
	
	i2cFrame_transmitQueue parsingData;
	//parsingData.pData=nullptr_t;
	i2cFrame_commonHeader* fakeCommHeader; 
	uint8_t	crcSumCalculated;
	
	for (;;)
	{
		if(p_i2cSlave->i2cSlaveReceiveDataToDataParserQueue->QueueReceive(&parsingData, portMAX_DELAY)==pdTRUE)
		{
			//sprawdzanie czy CRC ma poprawną wartość
			fakeCommHeader = (i2cFrame_commonHeader*)parsingData.pData;
			
			crcSumCalculated = calculate_checksum(fakeCommHeader, fakeCommHeader->dataSize);
			if (crcSumCalculated == fakeCommHeader->crcSum)
			{
				//CRC sum correct - data correct
				p_i2cSlave->i2cMasterCrcSumCounterErrorReset();
				switch (fakeCommHeader->commandGroup)
				{
					//case I2C_COMMAND_GROUP_KEYBOARD:	0x01
					//	break;
					case I2C_COMMAND_GROUP_NVS: //0x02
						assert(0);
						break;
					case I2C_COMMAND_GROUP_LEDS:	//0x03
						extern TaskHandle_t handlerTask_ledDisplay;
						pLedDisplay->QueueSendDataToLedTask(&parsingData);
						pLedDisplay->blinkTimeMultiplierSetMaxValue();	//jeżeli jest mryganie to natychniast zostanie przerwana petla opóźniajaca
						vTaskResume(handlerTask_ledDisplay);
						break;
					case I2C_COMMAND_GROUP_STEPPER:		//0x04
						//extern TaskHandle_t handlerTask_stepperMotorDataPasrser;
						pMotor->QueueSendDataToMotorDataQueue(&parsingData);
						//vTaskResume(handlerTask_stepperMotorDataPasrser);
						break;
					default:
						//nie wiadomo do jakiej "commandGroup" należą dane więc jest jakiś bład trzeba je usunąć, aby nie było przepełnienia pamięci
						p_i2cSlave->i2cSlaveReceiveDataToDataParserQueue->QueueDeleteDataFromPointer(parsingData);	
						assert(0);
				}
			}
			else
			{
				assert(p_i2cSlave->i2cMasterCrcSumCounterErrorIncrement());	//tutaj powinien być reset radio jak będzie za dużo błędow
				p_i2cSlave->i2cSlaveReceiveDataToDataParserQueue->QueueDeleteDataFromPointer(parsingData);	
			}
			
			
		}
	}
}

Co mam źle w kodzie???