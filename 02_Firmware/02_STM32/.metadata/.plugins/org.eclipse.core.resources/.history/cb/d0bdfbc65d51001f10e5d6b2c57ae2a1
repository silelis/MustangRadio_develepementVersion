/*
 * esp32i2sComunicationDriver.cpp
 *
 *  Created on: Aug 2, 2024
 *      Author: dbank
 */

#include "esp32i2sComunicationDriver.h"

esp32_i2sComunicationDriver::esp32_i2sComunicationDriver(i2cMaster* pointer_to_i2cMasterObject) {
	// TODO Auto-generated constructor stub
		this->pi2cMaster = pointer_to_i2cMasterObject;
		configASSERT(this->esp32IntrrruptRequest_CountingSemaphore = xSemaphoreCreateCounting(this->esp32InterruptRequestCountingSemaphore_MAX, 0));
		esp32InrerruptRequest_CountingSemaphoreOverflow=pdFALSE;
}





HAL_StatusTypeDef esp32_i2sComunicationDriver::ping(void){
	return this->pi2cMaster->ping(this->esp32i2cSlaveAdress_7bit);
}

void esp32_i2sComunicationDriver::incrementInterruptRequestCountingSemaphore(void){
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	xSemaphoreGiveFromISR(this->esp32IntrrruptRequest_CountingSemaphore, &xHigherPriorityTaskWoken);
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

uint8_t esp32_i2sComunicationDriver::get_i2cSlaveAddress_7bit(void){
	return this->esp32i2cSlaveAdress_7bit;
}

esp32_i2sComunicationDriver::~esp32_i2sComunicationDriver() {
	// TODO Auto-generated destructor stub
	#warning zrobic porzadny destruktor
}

void esp32_i2sComunicationDriver::isCountingSemaphoreOverflowed(void){
	if( uxSemaphoreGetCount(this->esp32IntrrruptRequest_CountingSemaphore)== this->esp32InterruptRequestCountingSemaphore_MAX){		//sprawdza czy licznik esp32 interrupt request nie jest przepeÅ‚niony
		this->esp32InrerruptRequest_CountingSemaphoreOverflow= pdTRUE;
		printf("!!! ESP32 interrupt request counter overflowed   !!!\r\n");
	}
}

BaseType_t esp32_i2sComunicationDriver::semaphoreTake__CountingSemaphore(void){
	return xSemaphoreTake(this->esp32IntrrruptRequest_CountingSemaphore, portMAX_DELAY) == pdTRUE;
}

BaseType_t esp32_i2sComunicationDriver::receiveDataFromESP32(){
	this->pi2cMaster->i2cMasterSemaphoreTake();

	this->pi2cMaster->I2C_Master_Receive_DMA(this->get_i2cSlaveAddress_7bit(), pData, Size)





	this->pi2cMaster->i2cMasterSemaphoreGive();

}
