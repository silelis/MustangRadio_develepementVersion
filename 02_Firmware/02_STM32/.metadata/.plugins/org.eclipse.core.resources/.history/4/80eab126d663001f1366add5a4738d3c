/*
 * radioMenu.cpp
 *
 *  Created on: Aug 25, 2024
 *      Author: dbank
 */

#include <SileliS_code/radioMenu.h>

radioMenu::radioMenu() {
	// TODO Auto-generated constructor stub

	queueRadioMenuKbrd = nullptr;
	configASSERT(queueRadioMenuKbrd = xQueueCreate(20, sizeof(keyboardUnion)));
	taskHandle_manageTheRadioManue = nullptr;

	this->radioMainMenu		= nullptr;
	this->curretDevice		= nullptr;
	this->audioDevices		= nullptr;
	this->peripheryDevices 	= nullptr;

	//tworzenie manu peripheryDevices



	this->setCurrentDeviceList_onAudioDevices()
	//tworzę menu głowne radio do posługi klawiszy głownych tj. but_ON/OFF, long_but_ON/OFF,VOL_CW,VOL_CCW,but_EQU,long_but_EQU
	//tylko jedno płaskie menu, ktore zarządza pozostałymi
	this->radioMainMenu = new myList("MainMenu",5);
	//this->radioMainMenu->mI_appendExecFunctionArry(buttonSequence, newFunc)
}

void radioMenu::setCurrentDeviceList_onAudioDevices(void){
	this->curretDevice=this->audioDevices;
}

void radioMenu::setCurrentDeviceList_onPeripheryDevices(void){
	this->curretDevice=this->peripheryDevices;
}


BaseType_t radioMenu::queueRadioMenuKbrdSend(const void * kbrdUnion){
	return xQueueSend(this->queueRadioMenuKbrd, kbrdUnion, pdMS_TO_TICKS(700));
}

TaskHandle_t* radioMenu::getTaskHandle_tPointer(void){
	return &taskHandle_manageTheRadioManue;
}

void	radioMenu::manageTheRadioManue(void* noThink){
	keyboardUnion kbrdToRadioMenu;
	while(1)
	{
		if(xQueueReceive(this->queueRadioMenuKbrd, &kbrdToRadioMenu, portMAX_DELAY)){
			printf("%c 0x%02x  in hex: 0x%02x 0x%02x\r\n", kbrdToRadioMenu.array[0],kbrdToRadioMenu.array[1], kbrdToRadioMenu.array[0],kbrdToRadioMenu.array[1] );
		}
	}
}

radioMenu::~radioMenu() {
	// TODO Auto-generated destructor stub
	vTaskDelete(this->taskHandle_manageTheRadioManue);
	vQueueDelete(queueRadioMenuKbrd);

	delete [] this->radioMainMenu;
	delete [] this->curretDevice;
	delete [] this->audioDevices;
	delete [] this->peripheryDevices;
}

