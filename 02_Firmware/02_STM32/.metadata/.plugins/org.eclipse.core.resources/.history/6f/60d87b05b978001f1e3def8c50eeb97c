/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"
#include "dma.h"
#include "i2c.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
#include "queue.h"
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

/* USER CODE BEGIN Includes */
#define I2C_SLAVE_ADDRESS_ESP32  0x3C

typedef struct {
    uint8_t slaveDevice7bitAddress;   // Adres urządzenia slave (7-bitowy)
    size_t dataSize;                  // Rozmiar danych przesyłanych przez I2C
    void *pData;                      // Wskaźnik do danych
} i2cFrame_transmitQueue;

/* DMA Buffer alignment - region in RAM_D2 */
#define DMA_BUFFER __attribute__((section(".dma_buffer"))) __attribute__((aligned(32)))

DMA_BUFFER uint8_t tx_buffer[256];  // Bufor DMA dla I2C
void* testBuffer;

/* USER CODE END Includes */

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
    /* MCU Configuration--------------------------------------------------------*/

    /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    HAL_Init();

    /* Configure the system clock */
    SystemClock_Config();

    /* Initialize all configured peripherals */
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_USART1_UART_Init();
    MX_I2C1_Init();

    /* USER CODE BEGIN 2 */

    // Tworzenie kolejki FreeRTOS
    QueueHandle_t handler_Queue = xQueueCreate(20, sizeof(uint8_t));

    // Testowe dane
    char trash[] = "HelloABCDEF";

    // Inicjalizacja struktury do transmisji
    i2cFrame_transmitQueue testTransm;
    testTransm.slaveDevice7bitAddress = I2C_SLAVE_ADDRESS_ESP32 << 1;
    testTransm.dataSize = sizeof(trash);
    testTransm.pData = &trash;

    // Oblicz długość bufora
    size_t bufferLength = sizeof(testTransm.dataSize) + testTransm.dataSize;
    testBuffer = malloc(bufferLength);

    // Kopiowanie danych do bufora
    memcpy(testBuffer, &testTransm.dataSize, sizeof(testTransm.dataSize));
    memcpy(testBuffer + sizeof(size_t), testTransm.pData, testTransm.dataSize);

    // Czyszczenie pamięci cache przed transmisją DMA
    SCB_CleanDCache_by_Addr((uint32_t*)(((uint32_t)testBuffer) & ~(uint32_t)0x1F), bufferLength + 32);

    while (1) {
        // Sprawdzenie, czy I2C jest gotowe
        while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY) {};

        // Transmisja danych przez I2C z DMA
        HAL_StatusTypeDef retVal = HAL_I2C_Master_Transmit_DMA(&hi2c1, I2C_SLAVE_ADDRESS_ESP32 << 1, (uint8_t*)testBuffer, bufferLength);

        // Pętla opóźniająca między transmisjami
        for (uint32_t i = 0; i < 0xfffff; i++) {}

        // Czyszczenie pamięci cache po transmisji
        SCB_CleanDCache_by_Addr((uint32_t*)(((uint32_t)testBuffer) & ~(uint32_t)0x1F), bufferLength + 32);
    }

    /* USER CODE END 2 */

    /* Call init function for freertos objects (in cmsis_os2.c) */
    MX_FREERTOS_Init();

    /* Start scheduler */
    osKernelStart();

    /* Infinite loop */
    while (1)
    {
        /* USER CODE END WHILE */

        /* USER CODE BEGIN 3 */
    }
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    /* AXI clock gating */
    RCC->CKGAENR = 0xFFFFFFFF;

    /** Supply configuration update enable */
    HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);

    /** Configure the main internal regulator output voltage */
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);

    while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

    /** Initializes the RCC Oscillators */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
    RCC_OscInitStruct.HSICalibrationValue = 64;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
    RCC_OscInitStruct.PLL.PLLM = 4;
    RCC_OscInitStruct.PLL.PLLN = 35;
    RCC_OscInitStruct.PLL.PLLP = 2;
    RCC_OscInitStruct.PLL.PLLQ = 2;
    RCC_OscInitStruct.PLL.PLLR = 2;
    RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
    RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
    RCC_OscInitStruct.PLL.PLLFRACN = 0;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
    {
        Error_Handler();
    }

    /** Initializes the CPU, AHB and APB buses clocks */
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
        | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2
        | RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
    RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
    {
        Error_Handler();
    }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */
