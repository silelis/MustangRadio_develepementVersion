/*
 * menuItem.cpp
 *
 *  Created on: Aug 11, 2024
 *      Author: dbank
 */

#include "SileliS_code/menuItem.h"



menuItem::menuItem(const char* tag, uint8_t execFunctionArraySize) {
	if (execFunctionArraySize<= UINT8_MAX){
		this->TAG = tag;

		this->Init=nullptr;
		this->deInit = nullptr;

		this->pExecutableButtons = nullptr;
		this->create_pExecutableButtonsArray(execFunctionArraySize);
		printf("%s: menuItem with %d executable buttons had been created. Please append functiond.\r\n", this->TAG, this->execFunctionArrySize);
	}
};

void menuItem::delete_pExecutableButtonsArray(void){
	if (this->pExecutableButtons!=nullptr)
		delete [] pExecutableButtons;
}


bool menuItem::create_pExecutableButtonsArray(uint8_t arraySize){
	this->pExecutableButtons = new execute_t[arraySize];
	assert(this->pExecutableButtons);
	if (this->pExecutableButtons){
		memset(this->pExecutableButtons, 0, sizeof(execute_t)*arraySize);
		this->execFunctionArrySize=arraySize;
		this->execFunctionArryAppended = 0;
		return true;
	}
	return false;
}

void menuItem::appendFunctionPointer(void (**funcPtr)(), void (*newFunc)()){
	*funcPtr = newFunc;
}

void menuItem::executeFunctionPointer(void (*functionPointer)()){
	if (functionPointer)
		functionPointer();
	else
		printf("%s: Pointer to function is empty.\r\n", this->TAG);
}

void menuItem::appendInit(void (*newFunc)()) {
	appendFunctionPointer(&this->Init, newFunc);
}

void menuItem::executeInit(void){
	this->executeFunctionPointer(this->Init);
}

void menuItem::appendDeInit(void (*newFunc)()){
	appendFunctionPointer(&this->deInit, newFunc);
}

void menuItem::executeDeInit(void){
	this->executeFunctionPointer(this->deInit);
}

menuItem::~menuItem(){
	this->delete_pExecutableButtonsArray();
}

uint8_t menuItem::searchExecFunctionForButtonSequence(keyboardUnion buttonSequence){
	for(uint8_t i=0;i<this->execFunctionArryAppended;i++){
		if ((this->pExecutableButtons[i].buttonSequence.kbrdValue.input == buttonSequence.kbrdValue.input) &&
			(this->pExecutableButtons[i].buttonSequence.kbrdValue.value == buttonSequence.kbrdValue.value))
			{
			return i;
			}
	}
	return this->execFunctionArrySize;		//jeżeli zwraca warotść równią execFunctionArrySize to znaczy, żę sekwencja klawiszy nie znajduje się w tablicy
}

bool menuItem::isExecFunctionInButtonSequence(keyboardUnion buttonSequence){
	if (this->searchExecFunctionForButtonSequence(buttonSequence)==this->execFunctionArrySize)
		return false;
	return true;
}

void menuItem::executeExecutableButtons(keyboardUnion buttonSequence){
	uin8_t buttonSequenceArrayLocation = this->searchExecFunctionForButtonSequence(buttonSequence;
	if(buttonSequenceArrayLocation==this->execFunctionArrySize){ //gdy zwracana wartość jest równa execFunctionArrySize to znaczy, że nie ma zapamiętanej sekwencji klawiszy
		printf("%s: There is no buttonSequence with value of 0x%02x%02x in pExecutableButtonsaArry.\r\n", this->TAG, buttonSequence.array[0], buttonSequence.array[1]);
		//return;
	}
	else{
//this->executeFunctionPointer(this->pExecutableButtons[buttonSequenceArrayLocation].)
	this->pExecutableButtons[buttonSequenceArrayLocation].functionPointer;
	}

}
bool menuItem::appendExecFunctionArry(keyboardUnion buttonSequence,void (*newFunc)()){
	if (this->execFunctionArryAppended<this->execFunctionArrySize){
		if(!this->isExecFunctionInButtonSequence(buttonSequence)){
			this->pExecutableButtons[this->execFunctionArryAppended].buttonSequence=buttonSequence;
			this->appendFunctionPointer(&this->pExecutableButtons[this->execFunctionArryAppended].functionPointer, newFunc);
			this->execFunctionArryAppended++;
			printf("%s: %d button(s) are appended.\r\n", this->TAG, this->execFunctionArryAppended);
			return true;
		}
		else{
			printf("%s: Button sequence had already been appended in pExecutableButtonsaArry.\r\n", this->TAG);
		}

	}
	else{
		printf("%s: pExecutableButtonsaArry have not been appended. Array is full.\r\n", this->TAG);
	}
	return false;
}
