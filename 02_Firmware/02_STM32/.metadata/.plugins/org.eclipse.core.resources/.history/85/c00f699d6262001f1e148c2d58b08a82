#include "SileliS_code/myList.h"

// Inicjalizacja statycznych zmiennych
myList* myList::head = nullptr;
myList* myList::current = nullptr;
uint8_t myList::indexCounter = 0;

// Konstruktor
myList::myList(const char* nodeName, uint8_t execFunctionArraySize)
    : menuItem(nodeName, execFunctionArraySize) {
	if (head==nullptr){
		head=this;
	}
	next=nullptr;
	current=this;
	indexCounter++;
	this->index = indexCounter;
}

// Zwalnianie pamięci listy
void myList::freeList() {
    myList* temp;// = head;
    while (head!= nullptr) {
        temp = head;
        head = head->next;
        delete temp;
        temp = next;
        this->indexCounter--;
    }
    //head = nullptr;
    current = head; //nullptr;
    //indexCounter = 0;
}


// Destruktor
myList::~myList() {
	/*static bool destoying = false;
	if (!destoying) {
		freeList();
		destoying = true;
	}
	destoying = false;*/

    myList* temp;// = head;
    while (head!= nullptr) {
        temp = head;
        head = head->next;
        //delete temp;
        static_cast<void*>(temp);
        temp = next;
        this->indexCounter--;
    }
    //head = nullptr;
    current = head; //nullptr;
    //indexCounter = 0;

}

// Dodanie elementu na początku listy
void myList::addAtBeginning(const char* nodeName, uint8_t execFunctionArraySize) {
    if (!canAddItem()) return;

    myList* newNode = new myList(nodeName, execFunctionArraySize);
    newNode->next = head;
    head = newNode;
    current = newNode; // Ustawienie current na nowo dodany element
    renumberNodes();
}

// Dodanie elementu na końcu listy
void myList::addAtEnd(const char* nodeName, uint8_t execFunctionArraySize) {
    if (!canAddItem()) return;

    myList* newNode = new myList(nodeName, execFunctionArraySize);
    if (!head) {
        head = newNode;
    } else {
        myList* temp = head;
        while (temp->next) {
            temp = temp->next;
        }
        temp->next = newNode;
    }
    current = newNode; // Ustawienie current na nowo dodany element
    renumberNodes();
}

// Resetowanie current do pierwszego elementu listy
void myList::resetToFirst() {
    current = head;
}

// Przesunięcie current na następny element listy
myList* myList::moveToNext() {
    if (current) {
        current = current->next;
    }
    return current;
}

void 	myList::moveToNextInLoop(void){
	if(!moveToNext())
		resetToFirst();
	printCurrent();
}


// Zwracanie indeksu aktualnego węzła
uint8_t myList::getCurrentNodeIndex() const {
    return /*current ?*/ current->index /*: UINT8_MAX*/;
}

// Sprawdzanie, czy current znajduje się na końcu listy
bool myList::isAtEnd() const {
    return current == nullptr;
}

/*
// Usuwanie elementu z listy
void myList::removeElement(uint8_t indexToDelete) {
    if (!head) return;

    resetToFirst();
    myList* previous = head;
    while(current!=nullptr){
    	printCurrent();
    	if (current->index== indexToDelete){
    		previous->next=current->next;
    		break;
    	}

    	else{
    		moveToNext();
    	}
    }
    delete []current;
    printf("koniec\r\n");
    resetToFirst();
    //delete temp;
    //renumberNodes();
}*/

// Wydrukowanie wszystkich elementów listy
void myList::printList() const {
    myList* temp = head;
    while (temp){
    	printf("Node Index: %d, Name: %s.\r\n", temp->index, temp->TAG);
        //std::cout << "Node Index: " << (int)temp->index << ", Name: " << (temp->name ? temp->name : "Unnamed") << std::endl;
        temp = temp->next;
    }
}

// Wydrukowanie aktualnego elementu listy
void myList::printCurrent() const {
    if (current) {
    	printf("Current Node Index: %d, Name: %s.\r\n", current->index, current->TAG);
        //std::cout << "Current Node Index: " << (int)current->index << ", Name: " << (current->name ? current->name : "Unnamed") << std::endl;
    } else {
    	printf("No current node.\r\n");
        //std::cout << "No current node." << std::endl;
    }
}

// Renumeracja węzłów listy
void myList::renumberNodes() {
    myList* temp = head;
    uint8_t tempIndex = 0;
    while (temp) {
        temp->index = ++tempIndex;
        temp = temp->next;
    }
    //indexCounter = index;
}

// Sprawdzanie, czy można dodać element do listy
bool myList::canAddItem() const {
    return indexCounter < UINT8_MAX; // Maksymalna wartość uint8_t to 255, więc sprawdzamy, czy jest mniejsza niż 255
}
