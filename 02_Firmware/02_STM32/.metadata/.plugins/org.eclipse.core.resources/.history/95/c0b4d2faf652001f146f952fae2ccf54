/*
 * esp32i2sComunicationDriver.cpp
 *
 *  Created on: Aug 2, 2024
 *      Author: dbank
 */

#include "esp32i2cComunicationDriver.h"

esp32_i2cComunicationDriver::esp32_i2cComunicationDriver(i2cMaster* pointer_to_i2cMasterObject) {
	// TODO Auto-generated constructor stub
		this->pi2cMaster = pointer_to_i2cMasterObject;
		configASSERT(this->esp32IntrrruptRequest_CountingSemaphore = xSemaphoreCreateCounting(this->esp32InterruptRequestCountingSemaphore_MAX, 0));
		this->esp32DynamicmMemeoryAlocationError=this->esp32InrerruptRequest_CountingSemaphoreOverflowError=pdFALSE;
		this->esp32CrcSumCounterError=0;
}

BaseType_t esp32_i2cComunicationDriver::isCrcSumCorreect(i2cFrame_transmitQueue I2CReceivedFrame, uint8_t	crcSum){
	if(crcSum==calculate_checksum(I2CReceivedFrame.pData, sizeof(i2cFrame_keyboardFrame)))
	{
		this->esp32CrcSumCounterError=0;
		return pdPASS;
	}
	else{
		this->esp32CrcSumCounterError++;
		printf("%sCRC sum NOT correct: %d time(s)\r\n", this->TAG, this->esp32CrcSumCounterError);
		return pdFAIL;
	}
}




HAL_StatusTypeDef esp32_i2cComunicationDriver::ping(void){
	HAL_StatusTypeDef retVal;
	this->i2cMasterSemaphoreTake();
	this->pi2cMaster->while_I2C_STATE_READY();
	retVal = this->pi2cMaster->ping(this->esp32i2cSlaveAdress_7bit);
	this->i2cMasterSemaphoreGive();
	return retVal;
}

void esp32_i2cComunicationDriver::incrementInterruptRequestCountingSemaphore(void){
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	xSemaphoreGiveFromISR(this->esp32IntrrruptRequest_CountingSemaphore, &xHigherPriorityTaskWoken);
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/*
uint8_t esp32_i2sComunicationDriver::get_i2cSlaveAddress_7bit(void){
	return this->esp32i2cSlaveAdress_7bit;
}*/

esp32_i2cComunicationDriver::~esp32_i2cComunicationDriver() {
	// TODO Auto-generated destructor stub
	#warning zrobic porzadny destruktor
}

void esp32_i2cComunicationDriver::isCountingSemaphoreOverflowed(void){
	if( uxSemaphoreGetCount(this->esp32IntrrruptRequest_CountingSemaphore)== this->esp32InterruptRequestCountingSemaphore_MAX){		//sprawdza czy licznik esp32 interrupt request nie jest przepełniony
		this->esp32InrerruptRequest_CountingSemaphoreOverflowError= pdTRUE;
		printf("!!! ESP32 interrupt request counter overflowed   !!!\r\n");
	}
}

BaseType_t esp32_i2cComunicationDriver::semaphoreTake__CountingSemaphore(void){
	return xSemaphoreTake(this->esp32IntrrruptRequest_CountingSemaphore, portMAX_DELAY) == pdTRUE;
}

BaseType_t esp32_i2cComunicationDriver::masterReceiveFromESP32_DMA(uint8_t *pData, uint16_t Size){
	return this->pi2cMaster->I2C_Master_Receive_DMA(this->esp32i2cSlaveAdress_7bit, pData, Size);
}


BaseType_t esp32_i2cComunicationDriver::i2cMasterSemaphoreTake(void){
	return this->pi2cMaster->i2cMasterSemaphoreTake();
}

BaseType_t esp32_i2cComunicationDriver::i2cMasterSemaphoreGive(void){
	return this->pi2cMaster->i2cMasterSemaphoreGive();
}

void esp32_i2cComunicationDriver::while_I2C_STATE_READY(void){
	pi2cMaster->while_I2C_STATE_READY();
}


void esp32_i2cComunicationDriver::seteDynamicmMemeoryAlocationError(){
	this->esp32DynamicmMemeoryAlocationError=pdTRUE;
	printf("error with memory allocation\r\n");
}

void esp32_i2cComunicationDriver::parseReceivedData(i2cFrame_transmitQueue I2CReceivedFrame){
	i2cFrame_commonHeader tempI2cFrameCommandHeader;														//tymczasowa zmienna, do któej będa kopiowane otrzymane dane (aby zawsze uzyskać sumę crc z prawidłowego miejsca, nawert jeśli zmieni się typredef i2cFrame_commonHeader)
	memcpy(&tempI2cFrameCommandHeader, I2CReceivedFrame.pData, sizeof(i2cFrame_commonHeader));				//kopiowanie danych z otrzymanego bufora do zmiennej tymczasowej
	if(this->isCrcSumCorreect(I2CReceivedFrame, tempI2cFrameCommandHeader.crcSum))
	{
		switch(tempI2cFrameCommandHeader.commandGroup){

		case I2C_COMMAND_GROUP_KEYBOARD:
			parserFunction::keyboard((i2cFrame_keyboardFrame*)I2CReceivedFrame.pData);
			break;
		default:
			printf("%sunknown commandGroup value:0x%x\r\n",this->TAG, tempI2cFrameCommandHeader.commandGroup);
			assert(0);
		}
	}
}

#warining zrobic obsługę błędów komunikacji (jeśli są błędy komunikacji i jeśli nie ma sygnału keep alive)

namespace parserFunction{
	void keyboard(i2cFrame_keyboardFrame* kbrdFrame){
		kbrdFrame;
		kbrdFrame->keyboardData.array;

		//tutaj pchamy do kolejki klasy menu
	}

}
