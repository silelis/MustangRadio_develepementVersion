/*
 * tasksFunctions.c
 *
 *  Created on: Jul 13, 2024
 *      Author: dbank
 */


//#include "tasksFunctions.h"
#include "SileliS_code/tasksFunctions.h"
//#include <SileliS_code/myList.h>
#include <SileliS_code/radioMenu.h>


static bool esp32I2cInitialised = false;	//zmienna sprawdza czy esp32 zainiclował interfejs i2c
static TaskHandle_t taskHandle_esp32IntrrruptRequest = nullptr;					//uchwyt taska obsługującego komunikację (odczytywanie danych) z esp32, po pojawieniu się sygnału esp32 interrupt request
static TaskHandle_t taskHandle_i2cMaster_pReceiveQueueObjectParser = nullptr;	//uchwyt taska obsługującego parsowanie kolejki odbiorczej pi2cMaster->pReceiveQueueObject
static TaskHandle_t taskHandle_manageTheRadioManue=nullptr;						//uchwyt do taska przetwarzajacego dane z klawiatury i przekazującego go go radioMenu
static TaskHandle_t taskHandle_PrintfTask=nullptr;								//uchwyt do taska kontrolujący wyświetlaniekomunikatów na uart

static i2cMaster* pi2cMaster=nullptr;  											//wsyaźnik do obiektu służącego do komunikacji stm32 po i2c jako master
static esp32_i2cComunicationDriver* pESP32=nullptr; 							//wsyaźnik do obiektu obsługującego komunikację z ESP32
/*static*/ radioMenu* pRadioMenu=nullptr;
myPrintfTask* pPrintf=nullptr;											//pointer do taska obsługuącego pisanie komunikatow na konsolę



static void i2cMaster_pReceivedQueueObjectParser(void *pNothing){
	i2cFrame_transmitQueue tempI2CReceiveFrame;
	while(1){
		if(pi2cMaster->pReceiveQueueObject->QueueReceive(&tempI2CReceiveFrame, portMAX_DELAY)==pdPASS){
			switch(tempI2CReceiveFrame.slaveDevice7bitAddress)
			{
			case I2C_SLAVE_ADDRESS_ESP32:
				pESP32->parseReceivedData(tempI2CReceiveFrame);
				break;
			default:
				//printf("i2cMaster_pReceiveQueueObjectParser: Unknown i2c slave address: 0x%x (7bit).\r\n", tempI2CReceiveFrame.slaveDevice7bitAddress);
				pPrintf->feedPrintf("i2cMaster_pReceiveQueueObjectParser: Unknown i2c slave address: 0x%x (7bit).", tempI2CReceiveFrame.slaveDevice7bitAddress);


				pi2cMaster->ping(tempI2CReceiveFrame.slaveDevice7bitAddress);
				assert(0);
			}
			pi2cMaster->pReceiveQueueObject->QueueDeleteDataFromPointer(tempI2CReceiveFrame);			//BARDZO WAŻNA FUNKCJA, po parsowaniu otrzymanego z i2c pakiedy danych, który jest przetrzymywany pod zmienną alokowaną dynamicznie niszczy tą zmienną. Ta funkcja, w tym miejscu zapobiega wyciekom pamięci!!!!!
		};
	}
}

static void esp32IntrrruptRequestCallback(void *pNothing){
	i2cFrame_transmitQueue tempI2CFrameForESP32;			//
	tempI2CFrameForESP32.slaveDevice7bitAddress = pESP32->esp32i2cSlaveAdress_7bit;		//I2C_SLAVE_ADDRESS_ESP32;
	while(1){
		pESP32->isCountingSemaphoreOverflowed();
		if (pESP32->semaphoreTake__CountingSemaphore()){								//czeka dopuki nie pojawi się esp32 interrupt request


			pESP32->i2cMasterSemaphoreTake();
			pESP32->masterReceiveFromESP32_DMA((uint8_t*) &tempI2CFrameForESP32.dataSize, sizeof(size_t));
			pESP32->while_I2C_STATE_READY();
			tempI2CFrameForESP32.pData = new char[tempI2CFrameForESP32.dataSize];
			if (tempI2CFrameForESP32.pData!=nullptr){
				pESP32->masterReceiveFromESP32_DMA((uint8_t*) tempI2CFrameForESP32.pData, tempI2CFrameForESP32.dataSize);
				pESP32->while_I2C_STATE_READY();
				pi2cMaster->pReceiveQueueObject->QueueSend(&tempI2CFrameForESP32);
			}
			else{
				pESP32->seteDynamicmMemeoryAlocationError();
			}
			pESP32->i2cMasterSemaphoreGive();
		}
	};
}


void peripheryMenuTimeoutFunction(void* thing){
	radioMenu* ptrRadioMenu = (radioMenu*) thing;
	assert(ptrRadioMenu);
	bool selfSuspended = false;
	vTaskSuspend(NULL);
	while(1){
		vTaskDelay(pdMS_TO_TICKS(PERIPHERY_MENU_TIMEOUT_TASK_DELAY));

		xSemaphoreTake(ptrRadioMenu->peripheryMenu_TaskSuspendAllowedSemaphore, portMAX_DELAY);
		if (ptrRadioMenu->peripheryMenu_TimeoutCounterIncrement()>=6) {		//6 = 12 SECUNDS
			//ptrRadioMenu->peripheryMenu_TimeoutCounterReset();
			ptrRadioMenu->peripheryMenu_onTimeoutActions();
			//xSemaphoreGive(ptrRadioMenu->peripheryMenu_TaskSuspendAllowedSemaphore);
			vTaskSuspend(NULL);
			selfSuspended = true;
		}
		if (selfSuspended == false){
			xSemaphoreGive(ptrRadioMenu->peripheryMenu_TaskSuspendAllowedSemaphore);	//if self Suspended it means semaphore had been taken by menuFunction_equButShortPressed(void);
		}
		else{
			selfSuspended = false;		//reset self Suspend notification
		}

	}
}



static void manageRadioButtonsAndManue(void* thing){
	radioMenu* ptrRadioMenu = (radioMenu*) thing;
	assert(ptrRadioMenu);
	keyboardUnion receivedKeyboard;
	while(1){
		if(ptrRadioMenu->queueRadioMenuKbrdReceive(&receivedKeyboard)){
			if(!ptrRadioMenu->executeButtonFrom_radioMainMenu(receivedKeyboard)){
				if(!ptrRadioMenu->executeButtonFrom_curretDevice(receivedKeyboard)){
					//printf("%c %x - there is binded button.\r\n", receivedKeyboard.array[0], receivedKeyboard.array[1]);
					pPrintf->feedPrintf("%c %x - there is binded button.", receivedKeyboard.array[0], receivedKeyboard.array[1]);
				}
			}
		}
	}
}

static void printfTask(void* noThing){
	i2cFrame_transmitQueue itemToPrint;
	pPrintf->feedPrintf("Radio firmware version: %.2f", FW_VERSION);
	while(1){
		if(pPrintf->QueueReceive(&itemToPrint, portMAX_DELAY)==pdTRUE){
			pPrintf->myPrintf(itemToPrint);
			pPrintf->QueueDeleteDataFromPointer(itemToPrint);
		}
	}
}



static void initTaskFunctions(void){



	/*char trash[] = "HelloABCDEF";


	i2cFrame_transmitQueue testTransm;

	testTransm.slaveDevice7bitAddress = pESP32->esp32i2cSlaveAdress_7bit<<1;
	testTransm.dataSize =sizeof(trash);
	testTransm.pData = &trash;

	void* testBuffer;
	size_t bufferLenght = sizeof(testTransm.dataSize)+testTransm.dataSize;
	testBuffer = new char[bufferLenght];

	memcpy(testBuffer,&testTransm.dataSize, sizeof(testTransm.dataSize));
	memcpy(testBuffer+sizeof(size_t), testTransm.pData, testTransm.dataSize);


	while(1){
		while(HAL_I2C_GetState(&hi2c1)!= HAL_I2C_STATE_READY){};

		HAL_StatusTypeDef retVal =HAL_I2C_Master_Transmit_DMA(&hi2c1, I2C_SLAVE_ADDRESS_ESP32<<1, (uint8_t*) testBuffer, bufferLenght);

		//pętla opóźniająca jest potrzebna między kolejnymi przesyłkami
		for(uint32_t i=0; i<0xfffff; i++){

		}
		//uint8_t data;

	}*/


	assert(pi2cMaster = new i2cMaster(&hi2c1));
	assert(pESP32 = new esp32_i2cComunicationDriver(pi2cMaster));

	//pętla opóźniająca oczekująza aż zakończy się proces bootowania ESP32
	pi2cMaster->i2cMasterSemaphoreTake();


	while(HAL_I2C_IsDeviceReady(&hi2c1, pESP32->esp32i2cSlaveAdress_7bit<<1, 10000, 10000) != HAL_OK){
		//printf("ESP32 i2c bus not responding\r\n");
		pPrintf->feedPrintf("ESP32 i2c bus not responding...");
	}


	;
	pi2cMaster->i2cMasterSemaphoreGive();
	//pętla opóźniająca oczekująza aż zakończy si ę proces bootowania ESP32


	//printf("Radio main firmware version: %.2f\r\n", FW_VERSION);

	pi2cMaster->while_I2C_STATE_READY();
	pESP32->ping();


	//tworzy task callback na przerwanie od ESP32 informującę, że ESP32 ma jakieś dane do wysłania
	configASSERT(xTaskCreate(esp32IntrrruptRequestCallback, "esp32IntReq", 3*128, NULL, tskIDLE_PRIORITY+1, &taskHandle_esp32IntrrruptRequest));
	//tworzy task przetwarzający dane (parsujący) z kolejki odbiorczej i2c Mastera
	configASSERT(xTaskCreate(i2cMaster_pReceivedQueueObjectParser, "i2cMastRecQue, Pars", 3*128, NULL, tskIDLE_PRIORITY, &taskHandle_i2cMaster_pReceiveQueueObjectParser));


	assert(pRadioMenu=new radioMenu());
	//tworzy task obsługujący pobieranie z kolejki klawiszy
	configASSERT(xTaskCreate(manageRadioButtonsAndManue, "RadioMenu", 3*128, pRadioMenu, tskIDLE_PRIORITY, &/*(pRadioMenu->*/taskHandle_manageTheRadioManue/*)*/));
	//tworzy task timeoutu kontrolującego moment wyjścia z menu periphery (gdy radio jest w tym menu, a klawisze nie są używane)
	configASSERT(xTaskCreate(peripheryMenuTimeoutFunction, "periTimeout", 2*128, pRadioMenu, tskIDLE_PRIORITY, &pRadioMenu->peripheryMenu_taskHandle));
}


static TaskHandle_t taskHandle_initTaskFunctions=nullptr;						//uchwyt do taska (jodnorazowo wywolanego), który uruchamia całą konfigurację, trzeba tak to zrobić, aby printf działąło w tasku (task printf musi sie uruchomić  przed wszystkimi)
static void startUpTask_initTaskFunctions(void* noThing){

	//czeka, aż esp32 wyśle pierwszy sygnał interrupt request (pusty bez danych), wtedy wiadomo, że komunikacja jest zainicjowana.
	while(esp32I2cInitialised==false){
		pPrintf->feedPrintf("waiting for esp32 i2c bus to be initialized.");		//sygnałem o inicjalizacji jest pierwsze Interrupt request HIGH to LOW to HIGH
		vTaskDelay(pdMS_TO_TICKS(150));
	}

	//vTaskDelay(pdMS_TO_TICKS(2500));
	initTaskFunctions();
	vTaskDelete(taskHandle_initTaskFunctions);
}


void startUpTask(void* noThing){
	//printf("Radio main firmware version: %.2f\r\n", FW_VERSION);
	assert(pPrintf= new myPrintfTask(&huart1, 15));

	assert(xTaskCreate(printfTask, "Printf", 3*128, NULL, tskIDLE_PRIORITY, &taskHandle_PrintfTask));

	//pPrintf->feedPrintf("Radio main firmware version: %.2f\r\n", FW_VERSION);
	//tworzy task (JEDNORAZOWY), który wywołuje funkcję inicjalizacji calego sprzętu (inaczej nie dalo się zaimplementować printf działającego w tasku
	assert(xTaskCreate(startUpTask_initTaskFunctions, "initTasks", 3*128, NULL, tskIDLE_PRIORITY, &taskHandle_initTaskFunctions));
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if(esp32I2cInitialised==false){
		esp32I2cInitialised=true;
		//printf("f\r\n");
	}
	else{
		pESP32->incrementInterruptRequestCountingSemaphore();		//inkrementacja semafora daje sygnał ,dla metody esp32_i2sComunicationDriver::intrrruptRequestCallback
	}

}
