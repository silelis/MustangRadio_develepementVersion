/*
 * i2cEngine.cpp
 *
 *  Created on: Jul 21, 2024
 *      Author: dbank
 */

#include <i2cEngine.h>

i2cMaster::i2cMaster(I2C_HandleTypeDef *hi2c1) {
	// TODO Auto-generated constructor stub
	this->p_hi2c1 =hi2c1;
	this->pReceiveQueueObject = NULL;
	configASSERT(this->pReceiveQueueObject = new i2cQueue4DynamicData(DEFAULT_RECEIVE_QUEUE_SIZE));

//	this->esp32InterruptCounterOverflow =pdFALSE;		//reset interrupt counter overflow indicator
	assert(this->handle_i2cBinarySemaphore = xSemaphoreCreateBinary());
	this->i2cMasterSemaphoreGive();
	this->i2cMasterSemaphoreTake();
	HAL_I2C_DeInit(p_hi2c1);
	MX_I2C1_Init();
	//vTaskDelay(pdMS_TO_TICKS(1000));
	printf("%s bus had been initialized.\r\n",this->TAG);
	this->i2cMasterSemaphoreGive();
}

BaseType_t i2cMaster::i2cMasterSemaphoreTake(void){
	return xSemaphoreTake(this->handle_i2cBinarySemaphore, portMAX_DELAY);
}

BaseType_t i2cMaster::i2cMasterSemaphoreGive(void){
	return xSemaphoreGive(this->handle_i2cBinarySemaphore);
}

HAL_StatusTypeDef i2cMaster::ping(uint16_t DevAddress_7bit){
	HAL_StatusTypeDef retVal;
	this->i2cMasterSemaphoreTake();
	retVal = HAL_I2C_IsDeviceReady(this->p_hi2c1, DevAddress_7bit<<1, 100, 1000);
	this->i2cMasterSemaphoreGive();
	if(retVal==HAL_OK){
			printf("%s i2c slave avaliable on address: 0x%x (7bit).\r\n", this->TAG, DevAddress_7bit<<1);
	}
	return retVal;
}

i2cMaster::~i2cMaster() {
	// TODO Auto-generated destructor stub
	this->i2cMasterSemaphoreTake();
	HAL_I2C_DeInit(this->p_hi2c1);
	this->p_hi2c1 = NULL;
	delete this->pReceiveQueueObject;
	vSemaphoreDelete(this->handle_i2cBinarySemaphore);
}

void i2cMaster::while_I2C_STATE_READY(void){
	while(HAL_I2C_GetState(this->p_hi2c1)!= HAL_I2C_STATE_READY){};
}

HAL_StatusTypeDef i2cMaster::I2C_Master_Receive_DMA(uint16_t DevAddress_7bit, uint8_t *pData, uint16_t Size){
	return HAL_I2C_Master_Receive_DMA(this->p_hi2c1, DevAddress_7bit<<1, pData, Size);
}
