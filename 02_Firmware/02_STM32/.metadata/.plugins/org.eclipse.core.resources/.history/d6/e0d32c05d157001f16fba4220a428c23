#include "i2c_slave_master_queueClass.h"



/********************************************************************
 * @brief  Konstruktor obiektu
 *
 * @param  [uxQueueLength] [UBaseType_t] Długośc kolejki jaka będzie
 * 			przechowywać dane typu "i2cFrame_transmitQueue"
 *
 * @return NONE
 * @retval NONE
 * @retval NONE
 *
 * @note   NONE
 * @warning NONE
 *******************************************************************/
i2cQueue4DynamicData::i2cQueue4DynamicData(UBaseType_t uxQueueLength)
{
	this->handler_Queue = NULL;
	configASSERT(this->handler_Queue = xQueueCreate(uxQueueLength, sizeof(i2cFrame_transmitQueue)));
}


/********************************************************************
 * @brief  Destruktor obiektu
 *
 *
 * @param  [uxQueueLength] [UBaseType_t] Długośc kolejki jaka będzie
 * 			przechowywać dane typu "i2cFrame_transmitQueue"

 *
 * @return NONE
 * @retval NONE
 * @retval NONE
 *
 * @note   Przed destrukcją czyszczone są dane (tworzone dynamicznie.
 * 		   Indormacja o adresach tych danych zawarta jest w poli
 * 		   *pDataposzczególnych elementów trzymanych w
 * 		   i2cFrame_transmitQueue
 * @warning NONE
 *******************************************************************/
i2cQueue4DynamicData::~i2cQueue4DynamicData(void)
{
	i2cFrame_transmitQueue tempItemToDestrouQueue;
	BaseType_t tempQueueRetVal;
	do
	{
		tempQueueRetVal = xQueueReceive(this->handler_Queue, &tempItemToDestrouQueue, pdMS_TO_TICKS(1));
		if (tempQueueRetVal == pdPASS)
		{
			this->QueueDeleteDataFromPointer(tempItemToDestrouQueue);
		}			
	} while (tempQueueRetVal == pdPASS);
	vQueueDelete(this->handler_Queue);
}


/********************************************************************
 * @brief  Usuwa dane wskazane w *pData
 *
 * [Dłuższy opis funkcji, w którym można wyjaśnić szczegóły działania,
 *  algorytmy, przypadki brzegowe itp.]
 *
 * @param  [structWithPointer] [i2cFrame_transmitQueue] struktura
 * 			2cFrame_transmitQueue (z bufora i2c), któa zawiera m.inm
 * 			adres *pData, pod którym znajdują się dynamicznie alokowane
 * 			dane, które trzeba usunąć.
 *
 * @return NONE
 *
 * @note   NONE
 * @warning NONE
 *******************************************************************/
void i2cQueue4DynamicData::QueueDeleteDataFromPointer(i2cFrame_transmitQueue structWithPointer)
{
	delete[] static_cast<char*>(structWithPointer.pData);	
}


/********************************************************************
 * @brief  [Pobiera dane z bufora kolejki i2c
 *
 * [Dłuższy opis funkcji, w którym można wyjaśnić szczegóły działania,
 *  algorytmy, przypadki brzegowe itp.]
 *
 * @param  [parametr1] [Typ parametru] Opis pierwszego parametru.
 * @param  [parametr2] [Typ parametru] Opis drugiego parametru.
 * @param  [parametr3] [Typ parametru] Opis trzeciego parametru.
 *
 * @return [Typ zwracanej wartości] Opis tego, co funkcja zwraca.
 * @retval [wartość_1] Opis pierwszej możliwej wartości zwracanej.
 * @retval [wartość_2] Opis drugiej możliwej wartości zwracanej.
 *
 * @note   [Dodatkowe informacje, jeśli są istotne]
 * @warning [Ostrzeżenia dotyczące używania funkcji, jeśli istnieją]
 *******************************************************************/
BaseType_t  i2cQueue4DynamicData::QueueReceive(/*void*/i2cFrame_transmitQueue * /*const*/ pvBuffer, TickType_t xTicksToWait)
{
	
	return xQueueReceive(this->handler_Queue, pvBuffer, xTicksToWait);
}



BaseType_t i2cQueue4DynamicData::QueueSend(/*const*/ /*void*/i2cFrame_transmitQueue * pvItemToQueue){
	if (xQueueSend(this->handler_Queue, pvItemToQueue, pdMS_TO_TICKS(700)) == pdTRUE)
	{
		return pdTRUE;
	}
	else
	{
		i2cFrame_transmitQueue dataToTransmitQueue;
		memcpy(&dataToTransmitQueue, pvItemToQueue, sizeof(i2cFrame_transmitQueue));
		this->QueueDeleteDataFromPointer(dataToTransmitQueue);
		//delete[] static_cast<char*>(pointerToData);
		return pdFALSE;
	}
}
