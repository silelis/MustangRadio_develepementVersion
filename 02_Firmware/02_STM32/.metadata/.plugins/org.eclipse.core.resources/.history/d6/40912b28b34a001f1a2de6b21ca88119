/*
 * tasksFunctions.c
 *
 *  Created on: Jul 13, 2024
 *      Author: dbank
 */


#include "tasksFunctions.h"
#include "comunicationProtocol.h"
#include "comunicationStructures.h"
#include "comunication_calculate_checksum.h"
#include "FreeRTOS.h"
#include "queue.h"
#include "task.h"
#include "i2c.h"
#include <cstring>
#include "semphr.h"
#include "i2cEngine.h"

static TaskHandle_t taskHandle_esp32IntrrruptRequest = NULL;		//uchwyt taska obsługującego komunikację (odczytywanie danych) z esp32, po pojawieniu się sygnału esp32 interrupt request
static SemaphoreHandle_t esp32IntrrruptRequest_CountingSemaphore;	//uchwyt semafora zliczającego ilość wsytąpień esp32 interrupt request i ilość odczytów danych z esp32
static BaseType_t esp32InrerruptRequest_CountingSemaphoreOverflow=pdFALSE;	//zmienna informująca o tym, że nastąpiło przepełnienie "esp32IntrrruptRequest_CountingSemaphore", aka. zbyt wiele oczekujących komunikatów, co może wskazywać na błąd.

static i2cMaster* pi2cMaster;  //wsyaźnik do obiektu służącego do komunikacji stm32 po i2c jako master


static void esp32IntrrruptRequestCallback(void *pNothing){
	i2cFrame_transmitQueue temI2CRecFrame;
	while(1){
		if( uxSemaphoreGetCount(esp32IntrrruptRequest_CountingSemaphore)==ESP32_INTERRUPT_REQUEST_COUNTING_SEMAPHORE_MAX){		//sprawdza czy licznik esp32 interrupt request nie jest przepełniony
			esp32InrerruptRequest_CountingSemaphoreOverflow = pdTRUE;
			printf("!!! ESP32 interrupt request counter overflowed   !!!\r\n");
		}
		if (xSemaphoreTake(esp32IntrrruptRequest_CountingSemaphore, portMAX_DELAY) == pdTRUE){		//czeka dopuki nie pojawi się esp32 interrupt request
			printf("High prior task \r\n");
			size_t dataSizse;
			//temI2CRecFrame.dataSize;
			HAL_I2C_Master_Receive(&hi2c1, I2C_SLAVE_ADDRESS<<1, (uint8_t*)&temI2CRecFrame->dataSize, sizeof(size_t), 500);
			char* pdymanicDataPointer = new char[dataSizse];
			uintptr_t pdymanicDataPointer_byValue = (uintptr_t) pdymanicDataPointer;
			//pi2cMaster->pReceiveQueueObject->QueueSend(&pdymanicDataPointer_byValue);
			//#error Pociągnąć to dalej
		}
	};
}


void initTaskFunctions(void){
	printf("Radio main firmware version: %.2f\r\n", FW_VERSION);
	configASSERT(esp32IntrrruptRequest_CountingSemaphore = xSemaphoreCreateCounting(ESP32_INTERRUPT_REQUEST_COUNTING_SEMAPHORE_MAX, 0));

	//tworzy task callback na przerwanie od ESP32 informującę, że ESP32 ma jakieś dane do wysłania
	configASSERT(xTaskCreate(esp32IntrrruptRequestCallback, "esp32IntReq", 3*128, NULL, tskIDLE_PRIORITY+1, &taskHandle_esp32IntrrruptRequest));

	pi2cMaster = NULL;
	assert(pi2cMaster = new i2cMaster(&hi2c1));
	pi2cMaster->ping(I2C_SLAVE_ADDRESS);
}




void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		xSemaphoreGiveFromISR(esp32IntrrruptRequest_CountingSemaphore, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
