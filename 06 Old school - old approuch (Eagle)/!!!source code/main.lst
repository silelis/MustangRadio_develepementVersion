CCS PCH C Compiler, Version 5.070, 5967               17-kwi-19 20:26

               Filename:   G:\Elektronika_projekty\Car_Radio\!!!source code\main.lst

               ROM used:   2718 bytes (8%)
                           Largest free fragment is 30050
               RAM used:   68 (4%) at main() level
                           96 (6%) worst case
               Stack used: 0 locations
               Stack size: 31

*
0000:  GOTO   09D2
.................... #define _I2C_SCL  PIN_C3 
.................... #define _I2C_SDA  PIN_C4 
.................... //#include <STDLIB.H> 
....................  
.................... #include <main.h> 
.................... #include <18F4520.h> 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0004:  DATA 49,32
0006:  DATA 43,20
0008:  DATA 77,2E
000A:  DATA 61,64
000C:  DATA 64,72
000E:  DATA 3A,25
0010:  DATA 78,20
0012:  DATA 65,72
0014:  DATA 72,6F
0016:  DATA 72,20
0018:  DATA 74,72
001A:  DATA 79,28
001C:  DATA 73,29
001E:  DATA 3A,25
0020:  DATA 4C,75
0022:  DATA 20,73
0024:  DATA 74,61
0026:  DATA 74,75
0028:  DATA 73,3A
002A:  DATA 25,64
002C:  DATA 00,00
002E:  DATA 49,32
0030:  DATA 43,20
0032:  DATA 77,2E
0034:  DATA 61,64
0036:  DATA 64,72
0038:  DATA 3A,25
003A:  DATA 78,20
003C:  DATA 41,43
003E:  DATA 4B,00
0040:  DATA 49,32
0042:  DATA 43,20
0044:  DATA 72,2E
0046:  DATA 61,64
0048:  DATA 64,72
004A:  DATA 3A,25
004C:  DATA 78,20
004E:  DATA 41,43
0050:  DATA 4B,00
0052:  DATA 49,32
0054:  DATA 43,20
0056:  DATA 61,64
0058:  DATA 64,72
005A:  DATA 3A,25
005C:  DATA 78,20
005E:  DATA 21,41
0060:  DATA 43,4B
0062:  DATA 00,00
0064:  DATA 49,32
0066:  DATA 43,20
0068:  DATA 61,64
006A:  DATA 72,3A
006C:  DATA 25,78
006E:  DATA 20,43
0070:  DATA 4F,4C
0072:  DATA 49,53
0074:  DATA 49,4F
0076:  DATA 4E,00
*
015A:  TBLRD*+
015C:  MOVFF  FF6,57
0160:  MOVFF  FF7,58
0164:  MOVFF  FF5,5F
0168:  RCALL  011A
016A:  MOVFF  57,FF6
016E:  MOVFF  58,FF7
0172:  DECFSZ 56,F
0174:  BRA    015A
0176:  RETURN 0
0178:  BTFSC  57.7
017A:  BRA    019A
017C:  MOVLW  0F
017E:  MOVWF  00
0180:  SWAPF  56,W
0182:  ANDWF  00,F
0184:  MOVLW  0A
0186:  SUBWF  00,W
0188:  BC    0190
018A:  MOVLW  30
018C:  ADDWF  00,F
018E:  BRA    0194
0190:  MOVF   57,W
0192:  ADDWF  00,F
0194:  MOVFF  00,5F
0198:  RCALL  011A
019A:  MOVLW  0F
019C:  ANDWF  56,F
019E:  MOVLW  0A
01A0:  SUBWF  56,W
01A2:  BC    01A8
01A4:  MOVLW  30
01A6:  BRA    01AC
01A8:  BCF    57.7
01AA:  MOVF   57,W
01AC:  ADDWF  56,F
01AE:  MOVFF  56,5F
01B2:  RCALL  011A
01B4:  RETURN 0
01B6:  MOVFF  FEA,5E
01BA:  MOVFF  FE9,5D
01BE:  SWAPF  57,W
01C0:  IORLW  F0
01C2:  MOVWF  59
01C4:  ADDWF  59,F
01C6:  ADDLW  E2
01C8:  MOVWF  5A
01CA:  ADDLW  32
01CC:  MOVWF  5C
01CE:  MOVF   57,W
01D0:  ANDLW  0F
01D2:  ADDWF  5A,F
01D4:  ADDWF  5A,F
01D6:  ADDWF  5C,F
01D8:  ADDLW  E9
01DA:  MOVWF  5B
01DC:  ADDWF  5B,F
01DE:  ADDWF  5B,F
01E0:  SWAPF  56,W
01E2:  ANDLW  0F
01E4:  ADDWF  5B,F
01E6:  ADDWF  5C,F
01E8:  RLCF   5B,F
01EA:  RLCF   5C,F
01EC:  COMF   5C,F
01EE:  RLCF   5C,F
01F0:  MOVF   56,W
01F2:  ANDLW  0F
01F4:  ADDWF  5C,F
01F6:  RLCF   59,F
01F8:  MOVLW  07
01FA:  MOVWF  58
01FC:  MOVLW  0A
01FE:  DECF   5B,F
0200:  ADDWF  5C,F
0202:  BNC   01FE
0204:  DECF   5A,F
0206:  ADDWF  5B,F
0208:  BNC   0204
020A:  DECF   59,F
020C:  ADDWF  5A,F
020E:  BNC   020A
0210:  DECF   58,F
0212:  ADDWF  59,F
0214:  BNC   0210
0216:  CLRF   FEA
0218:  MOVLW  58
021A:  MOVWF  FE9
021C:  MOVLW  07
021E:  ANDWF  5D,W
0220:  BCF    5D.6
0222:  ADDWF  FE9,F
0224:  MOVLW  00
0226:  ADDWFC FEA,F
0228:  MOVF   FE9,W
022A:  SUBLW  5C
022C:  BNZ   0234
022E:  MOVF   FEA,F
0230:  BNZ   0234
0232:  BSF    5D.6
0234:  MOVF   FEF,W
0236:  MOVWF  00
0238:  BNZ   024A
023A:  BTFSC  5D.6
023C:  BRA    024A
023E:  BTFSC  5D.4
0240:  BRA    0268
0242:  BTFSC  5D.3
0244:  BRA    024A
0246:  MOVLW  20
0248:  BRA    0250
024A:  BSF    5D.3
024C:  BCF    5D.4
024E:  MOVLW  30
0250:  ADDWF  00,F
0252:  MOVFF  FEA,57
0256:  MOVFF  FE9,56
025A:  MOVFF  00,5F
025E:  RCALL  011A
0260:  MOVFF  57,FEA
0264:  MOVFF  56,FE9
0268:  MOVF   FEE,W
026A:  BTFSS  5D.6
026C:  BRA    0228
026E:  GOTO   03C4 (RETURN)
0272:  MOVF   5D,W
0274:  CLRF   01
0276:  SUBWF  5C,W
0278:  BC    0280
027A:  MOVFF  5C,00
027E:  BRA    0298
0280:  CLRF   00
0282:  MOVLW  08
0284:  MOVWF  5E
0286:  RLCF   5C,F
0288:  RLCF   00,F
028A:  MOVF   5D,W
028C:  SUBWF  00,W
028E:  BTFSC  FD8.0
0290:  MOVWF  00
0292:  RLCF   01,F
0294:  DECFSZ 5E,F
0296:  BRA    0286
0298:  RETURN 0
029A:  MOVLW  20
029C:  BTFSS  57.4
029E:  MOVLW  30
02A0:  MOVWF  58
02A2:  MOVFF  56,00
02A6:  BTFSS  56.7
02A8:  BRA    02BA
02AA:  COMF   00,F
02AC:  INCF   00,F
02AE:  MOVFF  00,56
02B2:  MOVLW  2D
02B4:  MOVWF  58
02B6:  BSF    57.7
02B8:  BSF    57.0
02BA:  MOVF   01,W
02BC:  MOVFF  56,5C
02C0:  MOVLW  64
02C2:  MOVWF  5D
02C4:  RCALL  0272
02C6:  MOVFF  00,56
02CA:  MOVLW  30
02CC:  ADDWF  01,W
02CE:  MOVWF  59
02D0:  MOVFF  56,5C
02D4:  MOVLW  0A
02D6:  MOVWF  5D
02D8:  RCALL  0272
02DA:  MOVLW  30
02DC:  ADDWF  00,W
02DE:  MOVWF  5B
02E0:  MOVLW  30
02E2:  ADDWF  01,W
02E4:  MOVWF  5A
02E6:  MOVFF  58,00
02EA:  MOVLW  30
02EC:  SUBWF  59,W
02EE:  BZ    02F8
02F0:  BSF    57.1
02F2:  BTFSC  57.7
02F4:  BSF    57.2
02F6:  BRA    031C
02F8:  MOVFF  58,59
02FC:  MOVLW  20
02FE:  MOVWF  58
0300:  MOVLW  30
0302:  SUBWF  5A,W
0304:  BZ    030E
0306:  BSF    57.0
0308:  BTFSC  57.7
030A:  BSF    57.1
030C:  BRA    031C
030E:  BTFSS  FD8.2
0310:  BSF    57.0
0312:  BNZ   031C
0314:  MOVFF  59,5A
0318:  MOVLW  20
031A:  MOVWF  59
031C:  BTFSC  57.2
031E:  BRA    032A
0320:  BTFSC  57.1
0322:  BRA    0330
0324:  BTFSC  57.0
0326:  BRA    0336
0328:  BRA    033C
032A:  MOVFF  58,5F
032E:  RCALL  011A
0330:  MOVFF  59,5F
0334:  RCALL  011A
0336:  MOVFF  5A,5F
033A:  RCALL  011A
033C:  MOVFF  5B,5F
0340:  RCALL  011A
0342:  GOTO   03DC (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(crystal=20000000) 
*
0354:  MOVLW  03
0356:  SUBWF  56,F
0358:  BNC   036C
035A:  CLRF   FEA
035C:  MOVLW  56
035E:  MOVWF  FE9
0360:  MOVF   FEF,W
0362:  BZ    036C
0364:  BRA    0368
0366:  BRA    0368
0368:  DECFSZ FEF,F
036A:  BRA    0366
036C:  GOTO   03EC (RETURN)
*
0962:  CLRF   FEA
0964:  MOVLW  44
0966:  MOVWF  FE9
0968:  MOVF   FEF,W
096A:  BZ    0986
096C:  MOVLW  06
096E:  MOVWF  01
0970:  CLRF   00
0972:  DECFSZ 00,F
0974:  BRA    0972
0976:  DECFSZ 01,F
0978:  BRA    0970
097A:  MOVLW  7B
097C:  MOVWF  00
097E:  DECFSZ 00,F
0980:  BRA    097E
0982:  DECFSZ FEF,F
0984:  BRA    096C
0986:  GOTO   0A80 (RETURN)
....................  
....................  
....................  
.................... #FUSES brownout //,nomclr  
.................... //#use rs232(baud=9600,parity=N,xmit=None,rcv=None,bits=8,stream=PORT1) 
.................... //#use rs232(baud=38400,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) //,stream=PORT1) 
.................... #ifndef _I2C_ 
....................    #define _I2C_ 
....................    #use i2c(Master,Slow,sda=_I2C_SDA,scl=_I2C_SCL) 
*
00C4:  BCF    FC6.7
00C6:  BCF    F9E.3
00C8:  MOVFF  58,FC9
00CC:  MOVLW  02
00CE:  BTFSC  FC6.7
00D0:  BRA    00DC
00D2:  BTFSS  F9E.3
00D4:  BRA    00D2
00D6:  MOVLW  00
00D8:  BTFSC  FC5.6
00DA:  MOVLW  01
00DC:  MOVWF  01
00DE:  RETURN 0
*
03F6:  BCF    FC6.6
03F8:  BSF    FC5.3
03FA:  BTFSC  FC5.3
03FC:  BRA    03FA
03FE:  BTFSC  00.0
0400:  BCF    FC5.5
0402:  BTFSS  00.0
0404:  BSF    FC5.5
0406:  BSF    FC5.4
0408:  BTFSC  FC5.4
040A:  BRA    0408
040C:  MOVFF  FC9,01
0410:  GOTO   04E8 (RETURN)
....................    //#use i2c(Master,Fast,sda=_I2C_SDA,scl=_I2C_SCL) 
.................... #endif 
....................  
.................... //#define LED PIN_D1 
.................... //#define ACTIVE_ANTENA PIN_C5 
.................... //#define DELAY 1000 
.................... //#define I2C_BUFSIZE         64 
.................... //#define MAX_TIMEOUT         0x00FFFFFF 
.................... #define StartupVoltageStabilisation   delay_ms(2000) 
.................... //#define BYTE int  
.................... //#define BOOLEAN short int  
....................  
.................... //#use rs232(UART1,baud=38400 ,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=Hardware__comm_port) 
.................... #use rs232(UART1, baud=57600 ,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8, stream=Hardware__comm_port)//, TRANSMIT_BUFFER=50,NOTXISR) 
....................  
.................... #byte UART_BUFFOR = getenv("SFR:TXREG") 
.................... #warning "UART_BUFFOR" UART_BUFFOR 
....................  
....................  
....................  
.................... #define _USE_LOGPORT_ 
....................  
....................  
.................... #if defined(DEBUG_ENABLED) 
.................... #use rs232(ICD,stream=ICD_DBG,DISABLE_INTS) 
.................... #define dbg_return_carriage() fprintf_return_carriage() 
.................... #define dbg_printf(fmt,...)   fprintf(ICD_DBG,fmt,__VA_ARGS__); dbg_return_carriage() 
....................  
.................... #elif defined(_USE_LOGPORT_) 
.................... //#use rs232(baud=38400,parity=N,xmit=PIN_B7,bits=8,stream=LOG_PORT, DISABLE_INTS) 
.................... #use rs232(baud=38400,parity=N,xmit=PIN_B7,bits=8,stream=LOG_PORT) 
*
011A:  BCF    F93.7
011C:  BCF    F8A.7
011E:  MOVLW  08
0120:  MOVWF  01
0122:  BRA    0124
0124:  NOP   
0126:  BSF    01.7
0128:  BRA    0146
012A:  BCF    01.7
012C:  RRCF   5F,F
012E:  BTFSC  FD8.0
0130:  BSF    F8A.7
0132:  BTFSS  FD8.0
0134:  BCF    F8A.7
0136:  BSF    01.6
0138:  BRA    0146
013A:  BCF    01.6
013C:  DECFSZ 01,F
013E:  BRA    012C
0140:  BRA    0142
0142:  NOP   
0144:  BSF    F8A.7
0146:  MOVLW  25
0148:  MOVWF  FE9
014A:  DECFSZ FE9,F
014C:  BRA    014A
014E:  NOP   
0150:  BTFSC  01.7
0152:  BRA    012A
0154:  BTFSC  01.6
0156:  BRA    013A
0158:  RETURN 0
.................... #define dbg_return_carriage() fprintf_return_carriage() 
.................... #define dbg_printf(fmt,...)   fprintf(LOG_PORT,fmt,__VA_ARGS__); dbg_return_carriage()//;  delay_ms(500) 
....................  
.................... #else 
.................... #define dbg_printf(fmt,...) 
.................... #define dbg_return_carriage() 
.................... #endif 
....................  
....................    void fprintf_return_carriage(void) 
....................    { 
....................       fprintf(LOG_PORT,"\r\n"); 
*
0346:  MOVLW  0D
0348:  MOVWF  5F
034A:  RCALL  011A
034C:  MOVLW  0A
034E:  MOVWF  5F
0350:  RCALL  011A
0352:  RETURN 0
....................       //fprintf(LOG_PORT,"%c%c", 0x0a,0x0d); 
....................    } 
....................  
....................  
....................  
.................... //#include </HW_drivers/tea5767.h> 
.................... //#include </core/I2C/I2C_Engine.c> 
....................  
.................... //#ifdef ACTIVE_ANTENA  
....................    #include </HW_drivers/AAntena/ActiveAntena.c> 
.................... #include </ActiveAntena.h> 
.................... #ifndef ACTIVE_ANTENA 
....................  
.................... #define ACTIVE_ANTENA PIN_B5    
....................     
.................... void        AAntenna_ON                      (void); 
.................... void        AAntenna_OFF                     (void); 
.................... #endif 
....................  
....................  
....................  
.................... // TODO: w sterowaniu radio zrobiæ mo¿liwoœc wyboru CZY ma byæ SUPPORT ACTIVE ANTENA - chodzi o to, ¿e czasem radio dzia³a lepiej z AA, a czaem bez 
....................  
.................... //#ifdef ACTIVE_ANTENA  
....................    void AAntenna_ON(void) 
....................    { 
....................       output_high(ACTIVE_ANTENA); 
....................       delay_ms(500); 
....................    } 
....................   
....................    void AAntenna_OFF(void) 
....................    { 
....................       output_low(ACTIVE_ANTENA); 
....................       delay_ms(500); 
....................    } 
.................... //#endif 
....................  
.................... //#endif 
....................  
.................... //volatile unsigned int8   MasterBuffer[I2C_BUFSIZE]; 
.................... //volatile unsigned int8   SlaveBuffer[I2C_BUFSIZE]; 
....................  
....................  
.................... //float FMfreqency; 
....................  
....................  
.................... //#ifndef _I2C_ENGINE_ 
....................    #include </core/I2C_ENGINE/I2C_Engine.c> 
.................... /**************************************************************************/ 
.................... /*!  
....................     @file     i2c_engine.c 
....................     @author   D. Bankowski (d.bankowski@gmail.com) 
....................      
....................     @brief    Driver for i2c master. 
....................     @section LICENSE 
....................     Software License Agreement (BSD License) 
....................     Copyright (c) 2017, D. Bankowski 
....................     All rights reserved. 
....................     Redistribution and use in source and binary forms, with or without 
....................     modification, are permitted provided that the following conditions are met: 
....................     1. Redistributions of source code must retain the above copyright 
....................     notice, this list of conditions and the following disclaimer. 
....................     2. Redistributions in binary form must reproduce the above copyright 
....................     notice, this list of conditions and the following disclaimer in the 
....................     documentation and/or other materials provided with the distribution. 
....................     3. Neither the name of the copyright holders nor the 
....................     names of its contributors may be used to endorse or promote products 
....................     derived from this software without specific prior written permission. 
....................     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY 
....................     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY 
....................     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.ty 
.................... */ 
.................... /**************************************************************************/ 
....................  
.................... #include </I2C_Engine.h> 
.................... /**************************************************************************/ 
.................... /*!  
....................     @file     i2c_engine.h 
....................     @author   D. Bankowski (d.bankowski@gmail.com) 
....................      
....................     @brief    Driver for i2c master. 
....................     @section LICENSE 
....................     Software License Agreement (BSD License) 
....................     Copyright (c) 2017, D. Bankowski 
....................     All rights reserved. 
....................     Redistribution and use in source and binary forms, with or without 
....................     modification, are permitted provided that the following conditions are met: 
....................     1. Redistributions of source code must retain the above copyright 
....................     notice, this list of conditions and the following disclaimer. 
....................     2. Redistributions in binary form must reproduce the above copyright 
....................     notice, this list of conditions and the following disclaimer in the 
....................     documentation and/or other materials provided with the distribution. 
....................     3. Neither the name of the copyright holders nor the 
....................     names of its contributors may be used to endorse or promote products 
....................     derived from this software without specific prior written permission. 
....................     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY 
....................     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY 
....................     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
.................... */ 
.................... /**************************************************************************/ 
....................  
.................... #ifndef _I2C_ENGINE_ 
....................    #define _I2C_ENGINE_ 
....................  
....................    #define  I2C_DELAY_US            20  
....................    #define  I2C_INTERBYTE_DELAY_US  60 
....................    #define  READ__EEPROM            TRUE 
....................    #define  normal__I2C             FALSE 
....................     
....................    void i2cInit      (void);    
....................    void i2cEngine    (int1); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _TRANSMISSION_BUFFERS_ 
....................    #include </core/transmission_buffers/transmission_buffers.c> 
.................... #ifndef _TRANSMISSION_BUFFERS_ 
....................     
....................    #include </transmission_buffers.h> 
.................... #ifndef _TRANSMISSION_BUFFERS_ 
....................    #define _TRANSMISSION_BUFFERS_ 
....................     
....................    //#define mcu_Transmission_BUFSIZE         65 
....................    //#define mcu_Reception_BUFSIZE           255 //257 by³o 257 z jakiegoœ powodu, ale UART dzia³a mi z 255 //poza tym wszêdzie s¹ tak powyliczane pêtke (na int8) 
....................     
....................  
....................     //const unsigned int16 mcu_Transmission_BUFSIZE=16; 
....................     #define mcu_Transmission_BUFSIZE 16 
....................     //const unsigned int16 mcu_Reception_BUFSIZE=32; //257 by³o 257 z jakiegoœ powodu, ale UART dzia³a mi z 255 //poza tym wszêdzie s¹ tak powyliczane pêtke (na int8) 
....................     #define mcu_Reception_BUFSIZE 32 
....................     unsigned int   comunication_MasterBuffer[mcu_Transmission_BUFSIZE ]; 
....................     unsigned int   comunication_SlaveBuffer[mcu_Reception_BUFSIZE]; 
....................     
....................     
....................    void ClearBuffers (unsigned int, short int); 
....................     
....................    #ifdef _I2C_ENGINE_ 
....................       //i2c buffer size (MAX): 
....................       // device:                    TEA5767        TDA7418       HMI      EEPROM       au6850 
....................       //- write (I2CWriteLength):      6              3           15      4+2=6         5??? 
....................       //- read  (I2CReadLength):       5              0           1        4           32 
....................        
....................       
....................       #define  i2c_MasterBuffer                    comunication_MasterBuffer 
....................       #define  i2c_SlaveBuffer                     comunication_SlaveBuffer 
....................       #define  i2c_mcu_Transmission_BUFSIZE        mcu_Transmission_BUFSIZE 
....................       #define  i2c_mcu_Reception_BUFSIZE           mcu_Reception_BUFSIZE 
....................        
....................        
....................       #define i2c_ClearMasterBuffer()     ClearBuffers(&i2c_MasterBuffer,i2c_mcu_Transmission_BUFSIZE) 
....................       #define i2c_ClearSlaveBuffers()     ClearBuffers(&i2c_SlaveBuffer,i2c_mcu_Reception_BUFSIZE) 
....................       //void i2c_ClearMasterBuffer  (void); 
....................       //void i2c_ClearSlaveBuffers  (void); 
....................    #endif 
....................  
....................    #ifdef _UART_ENGINE_ 
....................        //UART buffer size (MAX): 
....................       // device:                    OVC3860        MonkeyBoard          au6820 
....................       //- write (I2CWriteLength):       
....................       //- read  (I2CReadLength):                                           19 
....................     
....................       #define  UART_MasterBuffer                    comunication_MasterBuffer 
....................       #define  UART_SlaveBuffer                     comunication_SlaveBuffer 
....................       #define  UART_mcu_Transmission_BUFSIZE        mcu_Transmission_BUFSIZE 
....................       #define  UART_mcu_Reception_BUFSIZE           mcu_Reception_BUFSIZE    
....................     
....................       #define UART_ClearMasterBuffer()     ClearBuffers(&UART_MasterBuffer,UART_mcu_Transmission_BUFSIZE) 
....................       #define UART_ClearSlaveBuffers()     ClearBuffers(&UART_SlaveBuffer,UART_mcu_Reception_BUFSIZE) 
....................        
....................    #endif 
....................     
....................  
....................     
.................... #endif 
....................  
....................     
....................    //void ClearBuffers (unsigned int *buffer, short int buffer_size) 
....................    void ClearBuffers (unsigned int *buffer, unsigned int16 buffer_size) 
....................       { 
....................          //unsigned int8 i; 
....................          unsigned int16 i; 
....................          for ( i = 0; i < buffer_size; i++ ) 
*
0078:  CLRF   55
007A:  CLRF   54
007C:  MOVF   55,W
007E:  SUBWF  53,W
0080:  BNC   00A4
0082:  BNZ   008A
0084:  MOVF   52,W
0086:  SUBWF  54,W
0088:  BC    00A4
....................          { 
....................             *(buffer+i)= 0x00; 
008A:  MOVF   54,W
008C:  ADDWF  50,W
008E:  MOVWF  01
0090:  MOVF   55,W
0092:  ADDWFC 51,W
0094:  MOVFF  01,FE9
0098:  MOVWF  FEA
009A:  CLRF   FEF
009C:  INCF   54,F
009E:  BTFSC  FD8.2
00A0:  INCF   55,F
00A2:  BRA    007C
....................          } 
00A4:  RETURN 0
....................       } 
....................     
....................    /* 
....................    void i2c_ClearMasterBuffer  (void) 
....................    { 
....................       ClearBuffers(&i2c_MasterBuffer,i2c_mcu_Transmission_BUFSIZE); 
....................     
....................    } 
....................    */ 
....................     
....................    /* 
....................    void i2c_ClearSlaveBuffers  (void) 
....................    { 
....................       ClearBuffers(&i2c_SlaveBuffer,i2c_mcu_Reception_BUFSIZE); 
....................    } 
....................    */ 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... //unsigned int32 I2CReadLength; //I2C zmieniæ na  
.................... //unsigned int32 I2CWriteLength; 
.................... unsigned int16 I2CReadLength;  
.................... unsigned int16 I2CWriteLength; 
....................  
.................... void i2cInit(void) { 
....................    output_float(_I2C_SCL); 
....................    output_float(_I2C_SDA); 
.................... } 
....................  
.................... int8 __i2cDeviceStatus() { 
....................    int8 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
00E0:  BSF    FC5.0
00E2:  BTFSC  FC5.0
00E4:  BRA    00E2
....................    delay_us(I2C_DELAY_US); 
00E6:  MOVLW  21
00E8:  MOVWF  00
00EA:  DECFSZ 00,F
00EC:  BRA    00EA
....................    ack = i2c_write(i2c_MasterBuffer[0]&0xFE);  // then the device is ready. PING should be always of write address so 0xFE 0b11111110 is required on ping 
00EE:  MOVF   04,W
00F0:  ANDLW  FE
00F2:  MOVWF  57
00F4:  MOVWF  58
00F6:  RCALL  00C4
00F8:  MOVFF  01,56
....................    delay_us(I2C_DELAY_US); 
00FC:  MOVLW  21
00FE:  MOVWF  00
0100:  DECFSZ 00,F
0102:  BRA    0100
....................    i2c_stop(); 
0104:  BSF    FC5.2
0106:  BTFSC  FC5.2
0108:  BRA    0106
....................    delay_us(I2C_DELAY_US); 
010A:  MOVLW  21
010C:  MOVWF  00
010E:  DECFSZ 00,F
0110:  BRA    010E
....................    return ack;             // 0 means ACK, 1 means NO ACK, 2 means there was a collision if in Multi_Master Mode. This does not return an ACK if using i2c in slave mode 
0112:  MOVFF  56,01
0116:  GOTO   0388 (RETURN)
.................... } 
....................  
.................... int8 __try_i2c_bus(void) 
*
0370:  MOVLW  01
0372:  MOVWF  53
0374:  CLRF   55
0376:  CLRF   54
.................... { 
....................    int8  i2c_try=1; 
....................    unsigned int16 i2c_tryout_error = 0; 
....................    while(i2c_try!=0&&i2c_tryout_error <100) //i2c_tryout_error<100 
0378:  MOVF   53,F
037A:  BZ    03EE
037C:  MOVF   55,F
037E:  BNZ   03EE
0380:  MOVF   54,W
0382:  SUBLW  63
0384:  BNC   03EE
....................    { 
....................       i2c_try = __i2cDeviceStatus(); 
0386:  BRA    00E0
0388:  MOVFF  01,53
....................        
....................       if (i2c_try!= 0) 
038C:  MOVF   53,F
038E:  BZ    03DE
....................       { 
....................          dbg_printf("I2C w.addr:%x error try(s):%Lu status:%d", i2c_MasterBuffer[0], i2c_tryout_error, i2c_try); 
0390:  MOVLW  04
0392:  MOVWF  FF6
0394:  MOVLW  00
0396:  MOVWF  FF7
0398:  MOVLW  0B
039A:  MOVWF  56
039C:  RCALL  015A
039E:  MOVFF  04,56
03A2:  MOVLW  57
03A4:  MOVWF  57
03A6:  RCALL  0178
03A8:  MOVLW  11
03AA:  MOVWF  FF6
03AC:  MOVLW  00
03AE:  MOVWF  FF7
03B0:  MOVLW  0E
03B2:  MOVWF  56
03B4:  RCALL  015A
03B6:  MOVLW  10
03B8:  MOVWF  FE9
03BA:  MOVFF  55,57
03BE:  MOVFF  54,56
03C2:  BRA    01B6
03C4:  MOVLW  22
03C6:  MOVWF  FF6
03C8:  MOVLW  00
03CA:  MOVWF  FF7
03CC:  MOVLW  08
03CE:  MOVWF  56
03D0:  RCALL  015A
03D2:  MOVFF  53,56
03D6:  MOVLW  18
03D8:  MOVWF  57
03DA:  BRA    029A
03DC:  RCALL  0346
....................          //dbg_return_carriage(); 
....................       } 
....................       i2c_tryout_error = i2c_tryout_error +1; 
03DE:  MOVLW  01
03E0:  ADDWF  54,F
03E2:  MOVLW  00
03E4:  ADDWFC 55,F
....................       delay_us(254); 
03E6:  MOVLW  FE
03E8:  MOVWF  56
03EA:  BRA    0354
03EC:  BRA    0378
....................    } 
....................    return i2c_try; 
03EE:  MOVFF  53,01
03F2:  GOTO   041E (RETURN)
.................... } 
....................  
.................... void i2cEngine(int1 eeprom_read = FALSE) //, unsigned int8 = 0) 
.................... { 
....................    disable_interrupts(GLOBAL); 
*
0414:  BCF    FF2.6
0416:  BCF    FF2.7
0418:  BTFSC  FF2.7
041A:  BRA    0416
....................     
....................    int8  i2c_ACK=__try_i2c_bus(); 
041C:  BRA    0370
041E:  MOVFF  01,4F
....................     
....................    if (i2c_ACK==0) 
0422:  MOVF   4F,F
0424:  BTFSS  FD8.2
0426:  BRA    0568
....................    { 
....................    i2c_start(); 
0428:  BSF    FC5.0
042A:  BTFSC  FC5.0
042C:  BRA    042A
....................    delay_us(I2C_DELAY_US); 
042E:  MOVLW  21
0430:  MOVWF  00
0432:  DECFSZ 00,F
0434:  BRA    0432
....................     
....................     
....................     
....................    //unsigned int8 i; 
....................    unsigned int16 i; 
....................  
....................    /* 
....................    #if (I2CReadLength >mcu_Reception_BUFSIZE) 
....................       #error 'B³¹d krytyczny. Nie mo¿esz wysy³aæ wiêcej danych ni¿ pojemnoœæ SlaveBuffer[mcu_Reception_BUFSIZE]' 
....................    #endif*/ 
....................     
....................     
....................    if (I2CWriteLength>0) 
0436:  MOVF   36,F
0438:  BNZ   043E
043A:  MOVF   37,F
043C:  BZ    0472
....................    {      
....................       for(i=0;i<I2CWriteLength; i++) 
043E:  CLRF   51
0440:  CLRF   50
0442:  MOVF   51,W
0444:  SUBWF  37,W
0446:  BNC   0472
0448:  BNZ   0450
044A:  MOVF   36,W
044C:  SUBWF  50,W
044E:  BC    0472
....................       { 
....................          i2c_write(i2c_MasterBuffer[i]); //write to device from buffer 
0450:  MOVLW  04
0452:  ADDWF  50,W
0454:  MOVWF  FE9
0456:  MOVLW  00
0458:  ADDWFC 51,W
045A:  MOVWF  FEA
045C:  MOVFF  FEF,58
0460:  RCALL  00C4
....................          delay_us(I2C_DELAY_US); 
0462:  MOVLW  21
0464:  MOVWF  00
0466:  DECFSZ 00,F
0468:  BRA    0466
046A:  INCF   50,F
046C:  BTFSC  FD8.2
046E:  INCF   51,F
0470:  BRA    0442
....................       } 
....................    } 
....................       if (eeprom_read == TRUE) 
0472:  DECFSZ 4E,W
0474:  BRA    0492
....................    { 
....................       i2c_start(); 
0476:  BSF    FC5.1
0478:  BTFSC  FC5.1
047A:  BRA    0478
....................       delay_us(I2C_DELAY_US); 
047C:  MOVLW  21
047E:  MOVWF  00
0480:  DECFSZ 00,F
0482:  BRA    0480
....................       i2c_write(i2c_MasterBuffer[2]); 
0484:  MOVFF  06,58
0488:  RCALL  00C4
....................       delay_us(I2C_DELAY_US); 
048A:  MOVLW  21
048C:  MOVWF  00
048E:  DECFSZ 00,F
0490:  BRA    048E
....................    }    
....................     
....................    if (I2CReadLength > 0) 
0492:  MOVF   34,F
0494:  BNZ   049A
0496:  MOVF   35,F
0498:  BZ    04FE
....................    {   
....................       int1 state; 
....................       for(i=0;i<I2CReadLength; i++) 
049A:  CLRF   51
049C:  CLRF   50
049E:  MOVF   51,W
04A0:  SUBWF  35,W
04A2:  BNC   04FE
04A4:  BNZ   04AC
04A6:  MOVF   34,W
04A8:  SUBWF  50,W
04AA:  BC    04FE
....................       {   
....................        
....................          if (i<(I2CReadLength-1)) 
04AC:  MOVLW  01
04AE:  SUBWF  34,W
04B0:  MOVWF  00
04B2:  MOVLW  00
04B4:  SUBWFB 35,W
04B6:  MOVWF  03
04B8:  MOVFF  00,01
04BC:  MOVF   51,W
04BE:  SUBWF  03,W
04C0:  BNC   04CE
04C2:  BNZ   04CA
04C4:  MOVF   01,W
04C6:  SUBWF  50,W
04C8:  BC    04CE
....................             state = TRUE; 
04CA:  BSF    52.0
04CC:  BRA    04D0
....................          else 
....................             state = FALSE; 
04CE:  BCF    52.0
....................          i2c_SlaveBuffer[i]=i2c_read(state); 
04D0:  MOVLW  14
04D2:  ADDWF  50,W
04D4:  MOVWF  FE9
04D6:  MOVLW  00
04D8:  ADDWFC 51,W
04DA:  MOVWF  FEA
04DC:  MOVLW  00
04DE:  BTFSC  52.0
04E0:  MOVLW  01
04E2:  MOVWF  55
04E4:  MOVWF  00
04E6:  BRA    03F6
04E8:  MOVFF  01,FEF
....................          delay_us(I2C_INTERBYTE_DELAY_US); 
04EC:  MOVLW  63
04EE:  MOVWF  00
04F0:  DECFSZ 00,F
04F2:  BRA    04F0
04F4:  BRA    04F6
04F6:  INCF   50,F
04F8:  BTFSC  FD8.2
04FA:  INCF   51,F
04FC:  BRA    049E
....................       } 
....................    } 
....................    i2c_stop(); 
04FE:  BSF    FC5.2
0500:  BTFSC  FC5.2
0502:  BRA    0500
....................    delay_us(I2C_DELAY_US); 
0504:  MOVLW  21
0506:  MOVWF  00
0508:  DECFSZ 00,F
050A:  BRA    0508
....................    if (I2CReadLength == 0) 
050C:  MOVF   34,F
050E:  BNZ   053E
0510:  MOVF   35,F
0512:  BNZ   053E
....................       { 
....................          dbg_printf("I2C w.addr:%x ACK", i2c_MasterBuffer[0]); 
0514:  MOVLW  2E
0516:  MOVWF  FF6
0518:  MOVLW  00
051A:  MOVWF  FF7
051C:  MOVLW  0B
051E:  MOVWF  56
0520:  RCALL  015A
0522:  MOVFF  04,56
0526:  MOVLW  57
0528:  MOVWF  57
052A:  RCALL  0178
052C:  MOVLW  3B
052E:  MOVWF  FF6
0530:  MOVLW  00
0532:  MOVWF  FF7
0534:  MOVLW  04
0536:  MOVWF  56
0538:  RCALL  015A
053A:  RCALL  0346
....................          //dbg_return_carriage(); 
....................       } 
053C:  BRA    0566
....................    else 
....................       { 
....................          dbg_printf("I2C r.addr:%x ACK", i2c_MasterBuffer[0]); 
053E:  MOVLW  40
0540:  MOVWF  FF6
0542:  MOVLW  00
0544:  MOVWF  FF7
0546:  MOVLW  0B
0548:  MOVWF  56
054A:  RCALL  015A
054C:  MOVFF  04,56
0550:  MOVLW  57
0552:  MOVWF  57
0554:  RCALL  0178
0556:  MOVLW  4D
0558:  MOVWF  FF6
055A:  MOVLW  00
055C:  MOVWF  FF7
055E:  MOVLW  04
0560:  MOVWF  56
0562:  RCALL  015A
0564:  RCALL  0346
....................          //dbg_return_carriage(); 
....................       } 
....................    break; 
....................    } 
0566:  BRA    05C4
....................    else if (i2c_ACK==1) 
0568:  DECFSZ 4F,W
056A:  BRA    0596
....................    { 
....................    dbg_printf("I2C addr:%x !ACK", i2c_MasterBuffer[0]); 
056C:  MOVLW  52
056E:  MOVWF  FF6
0570:  MOVLW  00
0572:  MOVWF  FF7
0574:  MOVLW  09
0576:  MOVWF  56
0578:  RCALL  015A
057A:  MOVFF  04,56
057E:  MOVLW  57
0580:  MOVWF  57
0582:  RCALL  0178
0584:  MOVLW  5D
0586:  MOVWF  FF6
0588:  MOVLW  00
058A:  MOVWF  FF7
058C:  MOVLW  05
058E:  MOVWF  56
0590:  RCALL  015A
0592:  RCALL  0346
....................    //dbg_return_carriage(); 
....................    break; 
....................    } 
0594:  BRA    05C4
....................    else if (i2c_ACK==2) 
0596:  MOVF   4F,W
0598:  SUBLW  02
059A:  BNZ   05C4
....................    { 
....................    dbg_printf("I2C adr:%x COLISION", i2c_MasterBuffer[0]); 
059C:  MOVLW  64
059E:  MOVWF  FF6
05A0:  MOVLW  00
05A2:  MOVWF  FF7
05A4:  MOVLW  08
05A6:  MOVWF  56
05A8:  RCALL  015A
05AA:  MOVFF  04,56
05AE:  MOVLW  57
05B0:  MOVWF  57
05B2:  RCALL  0178
05B4:  MOVLW  6E
05B6:  MOVWF  FF6
05B8:  MOVLW  00
05BA:  MOVWF  FF7
05BC:  MOVLW  09
05BE:  MOVWF  56
05C0:  RCALL  015A
05C2:  RCALL  0346
....................    //dbg_return_carriage(); 
....................    break; 
....................    } 
....................    I2CWriteLength = 0; 
05C4:  CLRF   37
05C6:  CLRF   36
....................    I2CReadLength = 0; 
05C8:  CLRF   35
05CA:  CLRF   34
....................    enable_interrupts(GLOBAL);  
05CC:  MOVLW  C0
05CE:  IORWF  FF2,F
05D0:  RETURN 0
.................... } 
....................  
.................... //#endif 
....................  
.................... //extern unsigned int   MasterBuffer[mcu_Transmission_BUFSIZE]; 
.................... //extern unsigned int   SlaveBuffer[mcu_Reception_BUFSIZE]; 
....................  
.................... #include </HW_drivers/TEA5767/TEA5767.c> 
.................... /**************************************************************************/ 
.................... /*!  
....................     @file     tea5767.c 
....................     @author   D. Bankowski (d.bankowski@gmail.com) 
....................      
....................     @brief    Driver for the TEA5767 FM receiver. 
....................     @section LICENSE 
....................     Software License Agreement (BSD License) 
....................     Copyright (c) 2017, D. Bankowski 
....................     All rights reserved. 
....................     Redistribution and use in source and binary forms, with or without 
....................     modification, are permitted provided that the following conditions are met: 
....................     1. Redistributions of source code must retain the above copyright 
....................     notice, this list of conditions and the following disclaimer. 
....................     2. Redistributions in binary form must reproduce the above copyright 
....................     notice, this list of conditions and the following disclaimer in the 
....................     documentation and/or other materials provided with the distribution. 
....................     3. Neither the name of the copyright holders nor the 
....................     names of its contributors may be used to endorse or promote products 
....................     derived from this software without specific prior written permission. 
....................     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY 
....................     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY 
....................     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
.................... */ 
.................... /**************************************************************************/ 
....................  
.................... #include </TEA5767.h> 
.................... /**************************************************************************/ 
.................... /*!  
....................     @file     tea5767.h 
....................     @author   D. Bankowski (d.bankowski@gmail.com) 
....................      
....................     @brief    Driver for the TEA5767 FM receiver. 
....................     @section LICENSE 
....................     Software License Agreement (BSD License) 
....................     Copyright (c) 2017, D. Bankowski 
....................     All rights reserved. 
....................     Redistribution and use in source and binary forms, with or without 
....................     modification, are permitted provided that the following conditions are met: 
....................     1. Redistributions of source code must retain the above copyright 
....................     notice, this list of conditions and the following disclaimer. 
....................     2. Redistributions in binary form must reproduce the above copyright 
....................     notice, this list of conditions and the following disclaimer in the 
....................     documentation and/or other materials provided with the distribution. 
....................     3. Neither the name of the copyright holders nor the 
....................     names of its contributors may be used to endorse or promote products 
....................     derived from this software without specific prior written permission. 
....................     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY 
....................     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY 
....................     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
.................... */ 
.................... /**************************************************************************/ 
....................  
.................... #ifndef _TEA5767_H_ 
....................    #define _TEA5767_H_  
....................     
....................     
....................    /*       konfiguracja odbiornika wybierz jedn¹ z opcji       */ 
....................     
....................    #ifndef TEA5767_REGION 
....................       #define TEA5767_REGION        "region_US_EUROPE" 
....................       //#define TEA5767_REGION      "region_JAPAN" 
....................    #endif 
....................     
....................    #ifndef  TEA5767_crystal   
....................       //#define TEA5767_crystal    "_13_MHz"              //PLLREF=0 XTAL=0 
....................       #define TEA5767_crystal    "_32_768_kHz"          //PLLREF=0 XTAL=1 
....................       //#define TEA5767_crystal    "_6._5_MHz"            //PLLREF=1 XTAL=0 
....................    #endif 
....................     
....................    #ifndef TEA5767_search_level                          // SSL1 SSL0 Search stop level: 01 = low level (ADC = 5)  
....................                                                          //                              10 = mid level (ADC = 7) 
....................                                                          //                              11 = high level (ADC = 10) 
....................       #define  TEA5767_search_level       "LOW" 
....................       //#define  TEA5767_search_level     "MID" 
....................       //#define  TEA5767_search_level     "HIGH" 
....................    #endif    
....................     
....................     
....................    #ifndef TEA5767_SPEAKERS_MODE 
....................       //#define     TEA5767_SPEAKERS_MODE       "FORCE_MONO" 
....................       #define     TEA5767_SPEAKERS_MODE       "FORCE_STEREO" 
....................    #endif    
....................     
....................    #ifndef TEA5767_High_Low_Side_Injection 
....................       #define  TEA5767_High_Low_Side_Injection  "HIGH" 
....................       //#define  TEA5767_High_Low_Side_Injection  "LOW" 
....................    #endif 
....................     
....................    #ifndef TEA5767_SoftwareProgramablePort1        //Software programmable port 1: if SWP1 = 1 then port 1 is HIGH; if SWP1 = 0 then port 1 is LOW 
....................       //#define TEA5767_SoftwareProgramablePort1     "HIGH" 
....................       #define TEA5767_SoftwareProgramablePort1     "LOW" 
....................    #endif 
....................     
....................    #ifndef TEA5767_SoftwareProgramablePort2        //Software programmable port 2: if SWP2 = 1 then port 1 is HIGH; if SWP2 = 0 then port 1 is LOW 
....................       //#define TEA5767_SoftwareProgramablePort2     "HIGH" 
....................       #define TEA5767_SoftwareProgramablePort2     "LOW" 
....................    #endif    
....................     
....................    #ifndef  TEA5767_Soft_Mute   
....................       #define TEA5767_Soft_Mute        "YES" 
....................       //#define TEA5767_Soft_Mute      "NO" 
....................    #endif 
....................     
....................    #ifndef  TEA5767_High_Cut_Control   
....................       #define TEA5767_High_Cut_Control   "ON" 
....................       //#define TEA5767_High_Cut_Control   "OFF" 
....................    #endif 
....................     
....................    #ifndef  TEA5767_Stereo_Noise_Cancelling   
....................       //#define TEA5767_Stereo_Noise_Cancelling   "ON" 
....................       #define TEA5767_Stereo_Noise_Cancelling     "OFF" 
....................    #endif    
....................  
....................    #ifndef  TEA5767_Search_Indicator   
....................       #define TEA5767_Search_Indicator          "pin_SWPORT1_is output_for_the_ready"            //Search Indicator: if SI = 1 then pin SWPORT1 is output for the ready flag; if SI = 0 then pin SWPORT1 is software programmable port 1 
....................       //#define TEA5767_Search_Indicator            "pin_SWPORT1_is_software_programmable_port_1"    //Search Indicator: if SI = 1 then pin SWPORT1 is output for the ready flag; if SI = 0 then pin SWPORT1 is software programmable port 1 
....................    #endif    
....................     
....................    #ifndef  TEA5767_DTC_time   
....................       #define TEA5767_DTC_time       "75us"        //if DTC = 1 then the de-emphasis time constant is 75 us; if DTC = 0 then the de-emphasis time constant is 50 us 
....................       //#define TEA5767_DTC_time       "50us"        //if DTC = 1 then the de-emphasis time constant is 75 us; if DTC = 0 then the de-emphasis time constant is 50 us 
....................    #endif 
....................     
....................    /*       konfiguracja odbiornika wybierz jedn¹ z opcji       */ 
....................  
....................    /*========================================================================= 
....................        I2C ADDRESS/BITS 
....................        -----------------------------------------------------------------------*/ 
....................    #define TEA5767_ADDRESS_WRITE                      (0xC0)  // 1100000b 
....................                                                         // b = 0 write addres  
....................                                                         // b = 1 read addres                                                       
....................    #define TEA5767_ADDRESS_READ                       (0x01) 
....................    /*=========================================================================*/    
....................     
....................    /*========================================================================= 
....................        I2C bytes/ bit adresses 
....................        -----------------------------------------------------------------------*/ 
....................  
....................    /*========================================================================= 
....................        WRITE BYTE 1 
....................        MUTE | SEARCHMODE | PLL13 | PLL12 | PLL11 | PLL10 | PLL9 | PLL8 
....................        -----------------------------------------------------------------------*/ 
....................    #define TEA5767_WRITE_byte_1        0 
....................  
....................    #define TEA5767_MUTE_bit            7 
....................    #define TEA5767_SEARCHMODE_bit      6 
....................    #define TEA5767_PLL13_bit           5 
....................    #define TEA5767_PLL12_bit           4 
....................    #define TEA5767_PLL11_bit           3 
....................    #define TEA5767_PLL10_bit           2 
....................    #define TEA5767_PLL9_bit            1 
....................    #define TEA5767_PLL8_bit            0 
....................    #define TEA5767_PLL13_8_bit_mask    0x3F 
....................  
....................    //bit:7 
....................    #define TEA5767_MUTE_ON             1   // 1 = mute,  (mute enabled after reset) 
....................    #define TEA5767_MUTE_OFF            0    // 0 = output enabled, 
....................    //bit:6 
....................    #define TEA5767_SEARCHMODE_enable   1     // 1 = Search mode enabled 
....................    #define TEA5767_SEARCHMODE_disable  0     // 0 = Search mode disabled 
....................    //bit:5-0 
....................    //      PLL val is salculated for frequency by tea5767CalculatePLL  
....................  
....................  
....................    /*========================================================================= 
....................        WRITE BYTE 2 
....................        PLL7 | PLL6 | PLL5 | PLL4 | PLL3 | PLL2 | PLL1 | PLL0     
....................        -----------------------------------------------------------------------*/ 
....................    #define TEA5767_WRITE_byte_2     1 
....................  
....................    #define TEA5767_PLL7_bit         7 
....................    #define TEA5767_PLL6_bit         6 
....................    #define TEA5767_PLL5_bit         5 
....................    #define TEA5767_PLL4_bit         4 
....................    #define TEA5767_PLL3_bit         3 
....................    #define TEA5767_PLL2_bit         2 
....................    #define TEA5767_PLL1_bit         1 
....................    #define TEA5767_PLL0_bit         0 
....................    #define TEA5767_PLL7_0_bit_mask  0xFF 
....................    //bit:7-0 
....................    //      PLL val is salculated for frequency by tea5767CalculatePLL    
....................  
....................  
....................    /*========================================================================= 
....................        WRITE BYTE 3     
....................        SUD | SSL1 | SSL0 | HLSI | MS | MR | ML | SWP1 
....................        -----------------------------------------------------------------------*/ 
....................    #define TEA5767_WRITE_byte_3        2 
....................  
....................    #define TEA5767_SearchUpDown_bit                7 
....................    #define TEA5767_SearchStopLevel_1_bit           6 
....................    #define TEA5767_SearchStopLevel_0_bit           5 
....................    #define TEA5767_HighLowSideInjection_bit        4 
....................    #define TEA5767_Mono2Stereo_bit                 3 
....................    #define TEA5767_MuteRight_bit                   2 
....................    #define TEA5767_MuteLeft_bit                    1 
....................    #define TEA5767_SoftwareProgrammablePort1_bit   0 
....................  
....................    //bit:7 
....................    #define TEA5767_SEARCHUP            1  // 1 = search up, 0 = search down 
....................    #define TEA5767_SEARCHDOWN          0  // 1 = search up, 0 = search down 
....................       //#define TEA5767_WRITE3_SEARCHDIRECTION              (1<<7)  // 1 = search up, 0 = search down 
....................    //bit:6-5 
....................    #if      TEA5767_search_level=="LOW" 
....................       #define TEA5767_SEARCHSTOPLEVEL          (0x20)  // 0 1 low; level ADC output = 5 
....................    #elif    TEA5767_search_level=="MID" 
....................       #define TEA5767_SEARCHSTOPLEVEL          (0x40)  // 1 0 mid; level ADC output = 7 
....................    #elif    TEA5767_search_level=="HIGH"  
....................       #define TEA5767_SEARCHSTOPLEVEL          (0x60)  // 1 1 high; level ADC output = 10 
....................    #else 
....................       #error "TEA5767_search_level" NOT DEFINED 
....................    #endif 
....................    //bit:4 
....................    #if   TEA5767_High_Low_Side_Injection=="HIGH" 
....................       #define  TEA5767_HLSI_value            1 //High/Low Side Injection: if HLSI = 1 then high side LO injection; if HLSI = 0 then low side LO injection 
....................    #elif TEA5767_High_Low_Side_Injection=="LOW" 
....................       #define  TEA5767_HLSI_value            0 //High/Low Side Injection: if HLSI = 1 then high side LO injection; if HLSI = 0 then low side LO injection 
....................    #else 
....................       #error "TEA5767_High_Low_Side_Injection" NOT DEFINED 
....................    #endif 
....................    //bit:3    
....................    #if   TEA5767_SPEAKERS_MODE=="FORCE_MONO" 
....................          #define TEA5767_MONOTOSTEREO          1     //(1<<3)  // 1 = force mono, 0 = stereo on 
....................    #elif TEA5767_SPEAKERS_MODE=="FORCE_STEREO" 
....................          //#define TEA5767_WRITE3_STEREOTOMONO                 (0<<3)  // 1 = force mono, 0 = stereo on 
....................          #define TEA5767_MONOTOSTEREO          0     //(0<<3)    // 1 = force mono, 0 = stereo on 
....................    #else 
....................          #error   "TEA5767_WRITE3_MONOTOSTEREO" NOT DEFINED 
....................    #endif 
....................    //bit 2 
....................    #define TEA5767_MUTERIGHT_ON                 TEA5767_MUTE_ON     // 1 = mute right audio, 0 = enabled 
....................    #define TEA5767_MUTERIGHT_OFF                TEA5767_MUTE_OFF    // 1 = mute right audio, 0 = enabled 
....................    //bit 1 
....................    #define TEA5767_MUTELEFT_ON                  TEA5767_MUTE_ON     // 1 = mute right audio, 0 = enabled 
....................    #define TEA5767_MUTELEFT_OFF                 TEA5767_MUTE_OFF    // 1 = mute right audio, 0 = enabled 
....................    //bit:0 
....................    #if TEA5767_SoftwareProgramablePort1=="HIGH" 
....................       #define  TEA5767_SWP1_value              1                   //Software programmable port 1: if SWP1 = 1 then port 1 is HIGH; if SWP1 = 0 then port 1 is LOW 
....................    #elif TEA5767_SoftwareProgramablePort1=="LOW" 
....................       #define  TEA5767_SWP1_value              0                   //Software programmable port 1: if SWP1 = 1 then port 1 is HIGH; if SWP1 = 0 then port 1 is LOW    
....................    #else 
....................    #endif 
....................  
....................  
....................    /*========================================================================= 
....................        WRITE BYTE 4 
....................        SWP2 | STBY | BL | XTAL | SMUTE | HCC | SNC | SI 
....................        -----------------------------------------------------------------------*/ 
....................    #define TEA5767_WRITE_byte_4                 3 
....................     
....................    #define TEA5767_SoftwareProgrammablePort2_bit   7 
....................    #define TEA5767_StandBy_bit                     6 
....................    #define TEA5767_BANDLIMITS_bit                  5 
....................    #define TEA5767_XTAL_bit                        4 
....................    #define TEA5767_SoftMUTE_bit                    3 
....................    #define TEA5767_HihgCutControl_bit              2 
....................    #define TEA5767_StereoNoiceCancelling_bit       1 
....................    #define TEA5767_SearchIndicator_bit             0 
....................     
....................    //bit:7 
....................    #ifndef TEA5767_SoftwareProgramablePort2=="HIGH" 
....................       #define TEA5767_SWP2_value                    1  //Software programmable port 2: if SWP2 = 1 then port 2 is HIGH; if SWP2 = 0 then port 2 is LOW           1 
....................    #elif TEA5767_SoftwareProgramablePort2=="LOW" 
....................       #define TEA5767_SWP2_value                    0  //Software programmable port 2: if SWP2 = 1 then port 2 is HIGH; if SWP2 = 0 then port 2 is LOW   
....................    #else 
....................       #error "TEA5767_SoftwareProgramablePort2" NOT DEFINED 
....................    #endif  
....................    //bit:6 
....................    #define TEA5767_STBY_enable                  1  //Standby: if STBY = 1 then in Standby mode; if STBY = 0 then not in Standby mode 
....................    #define TEA5767_STBY_disable                 0  //Standby: if STBY = 1 then in Standby mode; if STBY = 0 then not in Standby mode 
....................    //bit:5 
....................    #if TEA5767_REGION=="region_US_EUROPE" 
....................       #define TEA5767_BANDLIMITS_value          0  // 1 = Japanese FM band, 0 = US/Europe 
....................       #define TEA5767_FM_LIMIT_DOWN                (87500000) 
....................       #define TEA5767_FM_LIMIT_UP                  (108000000)     
....................       #WARNING TEA5767 regfion US_EUROPE from TEA5767_FM_LIMIT_DOWN to TEA5767_FM_LIMIT_UP 
....................    #elif TEA5767_REGION=="region_JAPAN" 
....................       #define TEA5767_BANDLIMITS_value          1  // 1 = Japanese FM band, 0 = US/Europe 
....................       #define TEA5767_FM_LIMIT_DOWN                (76000000) 
....................       #define TEA5767_FM_LIMIT_UP                  (91000000) 
....................       #WARNING TEA5767 regfion JAPAN from TEA5767_FM_LIMIT_DOWN to TEA5767_FM_LIMIT_UP  
....................    #else 
....................       #ERROR   "TEA5767_REGION" NOT DEFINED 
....................    #endif 
....................     
....................    //bit:4 
....................    #if TEA5767_crystal=="_13_MHz"                        //PLLREF=0 XTAL=0   
....................    //#ifdef crystal_13_MHz                               //PLLREF=0 XTAL=0 
....................       #define TEA5767_XTAL_value                0 
....................       #define  TEA5767_crystal_PLL_value      13000000 
....................    //#endif 
....................    //#ifdef crystal_32_768_kHz                           //PLLREF=0 XTAL=1 
....................    #elif TEA5767_crystal=="_32_768_kHz"                  //PLLREF=0 XTAL=1 
....................       #define TEA5767_XTAL_value                1 
....................       #define  TEA5767_crystal_PLL_value      32768       
....................    //#endif 
....................    //#ifdef crystal_6_5_MHz                              //PLLREF=1 XTAL=0 
....................    #elif TEA5767_crystal=="_6._5_MHz"                    //PLLREF=1 XTAL=0  
....................       #define TEA5767_XTAL_value                0 
....................       #define  TEA5767_crystal_PLL_value      6500000 
....................    #else 
....................       #error  "TEA5767_crystal" NOT DEFINED  
....................    #endif 
....................    //bit3 
....................    #if   TEA5767_Soft_Mute=="YES" 
....................       #define TEA5767_SMute_value                    1  //Soft Mute: if SMUTE = 1 then soft mute is ON; if SMUTE = 0 then soft mute is OFF 
....................    #elif TEA5767_Soft_Mute=="NO" 
....................       #define TEA5767_SMute_value                    0  //Soft Mute: if SMUTE = 1 then soft mute is ON; if SMUTE = 0 then soft mute is OFF 
....................    #else 
....................       #error  "TEA5767_Soft_Mute" NOT DEFINED 
....................    #endif 
....................    //bit:2 
....................    #if   TEA5767_High_Cut_Control=="ON" 
....................       #define TEA5767_HCC_value                       1     //High Cut Control: if HCC = 1 then high cut control is ON; if HCC = 0 then high cut control is OFF 
....................    #elif TEA5767_High_Cut_Control=="OFF" 
....................       #define TEA5767_HCC_value                       0     //High Cut Control: if HCC = 1 then high cut control is ON; if HCC = 0 then high cut control is OFF 
....................    #else 
....................       #error  "TEA5767_High_Cut_Control" NOT DEFINED    
....................    #endif 
....................    //bit:1 
....................    #if   TEA5767_Stereo_Noise_Cancelling=="ON" 
....................       #define TEA5767_SNC_value                       1     //Stereo Noise Cancelling: if SNC = 1 then stereo noise cancelling is ON; if SNC = 0 then stereo noise cancelling is OFF 
....................    #elif TEA5767_Stereo_Noise_Cancelling=="OFF" 
....................       #define TEA5767_SNC_value                       0     //Stereo Noise Cancelling: if SNC = 1 then stereo noise cancelling is ON; if SNC = 0 then stereo noise cancelling is OFF 
....................    #else 
....................       #error  "TEA5767_Stereo_Noise_Cancellinge" NOT DEFINED 
....................    #endif 
....................    //bit:0 
....................    #if   TEA5767_Search_Indicator=="pin_SWPORT1_is output_for_the_ready" 
....................       #define TEA5767_SI_output_ready__port1          1     //Search Indicator: if SI = 1 then pin SWPORT1 is output for the ready flag; if SI = 0 then pin SWPORT1 is software programmable port 1    
....................    #elif TEA5767_Search_Indicator=="pin_SWPORT1_is_software_programmable_port_1" 
....................       #define TEA5767_SI_output_ready__port1          0     //Search Indicator: if SI = 1 then pin SWPORT1 is output for the ready flag; if SI = 0 then pin SWPORT1 is software programmable port 1    
....................    #else 
....................       #error  "TEA5767_Search_Indicator" NOT DEFINED    
....................    #endif 
....................  
....................  
....................    /*========================================================================= 
....................        WRITE BYTE 5 
....................        PLLREF | DTC | -- | -- | -- | -- | -- | -- 
....................        -----------------------------------------------------------------------*/    
....................    #define TEA5767_WRITE_byte_5 4 
....................     
....................    #define TEA5767_PLLREF_bit                  7 
....................    #define TEA5767_De_emphasisTimeConstant_bit       6 
....................     
....................    //bit:7 
....................    #if TEA5767_crystal=="_13_MHz"                        //PLLREF=0 XTAL=0   
....................    //#ifdef crystal_13_MHz                                       //PLLREF=0 XTAL=0 
....................       #define TEA5767_PLLREF_value                0   
....................    //#endif 
....................    //#ifdef crystal_32_768_kHz                                   //PLLREF=0 XTAL=1 
....................    #elif TEA5767_crystal=="_32_768_kHz"                  //PLLREF=0 XTAL=1 
....................       #define TEA5767_PLLREF_value                0   
....................    //#endif 
....................    //#ifdef crystal_6_5_MHz                                      //PLLREF=1 XTAL=0 
....................    #elif TEA5767_crystal=="_6._5_MHz"                    //PLLREF=1 XTAL=0  
....................       #define TEA5767_PLLREF_value                1 
....................    #else 
....................       #error  "TEA5767_crystal" NOT DEFINED 
....................    #endif 
....................    //bit:6 
....................     
....................    #if   TEA5767_DTC_time=="75us"        //if DTC = 1 then the de-emphasis time constant is 75 us; if DTC = 0 then the de-emphasis time constant is 50 us 
....................       #define TEA5767_DTC__value                1  //if DTC = 1 then the de-emphasis time constant is 75 µs; if DTC = 0 then the de-emphasis time constant is 50 µs 
....................    #elif TEA5767_DTC_time=="50us"        //if DTC = 1 then the de-emphasis time constant is 75 us; if DTC = 0 then the de-emphasis time constant is 50 us      
....................       #define TEA5767_DTC__value                 0  //if DTC = 1 then the de-emphasis time constant is 75 µs; if DTC = 0 then the de-emphasis time constant is 50 µs 
....................    #else 
....................       #error  "TEA5767_DTC_time" NOT DEFINED 
....................    #endif 
....................    //bit:5-0 
....................    //    not used; position is don't care 
....................  
....................    
....................    /*========================================================================= 
....................        READ BYTE 1 
....................        RF | BLF | PLL13 | PLL12 | PLL11 | PLL 10 | PLL9 | PLL8 
....................        -----------------------------------------------------------------------*/ 
....................    #define TEA5767_READ_byte_1        0 
....................     
....................    #define TEA5767_ReadyFlag_bit      7 
....................    #define TEA5767_BandLimitFlag_bit  6 
....................    //PLL - same as write 
.................... /* #define TEA5767_PLL13_bit           5 
....................    #define TEA5767_PLL12_bit           4 
....................    #define TEA5767_PLL11_bit           3 
....................    #define TEA5767_PLL10_bit           2 
....................    #define TEA5767_PLL9_bit            1 
....................    #define TEA5767_PLL8_bit            0*/   
....................     
....................    //bit:7 
....................    #define  TEA5767_StationFound_or_LimitReached   1     //Ready Flag: if RF = 1 then a station has been found or the band limit has been reached; if RF = 0 then no station has been found 
....................    #define  TEA5767_NO_StationFound                0     //Ready Flag: if RF = 1 then a station has been found or the band limit has been reached; if RF = 0 then no station has been found 
....................    //bit:6 
....................    #define  TEA5767_BandLimit_reached              1     //Band Limit Flag: if BLF = 1 then the band limit has been reached; if BLF = 0 then the band limit has not been reached 
....................    #define  TEA5767_BandLimit_NOT_reached          0     //Band Limit Flag: if BLF = 1 then the band limit has been reached; if BLF = 0 then the band limit has not been reached    
....................  
....................    #define TEA5767_search_status_NOTfound_NOTreached   0b00  // no station found no band limit reached 
....................    //#define TEA5767_search_status                   0b01  // not possible 
....................    #define TEA5767_search_status_found_NOTreached     0b10  // station found no band limit reached 
....................    #define TEA5767_search_status_found_reached        0b11  // station found band limit reached 
....................  
.................... //bit5-0 
....................    //depend on TEA5767 - can be calculated back to humen value by tea5767GetFrequency and tea5767GetFrequencySignificant 
....................  
....................    /*========================================================================= 
....................        READ BYTE 2 
....................        PLL7 | PLL6 | PLL5 | PLL4 | PLL3 | PLL2 | PLL1 | PLL0 
....................        -----------------------------------------------------------------------*/    
....................    #define TEA5767_READ_byte_2      1 
....................    //PLL - same as write 
.................... /*   #define TEA5767_PLL7_bit         7 
....................    #define TEA5767_PLL6_bit         6 
....................    #define TEA5767_PLL5_bit         5 
....................    #define TEA5767_PLL4_bit         4 
....................    #define TEA5767_PLL3_bit         3 
....................    #define TEA5767_PLL2_bit         2 
....................    #define TEA5767_PLL1_bit         1 
....................    #define TEA5767_PLL0_bit         0*/ 
....................     
....................    //bit:7-0 
....................    //depend on TEA5767 - can be calculated back to humen value by tea5767GetFrequency and tea5767GetFrequencySignificant    
....................  
....................  
....................    /*========================================================================= 
....................        READ BYTE 3 
....................        STEREO | IF6 | IF5 | IF4 | IF3 | IF2 | IF1 | IF0 
....................        -----------------------------------------------------------------------*/    
....................     
....................    #define TEA5767_READ_byte_3 2 
....................     
....................    #define TEA5767_STEREO_MONO_reception_bit 7 
....................    #define TEA5767_IF6_bit                   6 
....................    #define TEA5767_IF5_bit                   5 
....................    #define TEA5767_IF4_bit                   4 
....................    #define TEA5767_IF3_bit                   3 
....................    #define TEA5767_IF2_bit                   2 
....................    #define TEA5767_IF1_bit                   1 
....................    #define TEA5767_IF0_bit                   0 
....................     
....................    //bit:7 
....................    #define TEA5767_STEREO_reception          1  //Stereo indication: if STEREO = 1 then stereo reception; if STEREO = 0 then mono reception 
....................    #define TEA5767_MONO_reception            0  //Stereo indication: if STEREO = 1 then stereo reception; if STEREO = 0 then mono reception 
....................    //bit:6-0 
....................    //PLL[13:8] IF counter result 
....................  
....................      
....................    /*========================================================================= 
....................        READ BYTE 4 
....................        LEV3 | LEV2 | LEV1 | LEV0 | CI3 | CI2 | CI1 | - 
....................        -----------------------------------------------------------------------*/     
....................     
....................    #define TEA5767_READ_byte_4               3 
....................     
....................    #define TEA5767_LEV3_bit                  7 
....................    #define TEA5767_LEV2_bit                  6 
....................    #define TEA5767_LEV1_bit                  5 
....................    #define TEA5767_LEV0_bit                  4 
....................    #define TEA5767_CI3_bit                   3 
....................    #define TEA5767_CI2_bit                   2 
....................    #define TEA5767_CI1_bit                   1 
....................    #define TEA5767_0_bit                     0 
....................    //#define   //reserved for future extensions; these bits are internally set to logic 0 
....................     
....................    //bit:7-4 
....................    #define TEA5767_station_level_low         5                 // SSL1 SSL0 Search stop level: low level (ADC = 5) mid level (ADC = 7) high level (ADC = 10) 
....................    #define TEA5767_station_level_medium      7                 // SSL1 SSL0 Search stop level: low level (ADC = 5) mid level (ADC = 7) high level (ADC = 10) 
....................    #define TEA5767_station_level_high        10                 // SSL1 SSL0 Search stop level: low level (ADC = 5) mid level (ADC = 7) high level (ADC = 10) 
....................    //bit:3-1 
....................    //Chip Identification: these bits have to be set to logic 0 
....................    //bit:0 
....................    //reserved for future extensions; these bits are internally set to logic 0 
....................     
....................     
....................    /*========================================================================= 
....................        READ BYTE 5 
....................        - | - | - | - | - | - | - | - 
....................        -----------------------------------------------------------------------*/ 
....................    
....................    #define TEA5767_READ_byte_5 4 
....................     
....................    //#define   //reserved for future extensions; these bits are internally set to logic 0 
....................     
....................    //bit:7-0 
....................    //reserved for future extensions; these bits are internally set to logic 0 
....................  
....................    /*=========================================================================*/  
....................    void           tea5767SendData                  (unsigned int8 *);  
....................    unsigned int32 tea5767CalculatePLL              (unsigned int32);    
....................    void           tea5767_init                     (unsigned int32); 
....................    void           tea5767_set_frequency            (unsigned int32); 
....................    void           tea5767_SetCommand_SendData      (unsigned int8, int8, unsigned int8); 
....................    void           tea5767_auto_search              (int1, unsigned int32); 
....................  
....................    #define        tea5767_Mute(on_off_value)            (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_1, on_off_value, TEA5767_MUTE_bit)) 
....................  
....................    #define        tea5767_force_MonoStereo(mono_stereo_value)  (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_3 , mono_stereo_value, TEA5767_Mono2Stereo_bit)) 
....................    #define        tea5767_Mute_Right(on_off_value)             (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_3, on_off_value, TEA5767_MuteRight_bit)) 
....................    #define        tea5767_Mute_Left(on_off_value)              (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_3, on_off_value, TEA5767_MuteLeft_bit)) 
....................  
....................  
....................    #define        tea5767_StandBy(enable_disable_value)        (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_4, enable_disable_value, TEA5767_StandBy_bit)) 
....................     
....................    //te funkcje sprawdziæ 
....................    // sprawdziæ czy zmienne zwi¹zane z PLL freq musz¹ byæ unsigned int32 czy wystarczy unsigned int16 
....................    void           tea5767ReadData                     (void); 
....................    unsigned int32 tea5767ReadPLL_frequency            (void); 
....................    unsigned int32 tea5767GetFrequency                 (void); 
....................    unsigned int32 tea5767GetFrequency_humanClosest    (void); 
....................    unsigned int8  tea5767GetStationQualityLevel       (void); 
....................    int1           tea5767GetStereoMonoReceptionStatus (void); 
....................    unsigned int8  tea5767GetSearchStatus              (void); 
....................     
....................     
.................... //   #define        tea5767_Mute_ALL            tea5767_SetCommand_SendData(TEA5767_WRITE_byte_1, 1, TEA5767_MUTE_bit);      // TEA5767_MUTE_ON TEA5767_MUTE_OFF 
.................... //   void           tea5767SetFreq                   (unsigned int32); //do not set Active anthena ON 
....................  
.................... //   unsigned int32 tea5767GetFrequency              (void); 
.................... //   unsigned int32 tea5767GetFrequencySignificant   (void); 
.................... //   void           tea5767ReadData                  (void); 
.................... //   void           tea5767Mute                      (void); 
.................... //   //void           tea5767Standby                   (int8); 
.................... //   void           tea5767Standby                   (int8);    
.................... //   void           tea5767ForceMono                 (int8);  //state  ON- mono OFF-stereo 
.................... //   void           tea5767MuteRight                 (int8);  //state  ON- mute OFF-no mute 
.................... //   void           tea5767MuteLeft                  (int8);  //state  ON- mute OFF-no mute 
.................... //   void           tea5767Scan                      (unsigned int32, int8, int8); 
.................... //   void           tea5767SetBit2ScanOFF            (void); 
.................... //   BYTE           tea5767StereoReception           (void); 
.................... //   BYTE           tea5767ScanModeStatus            (void); 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef _I2C_ENGINE_ 
....................    #include </core/I2C/I2C_Engine.c> 
.................... #endif 
....................  
.................... #ifndef __silelis_math__ 
....................    #include </core/silelis_math/silelis_math.c> 
.................... #ifndef __silelis_math__ 
....................    #define __silelis_math__ 
....................     
....................    #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................    #include </BIT_MATH.c> 
.................... #ifndef _BIT_MATH_ 
....................        
....................       #include </BIT_MATH.h> 
.................... #ifndef _BIT_MATH_ 
....................    #define _BIT_MATH_ 
....................    unsigned int8 n_value_bits_to_x(unsigned int8 , int8, unsigned int8 ); 
....................    unsigned int8 nth_bit_to_x(unsigned int8, int8, unsigned int8); 
....................    unsigned int8 set_bit(unsigned int8, unsigned int8); 
....................    unsigned int8 clear_bit(unsigned int8, unsigned int8); 
....................    unsigned int8 toggle_bit(unsigned int8, unsigned int8); 
....................    int1 check_bit(unsigned int8, unsigned int8); 
....................    unsigned int MSB_to_LSM(unsigned int); 
.................... #endif 
....................  
....................        
....................        
....................       //BIT MATHEMATIC 
....................       //http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c 
....................        
....................       /* 
....................       Setting a bit 
....................        
....................       Use the bitwise OR operator (|) to set a bit. 
....................        
....................       number |= 1 << x; 
....................       That will set bit x. 
....................        
....................       Clearing a bit 
....................        
....................       Use the bitwise AND operator (&) to clear a bit. 
....................        
....................       number &= ~(1 << x); 
....................       That will clear bit x. You must invert the bit string with the bitwise NOT operator (~), then AND it. 
....................        
....................       Toggling a bit 
....................        
....................       The XOR operator (^) can be used to toggle a bit. 
....................        
....................       number ^= 1 << x; 
....................       That will toggle bit x. 
....................        
....................       Checking a bit 
....................        
....................       You didn't ask for this but I might as well add it. 
....................        
....................       To check a bit, shift the number x to the right, then bitwise AND it: 
....................        
....................       bit = (number >> x) & 1; 
....................       That will put the value of bit x into the variable bit. 
....................        
....................       Changing the nth bit to x 
....................        
....................       Setting the nth bit to either 1 or 0 can be achieved with the following: 
....................        
....................       number ^= (-x ^ number) & (1 << n); 
....................       */ 
....................        
....................       unsigned int8 nth_bit_to_x(unsigned int8 var_to_change, int8 x, unsigned int8 nth_bit) 
....................       { 
....................       /* zmienia na x konkretny bit*/ 
....................       var_to_change = (var_to_change & ~(1<<nth_bit)) | (x<<nth_bit); 
*
0754:  MOVLW  01
0756:  MOVWF  00
0758:  MOVF   4D,W
075A:  MOVWF  01
075C:  BZ    0766
075E:  BCF    FD8.0
0760:  RLCF   00,F
0762:  DECFSZ 01,F
0764:  BRA    075E
0766:  MOVF   00,W
0768:  XORLW  FF
076A:  ANDWF  4B,W
076C:  MOVWF  4E
076E:  MOVFF  4C,00
0772:  MOVF   4D,W
0774:  MOVWF  01
0776:  BZ    0780
0778:  BCF    FD8.0
077A:  RLCF   00,F
077C:  DECFSZ 01,F
077E:  BRA    0778
0780:  MOVF   00,W
0782:  IORWF  4E,W
0784:  MOVWF  4B
....................        
....................       return var_to_change; 
0786:  MOVFF  4B,01
078A:  RETURN 0
....................       } 
....................        
....................        
....................       unsigned int8 n_value_bits_to_x(unsigned int8 var_to_change, int8 x, unsigned int8 n_value) 
....................       { 
....................       /* zmienia na x bity daj¹ce wartoœæ n_value eg. 65 zminei bity 0?00000?*/ 
....................          // x ON = 1 
....................          // x OFF= 0 
....................          // nth as bitmask for ex. 7th bit 1<<7 
....................          var_to_change^= (-x ^ var_to_change) & n_value; 
....................       return var_to_change; 
....................       } 
....................        
....................        
....................       unsigned int8 set_bit(unsigned int8 var_to_change, unsigned int8 nth) 
....................       { 
....................          var_to_change |= 1 << nth; 
....................          return var_to_change; 
....................       } 
....................        
....................        
....................       unsigned int8 clear_bit(unsigned int8 var_to_change, unsigned int8 nth) 
....................       { 
....................          var_to_change &= ~(1 << nth); 
....................          return var_to_change; 
....................       } 
....................        
....................       unsigned int8 toggle_bit(unsigned int8 var_to_change, unsigned int8 nth) 
....................       { 
....................          var_to_change ^= 1 << nth; 
....................          return var_to_change; 
....................       } 
....................        
....................       int1 check_bit(unsigned int8 var_to_check, unsigned int8 nth) 
....................       { 
....................          int1 bit = (var_to_check >> nth) & 1; 
....................          return bit; 
....................       } 
....................        
....................       unsigned int MSB_to_LSM(unsigned int num) 
....................          /* function change bit order - i.e. required between PIC and 8051 mcu communication*/ 
....................       { 
....................           unsigned int  NO_OF_BITS = sizeof(num) * 8; 
....................           unsigned int reverse_num = 0, i, temp; 
....................         
....................           for (i = 0; i < NO_OF_BITS; i++) 
....................           { 
....................               temp = (num & (1 << i)); 
....................               if(temp) 
....................                   reverse_num |= (1 << ((NO_OF_BITS - 1) - i)); 
....................           } 
....................          
....................           return reverse_num; 
....................       } 
....................        
.................... #endif 
....................  
....................  
....................    unsigned int random(unsigned int min, unsigned int  max) 
....................    { 
....................        unsigned int tmp; 
....................        if (max>=min) 
....................            max-= min; 
....................        else 
....................        { 
....................            tmp= min - max; 
....................            min= max; 
....................            max= tmp; 
....................        } 
....................        return max ? (rand() % max + min) : min; 
....................    } 
....................  
....................    unsigned int32 round_closest(float dividend, float divisor) 
....................    { 
....................        return (dividend + (divisor / 2)) / divisor; 
....................    } 
....................        
....................     
.................... #endif 
....................  
.................... #endif 
....................  
.................... /* 
.................... #ifndef _BIT_MATH_ 
....................    #include </core/BIT_MATH/BIT_MATH.c> 
.................... #endif*/ 
....................  
....................  
.................... //#ifdef ACTIVE_ANTENA  
.................... //   #include </HW_drivers/AAntena/ActiveAntena.c> 
.................... //#endif 
....................  
.................... /* 
.................... #define ON        1 
.................... #define OFF       0 
.................... #define SCAN_UP   1 
.................... #define SCAN_DOWN 0*/ 
....................  
.................... //extern volatile unsigned int8 MasterBuffer[I2C_BUFSIZE]; 
.................... //extern volatile unsigned int8 SlaveBuffer[I2C_BUFSIZE]; 
.................... /* 
.................... extern volatile unsigned int16 I2CReadLength; 
.................... extern volatile unsigned int16 I2CWriteLength;*/ 
.................... //extern volatile unsigned int8  tea5767_config[5]; 
.................... volatile unsigned int8  tea5767_config[5]; 
....................  
.................... //#define        last_READ      0 
.................... //#define        last_WRITE     1 
.................... //volatile int1  TEA5767_last_i2c_action_WRITE; //Should be last_action_READ at startup 
....................  
.................... unsigned int32 tea5767CalculatePLL (unsigned int32 freqency) 
*
06E6:  MOVLW  E8
06E8:  ADDWF  4B,W
06EA:  MOVWF  00
06EC:  MOVLW  6E
06EE:  ADDWFC 4C,W
06F0:  MOVWF  01
06F2:  MOVLW  03
06F4:  ADDWFC 4D,W
06F6:  MOVWF  02
06F8:  MOVLW  00
06FA:  ADDWFC 4E,W
06FC:  MOVWF  03
06FE:  RLCF   00,W
0700:  MOVWF  4F
0702:  RLCF   01,W
0704:  MOVWF  50
0706:  RLCF   02,W
0708:  MOVWF  51
070A:  RLCF   03,W
070C:  MOVWF  52
070E:  RLCF   4F,F
0710:  RLCF   50,F
0712:  RLCF   51,F
0714:  RLCF   52,F
0716:  MOVLW  FC
0718:  ANDWF  4F,F
.................... ///* 
.................... //This function calculates frequency as PLL which should be sent to TEA5767 
.................... //*/ 
.................... { 
....................    unsigned int32 temp= 4* (freqency + 225000); 
....................    return temp/ TEA5767_crystal_PLL_value; 
071A:  CLRF   03
071C:  RRCF   52,W
071E:  MOVWF  02
0720:  RRCF   51,W
0722:  MOVWF  01
0724:  RRCF   50,W
0726:  MOVWF  00
0728:  RRCF   02,F
072A:  RRCF   01,F
072C:  RRCF   00,F
072E:  RRCF   02,F
0730:  RRCF   01,F
0732:  RRCF   00,F
0734:  RRCF   02,F
0736:  RRCF   01,F
0738:  RRCF   00,F
073A:  RRCF   02,F
073C:  RRCF   01,F
073E:  RRCF   00,F
0740:  RRCF   02,F
0742:  RRCF   01,F
0744:  RRCF   00,F
0746:  RRCF   02,F
0748:  RRCF   01,F
074A:  RRCF   00,F
074C:  MOVLW  01
074E:  ANDWF  02,F
0750:  GOTO   080E (RETURN)
.................... } 
....................  
.................... void tea5767SendData(unsigned int8 *bytes) 
.................... { 
....................   // Clear write buffers 
....................    //ClearBuffers(&MasterBuffer,I2C_BUFSIZE); 
....................    i2c_ClearMasterBuffer  (); 
*
078C:  CLRF   51
078E:  MOVLW  04
0790:  MOVWF  50
0792:  CLRF   53
0794:  MOVLW  10
0796:  MOVWF  52
0798:  RCALL  0078
....................    //TODO: To daæ do i2c_Engine - jako generaln¹ funkcjê fill buffer w wersj dla I2C i innych np. UART 
....................    I2CWriteLength = 6; //i2cEngine write information 
079A:  CLRF   37
079C:  MOVLW  06
079E:  MOVWF  36
....................    I2CReadLength = 0;  //i2cEngine read information 
07A0:  CLRF   35
07A2:  CLRF   34
....................    i2c_MasterBuffer[0] = TEA5767_ADDRESS_WRITE; 
07A4:  MOVLW  C0
07A6:  MOVWF  04
....................    unsigned int8 i; 
....................    for ( i = 1; i < I2CWriteLength; i++ ) 
07A8:  MOVLW  01
07AA:  MOVWF  4D
07AC:  MOVF   37,F
07AE:  BNZ   07B6
07B0:  MOVF   36,W
07B2:  SUBWF  4D,W
07B4:  BC    07E4
....................    { 
....................       *(i2c_MasterBuffer+i) = bytes[i-1];  
07B6:  MOVLW  04
07B8:  ADDWF  4D,W
07BA:  MOVWF  01
07BC:  CLRF   03
07BE:  BTFSC  FD8.0
07C0:  INCF   03,F
07C2:  MOVLW  01
07C4:  SUBWF  4D,W
07C6:  ADDWF  4B,W
07C8:  MOVWF  FE9
07CA:  MOVLW  00
07CC:  ADDWFC 4C,W
07CE:  MOVWF  FEA
07D0:  MOVFF  FEF,50
07D4:  MOVFF  03,FEA
07D8:  MOVFF  01,FE9
07DC:  MOVFF  50,FEF
07E0:  INCF   4D,F
07E2:  BRA    07AC
....................    } 
....................   i2cEngine(FALSE); 
07E4:  CLRF   4E
07E6:  RCALL  0414
07E8:  RETURN 0
....................   //delay_ms(100); 
....................    
.................... //     if (TEA5767_last_i2c_action_WRITE==last_READ) 
....................  
.................... //   { 
.................... //      TEA5767_last_i2c_action_WRITE=last_WRITE; 
....................       //delay_ms(499); 
....................       //dbg_printf("BUG:TEA5767 wykasowaæ linijke wy¿ej"); 
....................  //  } 
.................... } 
....................  
.................... void tea5767ReadData(void) 
.................... { 
....................   i2c_ClearMasterBuffer  (); 
....................   i2c_ClearSlaveBuffers  (); 
....................    
....................    
....................   I2CWriteLength = 1; //"1" beacause i2c after start should write adress 
....................   I2CReadLength = 5; 
....................   i2c_MasterBuffer[0] = TEA5767_ADDRESS_WRITE | TEA5767_ADDRESS_READ; 
....................   i2cEngine(FALSE); 
....................    
....................   /*i2c_start(); 
....................   i2c_write(TEA5767_ADDRESS_WRITE | TEA5767_ADDRESS_READ); 
....................   SlaveBuffer[0]=i2c_read(TRUE); 
....................   SlaveBuffer[1]=i2c_read(TRUE); 
....................   SlaveBuffer[2]=i2c_read(TRUE); 
....................   SlaveBuffer[3]=i2c_read(TRUE); 
....................   SlaveBuffer[4]=i2c_read(FALSE); 
....................   i2c_stop(); 
....................   dbg_printf("TEA5767 i2c read bug");*/ 
....................   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
....................   // OPIS BUG'a 
....................   //jest jakiœ bug w czytaniu nie wiem czemu na i2c_engine zawiesza siê tutaj: 
....................   /* 
....................      if (I2CWriteLength>0) 
....................    {   
....................       for(i=0;i<I2CWriteLength; i++) 
....................       { 
....................          i2c_write(MasterBuffer[i]); //write to device from buffer 
....................          //po i2c_write(MasterBuffer[i]); tym siê zawiesza adok³adnie jak jest robiona operacja int8  i2c_ACK=_try_i2c_bus(); przed czytaniem. gdy zrobiê int8  i2c_ACK=0; (nie robi pinga do TEA5767 przed czytaniem to wszystko jest w jak najlepszym porzadku 
....................          delay_us(I2C_DELAY_US); 
....................       } 
....................    } 
....................    */ 
....................    // OPIS BUG'a 
....................   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    
.................... } 
....................  
.................... void tea5767_init(unsigned int32 frequency = TEA5767_FM_LIMIT_DOWN) 
.................... { 
....................    tea5767_config[TEA5767_WRITE_byte_1]=tea5767_config[TEA5767_WRITE_byte_2]=tea5767_config[TEA5767_WRITE_byte_3]=tea5767_config[TEA5767_WRITE_byte_4]=tea5767_config[TEA5767_WRITE_byte_5]=0; 
07EA:  CLRF   42
07EC:  MOVFF  42,41
07F0:  MOVFF  41,40
07F4:  MOVFF  40,3F
07F8:  MOVFF  3F,3E
....................     
....................    unsigned int32 PLL_freq = tea5767CalculatePLL(frequency); 
07FC:  MOVFF  46,4E
0800:  MOVFF  45,4D
0804:  MOVFF  44,4C
0808:  MOVFF  43,4B
080C:  BRA    06E6
080E:  MOVFF  03,4A
0812:  MOVFF  02,49
0816:  MOVFF  01,48
081A:  MOVFF  00,47
....................     
....................    tea5767_config[TEA5767_WRITE_byte_1] = nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_1], TEA5767_MUTE_OFF, TEA5767_MUTE_bit); 
081E:  MOVFF  3E,4B
0822:  CLRF   4C
0824:  MOVLW  07
0826:  MOVWF  4D
0828:  RCALL  0754
082A:  MOVFF  01,3E
....................    tea5767_config[TEA5767_WRITE_byte_1] = nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_1], TEA5767_SEARCHMODE_disable, TEA5767_SEARCHMODE_bit); 
082E:  MOVFF  3E,4B
0832:  CLRF   4C
0834:  MOVLW  06
0836:  MOVWF  4D
0838:  RCALL  0754
083A:  MOVFF  01,3E
....................    //tea5767_config[TEA5767_WRITE_byte_1] |= ((tea5767CalculatePLL(frequency)>> 8) & TEA5767_PLL13_8_bit_mask);//|0;// |TEA5767_WRITE1_SEARCHMODE_OFF; 
....................    tea5767_config[TEA5767_WRITE_byte_1] |= ((PLL_freq>> 8) & TEA5767_PLL13_8_bit_mask);//|0;// |TEA5767_WRITE1_SEARCHMODE_OFF; 
083E:  MOVF   48,W
0840:  ANDLW  3F
0842:  MOVWF  00
0844:  MOVF   00,W
0846:  IORWF  3E,F
....................  
....................    //tea5767_config[TEA5767_WRITE_byte_2] = (tea5767CalculatePLL(frequency) & TEA5767_PLL7_0_bit_mask); 
....................    tea5767_config[TEA5767_WRITE_byte_2] = (PLL_freq & TEA5767_PLL7_0_bit_mask); 
0848:  MOVFF  47,3F
....................     
....................    //tea5767_config[2] = (0x20); 
....................    tea5767_config[TEA5767_WRITE_byte_3] = nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_3], TEA5767_SEARCHDOWN, TEA5767_SearchUpDown_bit); 
084C:  MOVFF  40,4B
0850:  CLRF   4C
0852:  MOVLW  07
0854:  MOVWF  4D
0856:  RCALL  0754
0858:  MOVFF  01,40
....................    tea5767_config[TEA5767_WRITE_byte_3] |= TEA5767_SEARCHSTOPLEVEL; 
085C:  BSF    40.5
....................    tea5767_config[TEA5767_WRITE_byte_3] = nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_3], TEA5767_HLSI_value, TEA5767_HighLowSideInjection_bit); 
085E:  MOVFF  40,4B
0862:  MOVLW  01
0864:  MOVWF  4C
0866:  MOVLW  04
0868:  MOVWF  4D
086A:  RCALL  0754
086C:  MOVFF  01,40
....................    tea5767_config[TEA5767_WRITE_byte_3] = nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_3], TEA5767_MONOTOSTEREO, TEA5767_Mono2Stereo_bit); 
0870:  MOVFF  40,4B
0874:  CLRF   4C
0876:  MOVLW  03
0878:  MOVWF  4D
087A:  RCALL  0754
087C:  MOVFF  01,40
....................    tea5767_config[TEA5767_WRITE_byte_3] = nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_3], TEA5767_MUTELEFT_OFF, TEA5767_MuteRight_bit); 
0880:  MOVFF  40,4B
0884:  CLRF   4C
0886:  MOVLW  02
0888:  MOVWF  4D
088A:  RCALL  0754
088C:  MOVFF  01,40
....................    tea5767_config[TEA5767_WRITE_byte_3] = nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_3], TEA5767_MUTELEFT_OFF, TEA5767_MuteLeft_bit); 
0890:  MOVFF  40,4B
0894:  CLRF   4C
0896:  MOVLW  01
0898:  MOVWF  4D
089A:  RCALL  0754
089C:  MOVFF  01,40
....................    tea5767_config[TEA5767_WRITE_byte_3] = nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_3], TEA5767_SWP1_value, TEA5767_SoftwareProgrammablePort1_bit); 
08A0:  MOVFF  40,4B
08A4:  CLRF   4C
08A6:  CLRF   4D
08A8:  RCALL  0754
08AA:  MOVFF  01,40
....................     
....................    //tea5767_config[3] = (0x14); 
....................    tea5767_config[TEA5767_WRITE_byte_4] =nth_bit_to_x(tea5767_config[3],TEA5767_SWP2_value, TEA5767_SoftwareProgrammablePort2_bit); 
08AE:  MOVFF  41,4B
08B2:  CLRF   4C
08B4:  MOVLW  07
08B6:  MOVWF  4D
08B8:  RCALL  0754
08BA:  MOVFF  01,41
....................    tea5767_config[TEA5767_WRITE_byte_4] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_4],TEA5767_STBY_disable, 6); 
08BE:  MOVFF  41,4B
08C2:  CLRF   4C
08C4:  MOVLW  06
08C6:  MOVWF  4D
08C8:  RCALL  0754
08CA:  MOVFF  01,41
....................    tea5767_config[TEA5767_WRITE_byte_4] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_4],TEA5767_BANDLIMITS_value, 5); 
08CE:  MOVFF  41,4B
08D2:  CLRF   4C
08D4:  MOVLW  05
08D6:  MOVWF  4D
08D8:  RCALL  0754
08DA:  MOVFF  01,41
....................    tea5767_config[TEA5767_WRITE_byte_4] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_4],1, 4); 
08DE:  MOVFF  41,4B
08E2:  MOVLW  01
08E4:  MOVWF  4C
08E6:  MOVLW  04
08E8:  MOVWF  4D
08EA:  RCALL  0754
08EC:  MOVFF  01,41
....................    tea5767_config[TEA5767_WRITE_byte_4] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_4],TEA5767_SMute_value, 3); 
08F0:  MOVFF  41,4B
08F4:  MOVLW  01
08F6:  MOVWF  4C
08F8:  MOVLW  03
08FA:  MOVWF  4D
08FC:  RCALL  0754
08FE:  MOVFF  01,41
....................    tea5767_config[TEA5767_WRITE_byte_4] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_4],TEA5767_HCC_value, 2); 
0902:  MOVFF  41,4B
0906:  MOVLW  01
0908:  MOVWF  4C
090A:  MOVLW  02
090C:  MOVWF  4D
090E:  RCALL  0754
0910:  MOVFF  01,41
....................    tea5767_config[TEA5767_WRITE_byte_4] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_4],TEA5767_SNC_value, 1); 
0914:  MOVFF  41,4B
0918:  CLRF   4C
091A:  MOVLW  01
091C:  MOVWF  4D
091E:  RCALL  0754
0920:  MOVFF  01,41
....................    tea5767_config[TEA5767_WRITE_byte_4] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_4],TEA5767_SI_output_ready__port1, 0); 
0924:  MOVFF  41,4B
0928:  MOVLW  01
092A:  MOVWF  4C
092C:  CLRF   4D
092E:  RCALL  0754
0930:  MOVFF  01,41
....................     
....................    //tea5767_config[4] = (0x40); 
....................    tea5767_config[TEA5767_WRITE_byte_5] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_5], TEA5767_PLLREF_value , TEA5767_PLLREF_bit); 
0934:  MOVFF  42,4B
0938:  CLRF   4C
093A:  MOVLW  07
093C:  MOVWF  4D
093E:  RCALL  0754
0940:  MOVFF  01,42
....................    tea5767_config[TEA5767_WRITE_byte_5] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_5], TEA5767_DTC__value, TEA5767_De_emphasisTimeConstant_bit); 
0944:  MOVFF  42,4B
0948:  MOVLW  01
094A:  MOVWF  4C
094C:  MOVLW  06
094E:  MOVWF  4D
0950:  RCALL  0754
0952:  MOVFF  01,42
....................     
....................    tea5767SendData (&tea5767_config); 
0956:  CLRF   4C
0958:  MOVLW  3E
095A:  MOVWF  4B
095C:  RCALL  078C
095E:  GOTO   0A76 (RETURN)
.................... } 
....................  
.................... void tea5767_set_frequency(unsigned int32 frequency) 
.................... { 
....................    unsigned int32 PLL_freq = tea5767CalculatePLL(frequency); 
....................    //tea5767_config[TEA5767_WRITE_byte_1] |= ((tea5767CalculatePLL(frequency)>> 8) & TEA5767_PLL13_8_bit_mask);//|0;// |TEA5767_WRITE1_SEARCHMODE_OFF; 
....................    //tea5767_config[TEA5767_WRITE_byte_2] = (tea5767CalculatePLL(frequency) & TEA5767_PLL7_0_bit_mask); 
....................     
....................    tea5767_config[TEA5767_WRITE_byte_1] |= ((PLL_freq>> 8) & TEA5767_PLL13_8_bit_mask);//|0;// |TEA5767_WRITE1_SEARCHMODE_OFF; 
....................    tea5767_config[TEA5767_WRITE_byte_2] = (PLL_freq & TEA5767_PLL7_0_bit_mask); 
....................    tea5767SendData (&tea5767_config); 
.................... } 
....................  
.................... void tea5767_SetCommand_SendData(unsigned int8 command_byte, int8 value, unsigned int8 command) 
.................... { 
.................... /* 
.................... command_byte - bit komendy 
.................... value - wartoœæ komendy 
.................... command jaki rozkaz 
.................... */ 
....................    tea5767_config[command_byte] =nth_bit_to_x(tea5767_config[command_byte], value , command); 
*
098A:  CLRF   03
098C:  MOVF   43,W
098E:  ADDLW  3E
0990:  MOVWF  01
0992:  MOVLW  00
0994:  ADDWFC 03,F
0996:  MOVFF  01,46
099A:  MOVFF  03,47
099E:  CLRF   03
09A0:  MOVF   43,W
09A2:  ADDLW  3E
09A4:  MOVWF  FE9
09A6:  MOVLW  00
09A8:  ADDWFC 03,W
09AA:  MOVWF  FEA
09AC:  MOVFF  FEF,4B
09B0:  MOVFF  44,4C
09B4:  MOVFF  45,4D
09B8:  RCALL  0754
09BA:  MOVFF  47,FEA
09BE:  MOVFF  46,FE9
09C2:  MOVFF  01,FEF
....................    tea5767SendData (&tea5767_config); 
09C6:  CLRF   4C
09C8:  MOVLW  3E
09CA:  MOVWF  4B
09CC:  RCALL  078C
09CE:  GOTO   0A92 (RETURN)
.................... } 
....................  
.................... /*#define        tea5767_Mute(on_off_value)            (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_1, on_off_value, TEA5767_MUTE_bit)) 
....................  
.................... #define        tea5767_force_MonoStereo(mono_stereo_value)  (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_3 , mono_stereo_value, TEA5767_Mono2Stereo_bit)) 
.................... #define        tea5767_Mute_Right(on_off_value)             (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_3, on_off_value, TEA5767_MuteRight_bit)) 
.................... #define        tea5767_Mute_Left(on_off_value)              (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_3, on_off_value, TEA5767_MuteLeft_bit)) 
....................  
....................  
.................... #define        tea5767_StandBy(enable_disable_value)        (tea5767_SetCommand_SendData(TEA5767_WRITE_byte_4, enable_disable_value, TEA5767_StandBy_bit))*/ 
....................  
.................... void tea5767_auto_search(int1 direction, unsigned int32 frequency=0) 
.................... /* 
....................    if frequency == 0 auto search from current TEA5767 frequency other case start point is new frequency 
.................... */ 
.................... { 
....................    if (frequency!=0) 
....................    { 
....................       tea5767_config[TEA5767_WRITE_byte_1] |= ((tea5767CalculatePLL(frequency)>> 8) & TEA5767_PLL13_8_bit_mask);//|0;// |TEA5767_WRITE1_SEARCHMODE_OFF; 
....................       tea5767_config[TEA5767_WRITE_byte_2] = (tea5767CalculatePLL(frequency) & TEA5767_PLL7_0_bit_mask); 
....................    } 
....................    tea5767_config[TEA5767_WRITE_byte_1] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_1], TEA5767_SEARCHMODE_enable , TEA5767_SEARCHMODE_bit); 
....................     
....................    tea5767_config[TEA5767_WRITE_byte_3] |= TEA5767_SEARCHSTOPLEVEL; 
....................     
....................     
....................    tea5767_config[TEA5767_WRITE_byte_3] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_3], direction , TEA5767_SearchUpDown_bit ); 
....................    tea5767SendData (&tea5767_config); 
....................    // after send command set TEA5767 bytes to not auto_search condition 
....................    tea5767_config[TEA5767_WRITE_byte_1] =nth_bit_to_x(tea5767_config[TEA5767_WRITE_byte_1], TEA5767_SEARCHMODE_disable , TEA5767_SEARCHMODE_bit); 
.................... } 
....................  
.................... unsigned int32 tea5767ReadPLL_frequency(void) 
.................... {   
....................    //unsigned int32 PLL_frequency; 
....................    tea5767ReadData(); 
....................    unsigned int32 PLL_frequency = (unsigned int16) (i2c_SlaveBuffer[TEA5767_READ_byte_1] & TEA5767_PLL13_8_bit_mask); 
....................    PLL_frequency =  PLL_frequency <<8;    
....................    return PLL_frequency+(i2c_SlaveBuffer[TEA5767_READ_byte_2] & TEA5767_PLL7_0_bit_mask); 
....................     
....................    //SPRAWDZIÆ DZIA£ANIE TEGO!!!!!!!!!!!!! 
.................... } 
....................  
.................... unsigned int8 tea5767GetStationQualityLevel(void) 
.................... /* 
.................... answer: 
.................... TEA5767_station_level_low         5                 // SSL1 SSL0 Search stop level: low level (ADC = 5) mid level (ADC = 7) high level (ADC = 10) 
.................... EA5767_station_level_medium      7                 // SSL1 SSL0 Search stop level: low level (ADC = 5) mid level (ADC = 7) high level (ADC = 10) 
.................... TEA5767_station_level_high        10                 // SSL1 SSL0 Search stop level: low level (ADC = 5) mid level (ADC = 7) high level (ADC = 10) 
.................... */ 
.................... { 
....................    tea5767ReadData(); 
....................    return i2c_SlaveBuffer[TEA5767_READ_byte_4]>>TEA5767_LEV0_bit; 
.................... } 
....................  
.................... int1  tea5767GetStereoMonoReceptionStatus(void) 
.................... /* 
.................... answer: 
.................... TEA5767_STEREO_reception          1  //Stereo indication: if STEREO = 1 then stereo reception; if STEREO = 0 then mono reception 
.................... TEA5767_MONO_reception            0  //Stereo indication: if STEREO = 1 then stereo reception; if STEREO = 0 then mono reception 
.................... */ 
.................... { 
....................    tea5767ReadData(); 
....................    return i2c_SlaveBuffer[TEA5767_READ_byte_3]>>TEA5767_STEREO_MONO_reception_bit; 
.................... } 
....................  
....................  
.................... unsigned int8  tea5767GetSearchStatus(void) 
.................... /* 
.................... answer: 
....................    TEA5767_search_status_NOTfound_NOTreached   0 0b00  // no station found no band limit reached 
....................    //TEA5767_search_status                   0b01  // not possible 
....................    TEA5767_search_status_found_NOTreached     2 0b10  // station found no band limit reached 
....................    TEA5767_search_status_found_reached        3 0b11  // station found band limit reached 
.................... */ 
.................... { 
....................    tea5767ReadData(); 
....................    return i2c_SlaveBuffer[TEA5767_READ_byte_1]>>TEA5767_BandLimitFlag_bit; 
.................... } 
....................  
....................  
.................... unsigned int32 tea5767GetFrequency (void) 
.................... { 
....................    return (((tea5767ReadPLL_frequency()*TEA5767_crystal_PLL_value)/ 4)-225000); 
....................    //temp = (((temp * TEA5767_crystal_PLL_value) / 4) - 225000); 
.................... } 
....................  
.................... unsigned int32 tea5767GetFrequency_humanClosest (void) 
.................... /* 
.................... Because the output of tea5767GetFrequency is different that seted frequency i.e. 
.................... If I set 100200000 to TEA the TEA sets 10019XXXXX frequency so I decided to 
.................... normalise the ending of calculated frequency 
.................... */ 
.................... { 
....................    //return ((unsigned int32) (tea5767GetFrequency() + (100000 / 2)) / 100000)*100000; 
....................    return   (round_closest(tea5767GetFrequency(),100000)*100000); 
.................... } 
....................  
....................  
.................... //unsigned int32 tea5767GetFrequency (void) 
.................... ///* 
.................... //This function calculates frequency based on PLL which is readen form TEA5767 
.................... //*/ 
.................... /*{ 
....................    tea5767ReadData(); 
....................    unsigned int32 temp = (tea5767_config[0] & 0x3F); 
....................    temp = temp << 8; 
....................    temp = temp + tea5767_config[1]; 
....................    temp = (((temp * TEA5767_crystal_PLL_value) / 4) - 225000); 
....................    return temp; 
....................     
....................  /*  #ifdef crystal_13_MHz 
....................       temp = (((temp * 13000000) / 4) - 225000); 
....................       return temp; 
....................    #endif 
....................    #ifdef crystal_32_768_kHz     
....................       temp = (((temp * 32768) / 4) - 225000); 
....................       return temp; 
....................    #endif 
....................    #ifdef crystal_6_5_MHz  
....................       temp = (((temp * 6500000) / 4) - 225000); 
....................       return temp;        
....................    #endif*/ 
.................... //} 
....................  
.................... //unsigned int32 tea5767GetFrequencySignificant (void) 
.................... /* 
.................... Because the output of tea5767GetFrequency is different that seted frequency i.e. 
.................... If I set 100200000 to TEA the TEA sets 10019XXXXX frequency so I decided to 
.................... normalise the ending of calculated frequency 
.................... */ 
.................... /*{ 
....................    unsigned int32 temp = tea5767GetFrequency(); 
....................    return ((temp/100000)+1)*100000; 
.................... }*/ 
....................  
....................  
.................... /*void tea5767SetFreq(unsigned int32 frequency)// = FMfreqency) 
.................... /* 
.................... This function is main TEA tuning funstion sets FREQUENCY 
.................... but do not set Active Anthena so there is no Active Anthena power on delay 
.................... */ 
.................... /*{ 
.................... tea5767_config[0] = ((tea5767CalculatePLL(frequency)>> 8) & 0x3F)|TEA5767_WRITE1_MUTE_OFF |TEA5767_WRITE1_SEARCHMODE_OFF; 
.................... tea5767_config[1] = (tea5767CalculatePLL(frequency) & 0xFF); 
.................... tea5767_config[2] = TEA5767_SEARCHSTOPLEVEL|TEA5767_WRITE3_HLSI; //(0x10); 
.................... //tea5767_config[3] = TEA5767_WRITE4_XTAL|TEA5767_WBYTE4_STEREONOISECANCEL_ON; //(0x10); 
.................... tea5767_config[3] = TEA5767_WRITE4_XTAL|TEA5767_WBYTE4_STEREONOISECANCEL_ON|TEA5767_MONOTOSTEREO; //(0x14); 
.................... tea5767_config[4] = 0; //(0xC0); 
.................... tea5767SendData (&tea5767_config); 
.................... }*/ 
....................  
....................  
.................... //void tea5767_init(unsigned int32 frequency)// = FMfreqency) 
.................... /* 
.................... This function is main TEA funcstion used as init TEA chip, set initial 
.................... frequency and Active anthena set ON so there is AA delay 
.................... */ 
.................... /*{ 
.................... //#ifdef ACTIVE_ANTENA 
.................... //   AAntenna_ON(); 
.................... //#endif 
.................... tea5767SetFreq(frequency); 
.................... }*/ 
....................  
.................... //void tea5767Mute(int8 state)  //state = ON OFF 
.................... /* 
.................... Mute the TEA5767 output 
.................... */ 
.................... /*{ 
.................... tea5767_config[0] = nth_bit_to_x(tea5767_config[0], state, TEA5767_WRITE1_MUTE_ON); 
.................... tea5767SendData (&tea5767_config); 
.................... }*/ 
....................  
.................... //void tea5767Standby(int8 state)  //state = ON OFF 
.................... //void tea5767Standby(void) 
.................... /* 
.................... Switch TEA5767 to Standby mode 
.................... */ 
.................... /*{ 
.................... //tea5767_config[3] = nth_bit_to_x(tea5767_config[3], state, TEA5767_WRITE4_STANDBY_ON); 
.................... tea5767_config[3] = nth_bit_to_x(tea5767_config[3], 1, TEA5767_WRITE4_STANDBY_ON); 
.................... tea5767SendData (&tea5767_config); 
.................... //#ifdef ACTIVE_ANTENA 
.................... //   /*if (state==1) 
.................... //      {*/ 
.................... //      //output_low(ACTIVE_ANTENA); 
.................... //      AAntenna_OFF(); 
.................... //     /* } 
.................... //   else 
.................... //   { 
.................... //   AAntenna_ON(); 
.................... //   }   */ 
.................... //#endif 
.................... //} 
....................  
.................... /*void tea5767ForceMono(int8 state)  //state  ON- mono OFF-stereo 
.................... { 
.................... tea5767_config[2] = nth_bit_to_x(tea5767_config[2], state, TEA5767_MONOTOSTEREO); 
.................... tea5767SendData (&tea5767_config); 
.................... }*/ 
....................  
.................... /*void tea5767MuteRight(int8 state)  //state  ON- mute OFF-no mute 
.................... { 
.................... tea5767_config[2] = nth_bit_to_x(tea5767_config[2], state, TEA5767_WRITE3_MUTERIGHT_ON); 
.................... tea5767SendData (&tea5767_config); 
.................... }*/ 
....................  
.................... /*void tea5767MuteLeft(int8 state)  //state  ON- mute OFF-no mute 
.................... { 
.................... tea5767_config[2] = nth_bit_to_x(tea5767_config[2], state, TEA5767_WRITE3_MUTELEFT_ON ); 
.................... tea5767SendData (&tea5767_config); 
.................... }*/ 
....................  
.................... /*void tea5767Scan(unsigned int32 frequency, int8 scan_mode, int8 direction) 
.................... { 
.................... /* 
.................... frequency - scan start frequency 
.................... scan_mode - On OFF 
.................... up_down 
.................... !!!!!!!!!!!!!!!! 
.................... IF STATION WAS FOUNF YOU HAVE TO SET SCAM bit to 0 
.................... !!!!!!!!!!!!!!!! 
.................... */ 
.................... //#ifdef ACTIVE_ANTENA 
.................... //   AAntenna_ON(); 
.................... //#endif 
.................... /*tea5767_config[0] = tea5767_config[0]|((tea5767CalculatePLL(frequency)>> 8) & 0x3F); 
.................... tea5767_config[1] = (tea5767CalculatePLL(frequency) & 0xFF); 
.................... tea5767_config[0] = nth_bit_to_x(tea5767_config[0], scan_mode, TEA5767_WRITE1_SEARCHMODE_ON); 
.................... tea5767_config[2] = nth_bit_to_x(tea5767_config[2], direction, TEA5767_WRITE3_SEARCHDIRECTION); 
.................... tea5767SendData (&tea5767_config); 
.................... tea5767SetBit2ScanOFF(); 
.................... }*/ 
....................  
....................  
.................... /*void tea5767SetBit2ScanOFF(void) 
.................... { 
.................... // Switch OFF SEARCHMODE bit in TEA5767 register 
....................    tea5767_config[0] = nth_bit_to_x(tea5767_config[0], OFF, TEA5767_WRITE1_SEARCHMODE_ON); 
....................    tea5767_config[2] = nth_bit_to_x(tea5767_config[2], 0, TEA5767_WRITE3_SEARCHDIRECTION); 
.................... }*/ 
....................  
.................... //BYTE tea5767StereoReception(void) 
.................... /* 
.................... RETURNS: 
.................... 0 - if mono reception 
.................... 1 - if stereo reception 
.................... */ 
.................... /*{ 
....................    tea5767ReadData(); 
....................   // printf("aaaa : %x",(tea5767_config[2]>>7)); 
....................    //return ((tea5767_config[2]>>7) == 0x1); 
....................    return ((SlaveBuffer[2]>>7) == 0x1); 
.................... }*/ 
....................  
....................  
.................... //BYTE tea5767ScanModeStatus(void) 
.................... /* 
.................... Afrer tea5767Scan this function gives information about TEA5767 scan state. 
.................... return conditions: 
.................... 00 (000000) - no station found, band limit not reached 
.................... 01 (000000) - no station found, band limit reached  
.................... 10 (000000) - station found , band limit not reached 
.................... 11 (000000) - station found , band limit reached 
.................... */ 
.................... /*{ 
....................    tea5767ReadData(); 
....................    return SlaveBuffer[0]>>6; 
.................... }*/ 
....................  
.................... /*void tea5767ReadData(void) 
.................... { 
....................   // Clear buffers 
....................   ClearBuffers(&MasterBuffer,I2C_BUFSIZE); 
....................   ClearBuffers(&SlaveBuffer,I2C_BUFSIZE); 
....................  
....................   I2CWriteLength = 1; //"1" beacause i2c after start should write adress 
....................   I2CReadLength = 5; 
....................   MasterBuffer[0] = TEA5767_ADDRESS_WRITE | TEA5767_ADDRESS_READ; 
....................   i2cEngine(FALSE); 
....................    
....................   //put PLL to current config tea5767 config 
....................   tea5767_config[0] = (SlaveBuffer[0] & 0x3F)|tea5767_config[0]; 
....................   tea5767_config[1] = (SlaveBuffer[1] & 0xFF); 
.................... }*/ 
....................  
....................  
.................... #include </HW_drivers/au7860_mp3/au7860_mp3.c> 
.................... #include </au7860_mp3.h> 
.................... #ifndef __au7860_mp3__  
....................    #define  __au7860_mp3__ 
....................     
....................    #define  au_header                           0x55AA 
....................     
....................    #define  au_address_len                      0x2 
....................    #define  au_address_command                  0x3 
....................    #define  au_address_data                     0x5 
....................    //check sum addres is au_address_data + data_len 
....................     
....................    #define  au_command_Mode_Next                0x0101 
....................    #define  au_command_Mode_Select              0x0102 
....................    #define  au_command_Mode_Get                 0x0103 
....................    #define  au_command_Mode_Get_device_link     0x0104 
....................     
....................    #define  au_command_Mode_Next_len            0x0 
....................    #define  au_command_Mode_Select_len          0x1 
....................    #define  au_command_Mode_Get_len             0x0 
....................    #define  au_command_Mode_Get_device_link_len 0x0   
....................     
....................    #define  au_command_FS_GetFolderSum          0x0201 
....................    #define  au_command_FS_GetFileSum            0x0202 
....................    #define  au_command_FS_GetFolderInfo         0x0203 
....................    #define  au_command_FS_GetFileInfo           0x0204 
....................     
....................    #define  au_command_FS_GetFolderSum_len      0x0       
....................    #define  au_command_FS_GetFileSum_len        0x0 
....................    #define  au_command_FS_GetFolderInfo_len     0x4 
....................    #define  au_command_FS_GetFileInfo_len       0x4  
....................     
....................    #define  au_command_Play_Play                0x0301 
....................    #define  au_command_Play_Pause               0x0302 
....................    #define  au_command_Play_Stop                0x0303 
....................    #define  au_command_Play_Next                0x0304 
....................    #define  au_command_Play_Pre                 0x0305 
....................    #define  au_command_Play_PlayPause           0x0306 
....................    #define  au_command_Play_FF                  0x0307 
....................    #define  au_command_Play_FB                  0x0308 
....................    #define  au_command_Play_StopFFFB            0x0309 
....................    #define  au_command_Play_SeekPlayTime        0x030A 
....................    #define  au_command_Play_NextFolder          0x030B 
....................    #define  au_command_Play_PreFolder           0x030C 
....................    #define  au_command_Play_SelectSong          0x030D 
....................    #define  au_command_Play_GetPlayStatus       0x0320 
....................    #define  au_command_Play_GetSongInfo         0x0321 
....................    #define  au_command_Play_SetRepeatMode       0x0322 
....................    #define  au_command_Play_GetRepeatMode       0x0323 
....................    #define  au_command_Play_EnableFolder        0x0324 
....................    #define  au_command_Play_DisableFolder       0x0325 
....................    #define  au_command_Play_GetTitle            0x0330 
....................    #define  au_command_Play_GetArtist           0x0331 
....................    #define  au_command_Play_GetAlbum            0x0332 
....................    #define  au_command_Play_GetComment          0x0333 
....................    #define  au_command_Play_GetYear             0x0334 
....................     
....................    #define  au_command_Play_Play_len            0x0 
....................    #define  au_command_Play_Pause_len           0x0 
....................    #define  au_command_Play_Stop_len            0x0 
....................    #define  au_command_Play_Next_len            0x0 
....................    #define  au_command_Play_Pre_len             0x0 
....................    #define  au_command_Play_PlayPause_len       0x0 
....................    #define  au_command_Play_FF_len              0x0 
....................    #define  au_command_Play_FB_len              0x0 
....................    #define  au_command_Play_StopFFFB_len        0x0 
....................    #define  au_command_Play_SeekPlayTime_len    0x4 
....................    #define  au_command_Play_NextFolder_len      0x0 
....................    #define  au_command_Play_PreFolder_len       0x0 
....................    #define  au_command_Play_SelectSong_len      0x4 
....................    #define  au_command_Play_GetPlayStatus_len   0x0 
....................    #define  au_command_Play_GetSongInfo_len     0x0 
....................    #define  au_command_Play_SetRepeatMode_len   0x1 
....................    #define  au_command_Play_GetRepeatMode_len   0x0 
....................    #define  au_command_Play_EnableFolder_len    0x0 
....................    #define  au_command_Play_DisableFolder_len   0x0 
....................    #define  au_command_Play_GetTitle_len        0x0 
....................    #define  au_command_Play_GetArtist_len       0x0 
....................    #define  au_command_Play_GetAlbum_len        0x0 
....................    #define  au_command_Play_GetComment_len      0x0 
....................    #define  au_command_Play_GetYear_len         0x0 
....................     
....................    #define  au_command_Audio_VolPlus            0x0401 
....................    #define  au_command_Audio_VolMinus           0x0402 
....................    #define  au_command_Audio_VolSet             0x0403 
....................    #define  au_command_Audio_VolGet             0x0404 
....................    #define  au_command_Audio_EqSet              0x0405 
....................    #define  au_command_Audio_EqGet              0x0406 
....................    #define  au_command_Audio_Mute               0x0407 
....................    #define  au_command_Audio_UnMute             0x0408 
....................    #define  au_command_Audio_SetLineInGain      0x0409 
....................    #define  au_command_Audio_EnableMic          0x040A 
....................    #define  au_command_Audio_DisableMic         0x040B 
....................     
....................    #define  au_command_Audio_VolPlus_len        0x0 
....................    #define  au_command_Audio_VolMinus_len       0x0 
....................    #define  au_command_Audio_VolSet_len         0x1 
....................    #define  au_command_Audio_VolGet_len         0x0 
....................    #define  au_command_Audio_EqSet_len          0x1 
....................    #define  au_command_Audio_EqGet_len          0x0 
....................    #define  au_command_Audio_Mute_len           0x0 
....................    #define  au_command_Audio_UnMute_len         0x0 
....................    #define  au_command_Audio_SetLineInGain_len  0x1 
....................    #define  au_command_Audio_EnableMic_len      0x1 
....................    #define  au_command_Audio_DisableMic_len     0x0 
....................  
....................    #define  au_cmd_val_ModeID_Idle              0x0 
....................    #define  au_cmd_val_ModeID_USB               0x1 
....................    #define  au_cmd_val_ModeID_SD                0x2 
....................    #define  au_cmd_val_ModeID_AuxIn             0x3 
....................    #define  au_cmd_val_ModeID_USBAudio          0x4 
....................  
....................    #define  au_cmd_rep_Linked_USB               0b00000001 
....................    #define  au_cmd_rep_Linked_SD                0b00000010 
....................    #define  au_cmd_rep_Linked_AuxIn             0b00000100 
....................    #define  au_cmd_rep_Linked_PC                0b00001000 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... //volatile unsigned int8  tea5767_config[5]={0,0,0,0,0}; 
....................  
.................... //extern volatile unsigned int8  tea5767_config[5]; 
.................... //extern volatile int1 TEA5767_last_i2c_action_WRITE; 
....................  
.................... #include </HW_drivers/TDA7418/TDA7418.c> 
.................... /**************************************************************************/ 
.................... /*!  
....................     @file     TDA7418.c 
....................     @author   D. Bankowski (d.bankowski@gmail.com) 
....................      
....................     @brief    Driver for the TDA7418 3 band car audio processor. 
....................     @section LICENSE 
....................     Software License Agreement (BSD License) 
....................     Copyright (c) 2017, D. Bankowski 
....................     All rights reserved. 
....................     Redistribution and use in source and binary forms, with or without 
....................     modification, are permitted provided that the following conditions are met: 
....................     1. Redistributions of source code must retain the above copyright 
....................     notice, this list of conditions and the following disclaimer. 
....................     2. Redistributions in binary form must reproduce the above copyright 
....................     notice, this list of conditions and the following disclaimer in the 
....................     documentation and/or other materials provided with the distribution. 
....................     3. Neither the name of the copyright holders nor the 
....................     names of its contributors may be used to endorse or promote products 
....................     derived from this software without specific prior written permission. 
....................     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY 
....................     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY 
....................     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
.................... */ 
.................... /**************************************************************************/ 
....................  
.................... #include </TDA7418.h> 
.................... /**************************************************************************/ 
.................... /*!  
....................     @file     TDA7418.h 
....................     @author   D. Bankowski (d.bankowski@gmail.com) 
....................      
....................     @brief    Driver for the TDA7418 3 band car audio processor. 
....................     @section LICENSE 
....................     Software License Agreement (BSD License) 
....................     Copyright (c) 2017, D. Bankowski 
....................     All rights reserved. 
....................     Redistribution and use in source and binary forms, with or without 
....................     modification, are permitted provided that the following conditions are met: 
....................     1. Redistributions of source code must retain the above copyright 
....................     notice, this list of conditions and the following disclaimer. 
....................     2. Redistributions in binary form must reproduce the above copyright 
....................     notice, this list of conditions and the following disclaimer in the 
....................     documentation and/or other materials provided with the distribution. 
....................     3. Neither the name of the copyright holders nor the 
....................     names of its contributors may be used to endorse or promote products 
....................     derived from this software without specific prior written permission. 
....................     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY 
....................     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY 
....................     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
.................... */ 
.................... /**************************************************************************/ 
....................  
.................... #ifndef _TDA7418_ 
....................    #define _TDA7418_ 
....................     
....................    /*========================================================================= 
....................        I2C ADDRESS/BITS 
....................        -----------------------------------------------------------------------*/ 
....................    #define TDA7418_ADDRESS_Write                      (0x88)  // 1 0 0 0 1 0 0 R/W    
....................                                                         // R/W  = 1 write addres  
....................                                                         // R/W  = 0 read addres                                                       
....................    #define TDA7418_ADDRESS_Read                       (0x89) 
....................    /*=========================================================================*/  
....................  
....................    /*========================================================================= 
....................    TDA7418 - Subaddress (receive mode) 
....................        -----------------------------------------------------------------------*/ 
....................         
....................    #define TDA7418_SubAddr_Testing_Mode_ON         0b10000000 
....................    #define TDA7418_SubAddr_Testing_Mode_OFF        0b00000000 
....................    #define TDA7418_SubAddr_Auto_Zero_Remain_ON     0b01000000 
....................    #define TDA7418_SubAddr_Auto_Zero_Remain_OFF    0b00000000 
....................    #define TDA7418_SubAddr_Auto_Increment_Mode_ON  0b00100000 
....................    #define TDA7418_SubAddr_Auto_Increment_Mode_OFF 0b00000000 
....................    #define TDA7418_SubAddr_Src                     0x0   //Main Source Selector 
....................    #define TDA7418_SubAddr_Loud                    0x01  //Loudness 
....................    #define TDA7418_SubAddr_Vol                     0x02  //Volume 
....................    #define TDA7418_SubAddr_Tre                     0x03  //Treble 
....................    #define TDA7418_SubAddr_Mid                     0x04  //Middle 
....................    #define TDA7418_SubAddr_Bas                     0x05  //Bass 
....................    #define TDA7418_SubAddr_FC                      0x06  //Middle/Bass Fc Selector 
....................    #define TDA7418_SubAddr_LF                      0x07  //Speaker Attenuator Left Front 
....................    #define TDA7418_SubAddr_LR                      0x08  //Speaker Attenuator Left Right 
....................    #define TDA7418_SubAddr_RR                      0x09  //Speaker Attenuator Right Rear 
....................    #define TDA7418_SubAddr_RF                      0x0A  //Speaker Attenuator Right Front 
....................    #define TDA7418_SubAddr_SW                      0x0B  //Subwoofer Attenuator  
....................    #define TDA7418_SubAddr_Soft_Mute               0x0C  //Soft Mute / Soft Step 
....................    #define TDA7418_SubAddr_Test_Processor          0x0D  //Testing Audio Processor 
....................    /*=========================================================================*/       
....................     
....................    /*========================================================================= 
....................    TDA7418 - Input selector /gain (0) - TDA7418_SubAddr_Src 
....................        -----------------------------------------------------------------------*/ 
....................    /* bits 2 to 0 */ 
....................     
....................    #define TDA7418_INPUT_PD_SE4                    0x00  //Source Selector PD/SE4 
....................    #define TDA7418_INPUT_SE1                       0x01  //Source Selector SE1 
....................    #define TDA7418_INPUT_SE2                       0x02  //Source Selector SE2 
....................    #define TDA7418_INPUT_SE3                       0x03  //Source Selector SE3 
....................    #define TDA7418_INPUT_MUTE                      0x04  //Source Selector SE3 
....................    /* bits 2 to 0 */ 
....................     
....................    /* bits 6 to 3 */ 
....................    #define TDA7418_INPUT_GAIN_0dB                  (0x0<<3)   //Input Gain 0dB 
....................    #define TDA7418_INPUT_GAIN_1dB                  (0x1<<3)   //Input Gain 1dB    
....................    #define TDA7418_INPUT_GAIN_2dB                  (0x2<<3)   //Input Gain 2dB 
....................    #define TDA7418_INPUT_GAIN_3dB                  (0x3<<3)   //Input Gain 3dB   
....................    #define TDA7418_INPUT_GAIN_4dB                  (0x4<<3)   //Input Gain 4dB  
....................    #define TDA7418_INPUT_GAIN_5dB                  (0x5<<3)   //Input Gain 5dB  
....................    #define TDA7418_INPUT_GAIN_6dB                  (0x6<<3)   //Input Gain 6dB             
....................    #define TDA7418_INPUT_GAIN_7dB                  (0x7<<3)   //Input Gain 7dB 
....................    #define TDA7418_INPUT_GAIN_8dB                  (0x8<<3)   //Input Gain 8dB 
....................    #define TDA7418_INPUT_GAIN_9dB                  (0x9<<3)   //Input Gain 9dB  
....................    #define TDA7418_INPUT_GAIN_10dB                 (0xA<<3)   //Input Gain 10dB  
....................    #define TDA7418_INPUT_GAIN_11dB                 (0xB<<3)   //Input Gain 11dB  
....................    #define TDA7418_INPUT_GAIN_12dB                 (0xC<<3)   //Input Gain 12dB  
....................    #define TDA7418_INPUT_GAIN_13dB                 (0xD<<3)   //Input Gain 13dB  
....................    #define TDA7418_INPUT_GAIN_14dB                 (0xE<<3)   //Input Gain 14dB  
....................    #define TDA7418_INPUT_GAIN_15dB                 (0xF<<3)   //Input Gain 15dB  
....................    /* bits 6 to 3 */    
....................     
....................    /* bits 7 */    
....................    #define TDA7418_DIFFIN_MODE_SINGLE              (0<<7)   //Single Ended Stereo 
....................    #define TDA7418_DIFFIN_MODE_DIFFERENTIAL        (1<<7)   //Differential Stereo 
....................    /* bits 7 */    
....................    /*=========================================================================*/ 
....................     
....................    /*========================================================================= 
....................    TDA7418 - Loudness (1) - TDA7418_SubAddr_Loud 
....................        -----------------------------------------------------------------------*/ 
....................    /* bits 3 to 0 */  
....................    #define TDA7418_ATTENUATION_0dB           (0x0)   //Input Gain 0dB 
....................    #define TDA7418_ATTENUATION_1dB           (0x1)   //Input Gain -1dB    
....................    #define TDA7418_ATTENUATION_2dB           (0x2)   //Input Gain -2dB 
....................    #define TDA7418_ATTENUATION_3dB           (0x3)   //Input Gain -3dB   
....................    #define TDA7418_ATTENUATION_4dB           (0x4)   //Input Gain -4dB  
....................    #define TDA7418_ATTENUATION_5dB           (0x5)   //Input Gain -5dB  
....................    #define TDA7418_ATTENUATION_6dB           (0x6)   //Input Gain -6dB             
....................    #define TDA7418_ATTENUATION_7dB           (0x7)   //Input Gain -7dB 
....................    #define TDA7418_ATTENUATION_8dB           (0x8)   //Input Gain -8dB 
....................    #define TDA7418_ATTENUATION_9dB           (0x9)   //Input Gain -9dB  
....................    #define TDA7418_ATTENUATION_10dB          (0xA)   //Input Gain -10dB  
....................    #define TDA7418_ATTENUATION_11dB          (0xB)   //Input Gain -11dB  
....................    #define TDA7418_ATTENUATION_12dB          (0xC)   //Input Gain -12dB  
....................    #define TDA7418_ATTENUATION_13dB          (0xD)   //Input Gain -13dB  
....................    #define TDA7418_ATTENUATION_14dB          (0xE)   //Input Gain -14dB  
....................    #define TDA7418_ATTENUATION_15dB          (0xF)   //Input Gain -15dB     
....................    /* bits 3 to 0 */     
....................  
....................    /* bits 5 to 4 */ 
....................    //#define TDA7418_CENTER_FREQ_OFF           //choose on of thise 
....................    #define TDA7418_CENTER_FREQ_400           //choose on of thise 
....................    //#define TDA7418_CENTER_FREQ_800           //choose on of thise 
....................    //#define TDA7418_CENTER_FREQ_2400          //choose on of thise 
....................  
....................    #ifdef   TDA7418_CENTER_FREQ_OFF 
....................       #define  TDA7418_CENTER_FREQ           0b00000000 //Filter/Center Frequency OFF 
....................    #endif 
....................     
....................    #ifdef   TDA7418_CENTER_FREQ_400 
....................       #define  TDA7418_CENTER_FREQ           0b00010000   //Filter/Center Frequency 400Hz 
....................    #endif    
....................  
....................     #ifdef   TDA7418_CENTER_FREQ_800 
....................       #define  TDA7418_CENTER_FREQ           0b00100000   //Filter/Center Frequency 800Hz 
....................    #endif 
....................     
....................    #ifdef   TDA7418_CENTER_FREQ_2400 
....................       #define  TDA7418_CENTER_FREQ           0b00110000   //Filter/Center Frequency 2400Hz 
....................    #endif 
....................     
....................    /* bits 5 to 4 */ 
....................     
....................    /* bits 6 */    
....................    #define TDA7418_SHAPE_LOW_BOOST           0b0000000   //Shape Low Boost 
....................    #define TDA7418_SHAPE_LOW_HIGH_BOOST      0b0100000   //Shape Low Boost & HighBoost 
....................    /* bits 6 */      
....................     
....................    /* bits 7 */     
....................    #define TDA7418_LOUDNESS_SOFT_STEF_ON     0b00000000  //Loudness Soft Step ON 
....................    #define TDA7418_LOUDNESS_SOFT_STEF_OFF    0b10000000  //Loudness Soft Step OFF 
....................    /* bits 7 */        
....................    /*=========================================================================*/    
....................  
....................  
....................    /*========================================================================= 
....................    TDA7418 - Volume / speaker attenuation (2,7,8,9,10,11) - TDA7418_SubAddr_Vol, 
....................             TDA7418_SubAddr_LF, TDA7418_SubAddr_LR, TDA7418_SubAddr_RR, 
....................             TDA7418_SubAddr_RF, TDA7418_SubAddr_SW 
....................        -----------------------------------------------------------------------*/ 
....................    /* bits 6 to 0 */  
....................    // see const int8 AUDIO_volume_attenuation[41] - in TDA7418.c 
....................    /* bits 6 to 0 */  
....................  
....................    /* bits 7 */ 
....................     
....................    #define TDA7418_VOLUME_SOFT_STEP_ON          // use one of TDA7418_VOLUME_SOFT_STEP_ON or TDA7418_VOLUME_SOFT_STEP_OFF  
....................    //#define TDA7418_VOLUME_SOFT_STEP_OFF       // use one of TDA7418_VOLUME_SOFT_STEP_ON or TDA7418_VOLUME_SOFT_STEP_OFF  
....................     
....................    #ifdef TDA7418_VOLUME_SOFT_STEP_ON         
....................       #define TDA7418_VOLUME_SOFT_STEP          0b00000000 
....................    #endif 
....................     
....................    #ifdef TDA7418_VOLUME_SOFT_STEP_OFF 
....................       #define TDA7418_VOLUME_SOFT_STEP          0b10000000 
....................    #endif 
....................    /* bits 7 */  
....................     /*=========================================================================*/  
....................  
....................    /*========================================================================= 
....................    TDA7418 - Treble filter (3) - TDA7418_SubAddr_Tre 
....................        -----------------------------------------------------------------------*/ 
....................    /* bits 4 to 0 */  
....................    // see const int8 AUDIO_Treble_Middle_Bass[31]  - in TDA7418.c 
....................    /* bits 4 to 0 */  
....................     
....................    /* bits 6 to 5*/  
....................     
....................    //#define  TDA7418_TREBLE_CENTRAL_FREQUENCY_10_0kHz        // use one of TDA7418_TREBLE_CENTRAL_FREQUENCY_10_0kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_12_5kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_15_0kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_17_5kHz 
....................    #define   TDA7418_TREBLE_CENTRAL_FREQUENCY_12_5kHz     // use one of TDA7418_TREBLE_CENTRAL_FREQUENCY_10_0kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_12_5kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_15_0kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_17_5kHz 
....................    //#define   TDA7418_TREBLE_CENTRAL_FREQUENCY_15_0kHz     // use one of TDA7418_TREBLE_CENTRAL_FREQUENCY_10_0kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_12_5kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_15_0kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_17_5kHz 
....................    //#define   TDA7418_TREBLE_CENTRAL_FREQUENCY_17_5kHz     // use one of TDA7418_TREBLE_CENTRAL_FREQUENCY_10_0kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_12_5kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_15_0kHz or TDA7418_TREBLE_CENTRAL_FREQUENCY_17_5kHz 
....................        
....................    #ifdef   TDA7418_TREBLE_CENTRAL_FREQUENCY_10_0kHz 
....................       #define  TDA7418_TREBLE_CENTRAL_FREQUENCY          0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_TREBLE_CENTRAL_FREQUENCY_12_5kHz 
....................       #define  TDA7418_TREBLE_CENTRAL_FREQUENCY          0b00100000 
....................    #endif 
....................    #ifdef   TDA7418_TREBLE_CENTRAL_FREQUENCY_15_0kHz 
....................       #define  TDA7418_TREBLE_CENTRAL_FREQUENCY          0b01000000 
....................    #endif 
....................    #ifdef   TDA7418_TREBLE_CENTRAL_FREQUENCY_17_5kHz 
....................       #define  TDA7418_TREBLE_CENTRAL_FREQUENCY          0b01100000 
....................    #endif  
....................    /* bits 6 to 5*/  
....................        
....................    /* bits 7*/  
....................    #define  TDA7418_TREBLE_BIT7                       0b10000000     //must "be" 1 
....................    /* bits 7*/ 
....................    /*=========================================================================*/ 
....................      
....................    /*========================================================================= 
....................    TDA7418 - Middle filter (4) - TDA7418_SubAddr_Mid 
....................        -----------------------------------------------------------------------*/ 
....................    /* bits 4 to 0 */  
....................    // see const int8 AUDIO_Treble_Middle_Bass[31]  - in TDA7418.c 
....................    /* bits 4 to 0 */  
....................     
....................    /* bits 6 to 5*/  
....................    //#define   TDA7418_MIDDLE_Q_FACTOR_0_5               // use one of TDA7418_MIDDLE_Q_FACTOR_0_5 or TDA7418_MIDDLE_Q_FACTOR_0_75 or TDA7418_MIDDLE_Q_FACTOR_1 or TDA7418_MIDDLE_Q_FACTOR_1_25 
....................    //#define   TDA7418_MIDDLE_Q_FACTOR_0_75              // use one of TDA7418_MIDDLE_Q_FACTOR_0_5 or TDA7418_MIDDLE_Q_FACTOR_0_75 or TDA7418_MIDDLE_Q_FACTOR_1 or TDA7418_MIDDLE_Q_FACTOR_1_25 
....................    #define   TDA7418_MIDDLE_Q_FACTOR_1                   // use one of TDA7418_MIDDLE_Q_FACTOR_0_5 or TDA7418_MIDDLE_Q_FACTOR_0_75 or TDA7418_MIDDLE_Q_FACTOR_1 or TDA7418_MIDDLE_Q_FACTOR_1_25 
....................    //#define   TDA7418_MIDDLE_Q_FACTOR_1_25              // use one of TDA7418_MIDDLE_Q_FACTOR_0_5 or TDA7418_MIDDLE_Q_FACTOR_0_75 or TDA7418_MIDDLE_Q_FACTOR_1 or TDA7418_MIDDLE_Q_FACTOR_1_25 
....................     
....................    #ifdef   TDA7418_MIDDLE_Q_FACTOR_0_5 
....................       #define TDA7418_MIDDLE_Q_FACTOR         0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_MIDDLE_Q_FACTOR_0_75 
....................       #define TDA7418_MIDDLE_Q_FACTOR         0b0100000 
....................    #endif 
....................    #ifdef   TDA7418_MIDDLE_Q_FACTOR_1 
....................       #define TDA7418_MIDDLE_Q_FACTOR         0b01000000 
....................    #endif 
....................    #ifdef   TDA7418_MIDDLE_Q_FACTOR_1_25 
....................       #define TDA7418_MIDDLE_Q_FACTOR         0b01100000 
....................    #endif 
....................    /* bits 6 to 5*/  
....................  
....................    /* bits 7*/ 
....................    #define TDA7418_MIDDLE_SOFT_STEP_OFF               // use one of TDA7418_MIDDLE_SOFT_STEP_OFF or TDA7418_MIDDLE_SOFT_STEP_ON 
....................    //#define TDA7418_MIDDLE_SOFT_STEP_ON 
....................     
....................    #ifdef   TDA7418_MIDDLE_SOFT_STEP_ON 
....................       #define TDA7418_MIDDLE_SOFT_STEP       0b00000000 
....................    #endif 
....................     
....................    #ifdef   TDA7418_MIDDLE_SOFT_STEP_OFF  
....................       #define TDA7418_MIDDLE_SOFT_STEP       0b10000000 
....................    #endif 
....................    /* bits 7*/ 
....................    /*=========================================================================*/    
....................  
....................    /*========================================================================= 
....................    TDA7418 - Middle / bass Fc select (6) - TDA7418_SubAddr_Bas 
....................        -----------------------------------------------------------------------*/ 
....................    /* bits 4 to 0 */  
....................    // see const int8 AUDIO_Treble_Middle_Bass[31]  - in TDA7418.c 
....................    /* bits 4 to 0 */  
....................     
....................    /* bits 6 to 5*/ 
....................    #define   TDA7418_BASS_Q_FACTOR_1_0          // use one of TDA7418_Bass_Q_FACTOR_1_0  or TDA7418_Bass_Q_FACTOR_1_25 or DA7418_Bass_Q_FACTOR_1_5 or TDA7418_Bass_Q_FACTOR_2_0 
....................    //#define   TDA7418_BASS_Q_FACTOR_1_25         // use one of TDA7418_Bass_Q_FACTOR_1_0  or TDA7418_Bass_Q_FACTOR_1_25 or DA7418_Bass_Q_FACTOR_1_5 or TDA7418_Bass_Q_FACTOR_2_0 
....................    //#define   TDA7418_BASS_Q_FACTOR_1_5          // use one of TDA7418_Bass_Q_FACTOR_1_0  or TDA7418_Bass_Q_FACTOR_1_25 or DA7418_Bass_Q_FACTOR_1_5 or TDA7418_Bass_Q_FACTOR_2_0 
....................    //#define   TDA7418_BASS_Q_FACTOR_2_0          // use one of TDA7418_Bass_Q_FACTOR_1_0  or TDA7418_Bass_Q_FACTOR_1_25 or DA7418_Bass_Q_FACTOR_1_5 or TDA7418_Bass_Q_FACTOR_2_0 
....................     
....................    #ifdef   TDA7418_BASS_Q_FACTOR_1_0 
....................       #define TDA7418_BASS_Q_FACTOR       0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_BASS_Q_FACTOR_1_25 
....................       #define TDA7418_BASS_Q_FACTOR       0b00100000 
....................    #endif    
....................     #ifdef  TDA7418_Bass_Q_FACTOR_1_5 
....................       #define TDA7418_BASS_Q_FACTOR       0b01000000 
....................    #endif   
....................     #ifdef  TDA7418_BASS_Q_FACTOR_2_0 
....................       #define TDA7418_BASS_Q_FACTOR       0b01100000 
....................    #endif    
....................    /* bits 6 to 5*/ 
....................  
....................    /* bits 7*/ 
....................    #define TDA7418_BASS_SOFT_STEP_OFF        // use one of TDA7418_BASS_SOFT_STEP_OFF or TDA7418_BASS_SOFT_STEP_ON 
....................    //#define TDA7418_BASS_SOFT_STEP_ON 
....................    #ifdef   TDA7418_BASS_SOFT_STEP_OFF 
....................       #define  TDA7418_BASS_SOFT_STEP    0b10000000 
....................    #endif 
....................    #ifdef   TDA7418_BASS_SOFT_STEP_ON 
....................       #define  TDA7418_BASS_SOFT_STEP    0b00000000 
....................    #endif 
....................    /* bits 7*/ 
....................    /*=========================================================================*/  
....................  
....................    /*========================================================================= 
....................    TDA7418 - Bass filter (5) - TDA7418_SubAddr_FC 
....................        -----------------------------------------------------------------------*/ 
....................    /* bits 1 to 0 */  
....................    //#define TDA7418_MIDDLE_CENTER_FREQUENCY_500Hz      // use one of TDA7418_MIDDLE_CENTER_FREQUENCY_500Hz  or TDA7418_MIDDLE_CENTER_FREQUENCY_1kHz or TDA7418_MIDDLE_CENTER_FREQUENCY_1_5kHz or TDA7418_MIDDLE_CENTER_FREQUENCY_2_5kHz 
....................    //#define TDA7418_MIDDLE_CENTER_FREQUENCY_1kHz      // use one of TDA7418_MIDDLE_CENTER_FREQUENCY_500Hz  or TDA7418_MIDDLE_CENTER_FREQUENCY_1kHz or TDA7418_MIDDLE_CENTER_FREQUENCY_1_5kHz or TDA7418_MIDDLE_CENTER_FREQUENCY_2_5kHz 
....................    #define TDA7418_MIDDLE_CENTER_FREQUENCY_1_5kHz    // use one of TDA7418_MIDDLE_CENTER_FREQUENCY_500Hz  or TDA7418_MIDDLE_CENTER_FREQUENCY_1kHz or TDA7418_MIDDLE_CENTER_FREQUENCY_1_5kHz or TDA7418_MIDDLE_CENTER_FREQUENCY_2_5kHz 
....................    //#define TDA7418_MIDDLE_CENTER_FREQUENCY_2_5kHz    // use one of TDA7418_MIDDLE_CENTER_FREQUENCY_500Hz  or TDA7418_MIDDLE_CENTER_FREQUENCY_1kHz or TDA7418_MIDDLE_CENTER_FREQUENCY_1_5kHz or TDA7418_MIDDLE_CENTER_FREQUENCY_2_5kHz 
....................     
....................    #ifdef   TDA7418_MIDDLE_CENTER_FREQUENCY_500Hz 
....................       #define  TDA7418_MIDDLE_CENTER_FREQUENCY     0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_MIDDLE_CENTER_FREQUENCY_1kHz 
....................       #define  TDA7418_MIDDLE_CENTER_FREQUENCY     0b00000001 
....................    #endif 
....................    #ifdef   TDA7418_MIDDLE_CENTER_FREQUENCY_1_5kHz 
....................       #define  TDA7418_MIDDLE_CENTER_FREQUENCY     0b00000010 
....................    #endif 
....................    #ifdef   TDA7418_MIDDLE_CENTER_FREQUENCY_2_5kHz 
....................       #define  TDA7418_MIDDLE_CENTER_FREQUENCY     0b00000011 
....................    #endif 
....................    /* bits 1 to 0 */  
....................     
....................    /* bits 3 to 2 */  
....................    //#define TDA7418_BASS_CENTER_FREQUENCY_60Hz      // use one of TDA7418_BASS_CENTER_FREQUENCY_60Hz or TDA7418_BASS_CENTER_FREQUENCY_80Hz or TDA7418_BASS_CENTER_FREQUENCY_100Hz or TDA7418_BASS_CENTER_FREQUENCY_200Hz 
....................    //#define TDA7418_BASS_CENTER_FREQUENCY_80Hz      // use one of TDA7418_BASS_CENTER_FREQUENCY_60Hz or TDA7418_BASS_CENTER_FREQUENCY_80Hz or TDA7418_BASS_CENTER_FREQUENCY_100Hz or TDA7418_BASS_CENTER_FREQUENCY_200Hz 
....................    //#define TDA7418_BASS_CENTER_FREQUENCY_100Hz     // use one of TDA7418_BASS_CENTER_FREQUENCY_60Hz or TDA7418_BASS_CENTER_FREQUENCY_80Hz or TDA7418_BASS_CENTER_FREQUENCY_100Hz or TDA7418_BASS_CENTER_FREQUENCY_200Hz 
....................    #define TDA7418_BASS_CENTER_FREQUENCY_200Hz     // use one of TDA7418_BASS_CENTER_FREQUENCY_60Hz or TDA7418_BASS_CENTER_FREQUENCY_80Hz or TDA7418_BASS_CENTER_FREQUENCY_100Hz or TDA7418_BASS_CENTER_FREQUENCY_200Hz 
....................  
....................    #ifdef   TDA7418_BASS_CENTER_FREQUENCY_60Hz 
....................       #define  TDA7418_BASS_CENTER_FREQUENCY    0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_BASS_CENTER_FREQUENCY_80Hz 
....................       #define  TDA7418_BASS_CENTER_FREQUENCY    0b00000100 
....................    #endif 
....................    #ifdef   TDA7418_BASS_CENTER_FREQUENCY_100Hz 
....................       #define  TDA7418_BASS_CENTER_FREQUENCY    0b00001000 
....................    #endif 
....................    #ifdef   TDA7418_BASS_CENTER_FREQUENCY_200Hz 
....................       #define  TDA7418_BASS_CENTER_FREQUENCY    0b00001100 
....................    #endif    
....................    /* bits 3 to 2 */  
....................  
....................    /* bits 4 to 4 */ 
....................    #define TDA7418_BASS_DC_MODE_OFF                       // use one of TDA7418_BASS_DC_MODE_OFF or TDA7418_BASS_DC_MODE_ON 
....................    //#define TDA7418_BASS_DC_MODE_ON                        // use one of TDA7418_BASS_DC_MODE_OFF or TDA7418_BASS_DC_MODE_ON 
....................     
....................    #ifdef   TDA7418_BASS_DC_MODE_OFF 
....................       #define  TDA7418_BASS_DC_MODE             0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_BASS_DC_MODE_ON 
....................       #define  TDA7418_BASS_DC_MODE             0b00010000 
....................    #endif    
....................    /* bits 4 to 4 */ 
....................        
....................    /* bits 5 to 5 */   
....................    #define TDA7418_SMOOTHING_FILTER_OFF               // use one of TDA7418_SMOOTHING_FILTER_OFF or TDA7418_SMOOTHING_FILTER_ON 
....................    //#define TDA7418_SMOOTHING_FILTER_ON                // use one of TDA7418_SMOOTHING_FILTER_OFF or TDA7418_SMOOTHING_FILTER_ON 
....................     
....................    #ifdef   TDA7418_SMOOTHING_FILTER_OFF 
....................       #define  TDA7418_SMOOTHING_FILTER         0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_SMOOTHING_FILTER_ON 
....................       #define  TDA7418_SMOOTHING_FILTER         0b00100000 
....................    #endif    
....................    /* bits 5 to 5 */      
....................     
....................    /* bits 7 to 6 */ 
....................    // any value is possible bits not used 
....................    /* bits 7 to 6 */       
....................    /*=========================================================================*/     
....................     
....................    /*========================================================================= 
....................    TDA7418 - Soft mute and soft step time (12) - TDA7418_SubAddr_Soft_Mute 
....................        -----------------------------------------------------------------------*/    
....................    /* bits 0 to 0 */ 
....................    //#define TDA7418_SOFT_MUTE_OFF                      // use one of TDA7418_SOFT_MUTE_OFF or TDA7418_SOFT_MUTE_ON 
....................    #define TDA7418_SOFT_MUTE_ON                       // use one of TDA7418_SOFT_MUTE_OFF or TDA7418_SOFT_MUTE_ON   
....................     
....................    #ifdef   TDA7418_SOFT_MUTE_OFF  
....................       #define  TDA7418_SOFT_MUTE                0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_SOFT_MUTE_ON  
....................       #define  TDA7418_SOFT_MUTE                0b00000001 
....................    #endif    
....................    /* bits 0 to 0 */ 
....................     
....................    /* bits 2 to 1 */    
....................    //#define TDA7418_SOFT_MUTE_TIME_0_48ms            // use one of TDA7418_SOFT_MUTE_TIME_0_48ms or TDA7418_SOFT_MUTE_TIME_0_96ms or TDA7418_SOFT_MUTE_TIME_123ms 
....................    //#define TDA7418_SOFT_MUTE_TIME_0_96ms            // use one of TDA7418_SOFT_MUTE_TIME_0_48ms or TDA7418_SOFT_MUTE_TIME_0_96ms or TDA7418_SOFT_MUTE_TIME_123ms 
....................    #define TDA7418_SOFT_MUTE_TIME_123ms             // use one of TDA7418_SOFT_MUTE_TIME_0_48ms or TDA7418_SOFT_MUTE_TIME_0_96ms or TDA7418_SOFT_MUTE_TIME_123ms 
....................     
....................    #ifdef   TDA7418_SOFT_MUTE_TIME_0_48ms 
....................       #define  TDA7418_SOFT_MUTE_TIME           0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_SOFT_MUTE_TIME_0_96ms 
....................       #define  TDA7418_SOFT_MUTE_TIME           0b00000010 
....................    #endif    
....................    #ifdef   TDA7418_SOFT_MUTE_TIME_123ms 
....................       #define  TDA7418_SOFT_MUTE_TIME           0b00000100 
....................    #endif   
....................    /* bits 2 to 1 */    
....................     
....................    /* bits 5 to 3 */     
....................    //#define  TDA7418_SOFT_STEP_TIME_0_16ms           // use one of TDA7418_SOFT_STEP_TIME_0_16ms or TDA7418_SOFT_STEP_TIME_0_32ms  ... TDA7418_SOFT_STEP_TIME_10_24ms or TDA7418_SOFT_STEP_TIME_20_48ms 
....................    #define  TDA7418_SOFT_STEP_TIME_0_32ms           // use one of TDA7418_SOFT_STEP_TIME_0_16ms or TDA7418_SOFT_STEP_TIME_0_32ms  ... TDA7418_SOFT_STEP_TIME_10_24ms or TDA7418_SOFT_STEP_TIME_20_48ms 
....................    //#define  TDA7418_SOFT_STEP_TIME_0_64ms           // use one of TDA7418_SOFT_STEP_TIME_0_16ms or TDA7418_SOFT_STEP_TIME_0_32ms  ... TDA7418_SOFT_STEP_TIME_10_24ms or TDA7418_SOFT_STEP_TIME_20_48ms 
....................    //#define  TDA7418_SOFT_STEP_TIME_1_28ms           // use one of TDA7418_SOFT_STEP_TIME_0_16ms or TDA7418_SOFT_STEP_TIME_0_32ms  ... TDA7418_SOFT_STEP_TIME_10_24ms or TDA7418_SOFT_STEP_TIME_20_48ms 
....................    //#define  TDA7418_SOFT_STEP_TIME_2_56ms           // use one of TDA7418_SOFT_STEP_TIME_0_16ms or TDA7418_SOFT_STEP_TIME_0_32ms  ... TDA7418_SOFT_STEP_TIME_10_24ms or TDA7418_SOFT_STEP_TIME_20_48ms 
....................    //#define  TDA7418_SOFT_STEP_TIME_5_12ms           // use one of TDA7418_SOFT_STEP_TIME_0_16ms or TDA7418_SOFT_STEP_TIME_0_32ms  ... TDA7418_SOFT_STEP_TIME_10_24ms or TDA7418_SOFT_STEP_TIME_20_48ms 
....................    //#define  TDA7418_SOFT_STEP_TIME_10_24ms          // use one of TDA7418_SOFT_STEP_TIME_0_16ms or TDA7418_SOFT_STEP_TIME_0_32ms  ... TDA7418_SOFT_STEP_TIME_10_24ms or TDA7418_SOFT_STEP_TIME_20_48ms 
....................    //#define  TDA7418_SOFT_STEP_TIME_20_48ms          // use one of TDA7418_SOFT_STEP_TIME_0_16ms or TDA7418_SOFT_STEP_TIME_0_32ms  ... TDA7418_SOFT_STEP_TIME_10_24ms or TDA7418_SOFT_STEP_TIME_20_48ms 
....................  
....................    #ifdef   TDA7418_SOFT_STEP_TIME_0_16ms  
....................       #define TDA7418_SOFT_STEP_TIME            0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_SOFT_STEP_TIME_0_32ms 
....................       #define TDA7418_SOFT_STEP_TIME            0b00001000 
....................    #endif 
....................    #ifdef   TDA7418_SOFT_STEP_TIME_0_64ms 
....................       #define TDA7418_SOFT_STEP_TIME            0b00010000 
....................    #endif 
....................    #ifdef   TDA7418_SOFT_STEP_TIME_1_28ms 
....................       #define TDA7418_SOFT_STEP_TIME            0b00011000 
....................    #endif 
....................    #ifdef   TDA7418_SOFT_STEP_TIME_2_56ms 
....................       #define TDA7418_SOFT_STEP_TIME            0b00100000 
....................    #endif 
....................    #ifdef   TDA7418_SOFT_STEP_TIME_5_12ms 
....................       #define TDA7418_SOFT_STEP_TIME            0b00101000 
....................    #endif 
....................    #ifdef   TDA7418_SOFT_STEP_TIME_10_24ms 
....................       #define TDA7418_SOFT_STEP_TIME            0b00110000 
....................    #endif    
....................    #ifdef   TDA7418_SOFT_STEP_TIME_20_48ms 
....................       #define TDA7418_SOFT_STEP_TIME            0b00111000 
....................    #endif    
....................    /* bits 5 to 3 */      
....................     
....................    /* bits 6 to 6 */     
....................    #define TDA7418_AZ_FUNCTION_OFF                 // use one of TDA7418_AZ_FUNCTION_OFF  or TDA7418_AZ_FUNCTION_ON 
....................    //#define TDA7418_AZ_FUNCTION_ON 
....................     
....................    #ifdef   TDA7418_AZ_FUNCTION_OFF 
....................       #define  TDA7418_AZ_FUNCTION              0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_AZ_FUNCTION_ON 
....................       #define  TDA7418_AZ_FUNCTION              0b01000000 
....................    #endif    
....................    /* bits 6 to 6 */ 
....................     
....................    /* bits 7 to 6 */ 
....................    // any value is possible bits not used 
....................    /* bits 7 to 6 */       
....................    /*=========================================================================*/  
....................     
....................    /*========================================================================= 
....................    TDA7418 - Testing audio processor (13) - TDA7418_SubAddr_Test_Processor  
....................        -----------------------------------------------------------------------*/  
....................     
....................     /* bits 0 to 0 */   
....................    #define TDA7418_AUDIO_PROCESSOR_TESTING_MODE_OFF        // TDA7418_AUDIO_PROCESSOR_TESTING_MODE_OFF = OPERATION MODE //use one of TDA7418_AUDIO_PROCESSOR_TESTING_MODE_OFF (OPERATION MODE) or TDA7418_AUDIO_PROCESSOR_TESTING_MODE_ON 
....................    //#define TDA7418_AUDIO_PROCESSOR_TESTING_MODE_ON        // TDA7418_AUDIO_PROCESSOR_TESTING_MODE_OFF = OPERATION MODE //use one of TDA7418_AUDIO_PROCESSOR_TESTING_MODE_OFF (OPERATION MODE) or TDA7418_AUDIO_PROCESSOR_TESTING_MODE_ON 
....................     
....................    #ifdef   TDA7418_AUDIO_PROCESSOR_TESTING_MODE_OFF 
....................       #define  TDA7418_AUDIO_PROCESSOR_TESTING_MODE     0b00000000 
....................       #define  TDA7418_AUDIO_PROCESSOR_OPERATIING_MODE   0b00000000 
....................    #endif 
....................    #ifdef   TDA7418_AUDIO_PROCESSOR_TESTING_MODE_ON 
....................       #define  TDA7418_AUDIO_PROCESSORT_TESTING_MODE     0b00000001 
....................    #endif    
....................    /* bits 0 to 0 */ 
....................     
....................    //TODO: WRITE DEFINITIONS bits 7 to 1 
....................  
.................... void TDA7418_HardwareTest(); // The simplest hardware test routine - input: SE1 
.................... //void _TDA7418_i2cWritePrepare(); //use before i2c transmission 
.................... //void _TDA7418_i2cWriteExecute(); //use when i2c data is ready 
.................... void TDA7418__SelectInput(int8, int8, int8); //set TDA7418 input, define input gain and Diffin mode 
.................... void TDA7418__Loudness (int8, int8); 
.................... //void _TDA7418__Volume_Speaker_Attenuation(int8, int8); 
.................... void TDA7418__Volume(int8); 
.................... void TDA7418__LeftFront(int8); 
.................... void TDA7418__LeftRear(int8); 
.................... void TDA7418__RightRear(int8); 
.................... void TDA7418__RightFront(int8); 
.................... void TDA7418__Subwoofer(int8); 
.................... void TDA7418__Treble(int8); 
.................... void TDA7418__Middle(int8); 
.................... void TDA7418__Bass(int8); 
.................... void TDA7418__Middle_Bass_Fc_Select(void); 
.................... void TDA7418_Soft_Mut_Step_Time(void); 
.................... void _TDA7418_Audio_Processor_Testing_Mode(int8,int8,int8,int8); 
.................... void TDA7418_Audio_Processor_Operating_Mode(void); 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _I2C_ENGINE_ 
....................    #include </core/I2C_ENGINE/I2C_Engine.c> 
.................... #endif 
....................  
.................... /*#ifndef _BIT_MATH_ 
....................    #include </core/BIT_MATH/BIT_MATH.c> 
.................... #endif*/ 
....................  
.................... //extern volatile unsigned int8 MasterBuffer[I2C_BUFSIZE]; 
.................... //extern volatile unsigned int8 SlaveBuffer[I2C_BUFSIZE]; 
....................  
....................  
.................... /* 
.................... extern volatile unsigned int16 I2CReadLength; 
.................... extern volatile unsigned int16 I2CWriteLength;*/ 
....................  
.................... const int8 AUDIO_volume_attenuation[41] = //To raczej powinno byæ symetrycznie 
.................... {    
....................    0x60 /* <-- MUTE*/, /*0x5F, 0x5D, 0x5B, 0x59, 0x57,*/   0x55, 0x53, 0x51,  
....................    0x4F, 0x4D, 0x4B, 0x49, 0x47, 0x45, 0x43, 0x41,  
....................    0x3F, 0x3D, 0x3B, 0x39, 0x37, 0x35, 0x33, 0x31,  
....................    0x2F, 0x2D, 0x2B, 0x29, 0x27, 0x25, 0x23, 0x21,  
....................    0x1F, 0x1D, 0x1B, 0x19, 0x17, 0x15, 0x13, 0x11,/*idx_35 default*/ 
....................    0x0 /* 0dB*/,  0x02, 0x04, 0x06, 0x08  /*, 0x0A, 0x0C, 0x0E*/ 
.................... }; 
....................  
.................... const int8 AUDIO_speaker_LeftRight_FrontRear[41] = //idx 20 default i jego wartoœæ powinna byæ 0 db, a reszta symetrycznie a idx 0 0x60 czylu mute 
.................... {    
.................... //   0x60 /* <-- MUTE*/, /*0x5F, 0x5D, 0x5B, 0x59, 0x57,*/   0x55, 0x53, 0x51,  
.................... //   0x4F, 0x4D, 0x4B, 0x49, 0x47, 0x45, 0x43, 0x41,  
.................... //   0x3F, 0x3D, 0x3B, 0x39, 0x37, 0x35, 0x33, 0x31,  
.................... //   0x2F, 0x2D, 0x2B, 0x29, 0x27, 0x25, 0x23, 0x21,  
.................... //   0x1F, 0x1D, 0x1B, 0x19, 0x17, 0x15, 0x13, 0x11,/*idx_35 default*/ 
.................... //   0x0 /* 0dB*/,  0x02, 0x04, 0x06, 0x08  /*, 0x0A, 0x0C, 0x0E*/ 
.................... }; 
....................  
.................... const int8 AUDIO_Loudness_attenuation[16] = //To raczej powinno byæ symetrycznie 
.................... {    
....................    0x0, 0x1, 0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0XB,0xC,0xD,0xE,0xF 
.................... }; 
....................  
.................... const int8 AUDIO_Treble_Middle_Bass[31] = //To raczej powinno byæ symetrycznie 
.................... {    
....................    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0XB, 0x0C, 
....................    0x0D, 0x0E, 0x0F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x17, 0x16, 0x15, 
....................    0x14, 0x13, 0x12, 0x11, 0x10 
.................... }; 
....................  
.................... const int8 AUDIO_low_high_boost[2] = 
.................... { 
.................... 0b00000000, 
.................... 0b01000000 
.................... }; 
....................  
.................... void TDA7418_HardwareTest() 
.................... { 
.................... /* Simple hardwarew test. 1st imput*/ 
....................       i2c_start(); 
....................        
....................          i2c_write(0x88);                                //          'address 
....................          i2c_write(0x20);                                //        'REG0 AUTO INC 
....................          i2c_write(0x01);                                //        '0-INPUT SELECTOR 
....................          i2c_write(0x80);                                //        '1-LOUDNESS OFF 
....................          i2c_write(0x80);                                //        '2-*VOLUME 0DB 
....................          i2c_write(0xCF);                                //        '3-TREBLE CENTER 15KHZ, 0DB 
....................          i2c_write(0xCF);                                //        '4-MIDDLE Q=1 0DB 
....................          i2c_write(0x8F);                                //        '5-BASS Q=1 0DB 
....................          i2c_write(0x0E);                                //        '6-BASS 200HZ MIDDLE 1,5KHZ 
....................          i2c_write(0xA0);                                //        '7-*  LEFT FRONT 
....................          i2c_write(0xA0);                                //        '8-*  LEFT REAR 
....................          i2c_write(0xA0);                                //        '9-*  RIGHT REAR 
....................          i2c_write(0xA0);                                //        '10-* RIGHT FRONT 
....................          i2c_write(0x80);                                //        '11-* SUBWOOFER 
....................          i2c_write(0x01);                                //        '12-SOFT MUTE SOFT STEP OFF 
....................          i2c_write(0x00);                                //        '13-IN OPERATION 
....................           
....................       i2c_stop(); 
.................... } 
....................  
.................... const int8 AUDIO_L_H_BOOST[2]= 
.................... { 
.................... TDA7418_SHAPE_LOW_BOOST, TDA7418_SHAPE_LOW_HIGH_BOOST 
.................... }; 
....................  
.................... void _TDA7418_i2cWritePrepare (void) 
.................... { 
.................... /* Prepare Transmission buffer to transmission*/ 
....................    //ClearBuffers(&MasterBuffer,I2C_BUFSIZE); 
....................    i2c_ClearMasterBuffer  (); 
*
00A6:  CLRF   51
00A8:  MOVLW  04
00AA:  MOVWF  50
00AC:  CLRF   53
00AE:  MOVLW  10
00B0:  MOVWF  52
00B2:  RCALL  0078
....................    *(i2c_MasterBuffer) = TDA7418_ADDRESS_Write; 
00B4:  CLRF   03
00B6:  MOVLW  04
00B8:  MOVWF  FE9
00BA:  MOVFF  03,FEA
00BE:  MOVLW  88
00C0:  MOVWF  FEF
00C2:  RETURN 0
.................... } 
....................  
.................... void _TDA7418_i2cWriteExecute(void) 
.................... { 
.................... /* I2Cengine write parameters setup */ 
....................    I2CWriteLength = 3; //i2cEngine write information 
*
05D2:  CLRF   37
05D4:  MOVLW  03
05D6:  MOVWF  36
....................    I2CReadLength = 0;  //i2cEngine read information 
05D8:  CLRF   35
05DA:  CLRF   34
....................    i2cEngine(FALSE);        //write or read data  depend of I2CWriteLength and I2CReadLength 
05DC:  CLRF   4E
05DE:  RCALL  0414
05E0:  RETURN 0
.................... } 
....................  
.................... void TDA7418__SelectInput (int8 input, int8 input_gain_dB_value, int8 SE4_PD_mode_Diffin_Mode) 
.................... { 
....................    _TDA7418_i2cWritePrepare(); 
05E2:  RCALL  00A6
....................    i2c_MasterBuffer[1] = TDA7418_SubAddr_Testing_Mode_OFF|TDA7418_SubAddr_Auto_Zero_Remain_OFF|TDA7418_SubAddr_Auto_Increment_Mode_OFF|TDA7418_SubAddr_Src; 
05E4:  CLRF   05
....................    //MasterBuffer[2] = TDA7418_DIFFIN_MODE_DIFFERENTIAL|TDA7418_INPUT_GAIN_0dB|input; 
....................    //i2c_MasterBuffer[2] = TDA7418_DIFFIN_MODE_DIFFERENTIAL|input_gain_dB_value|input; 
....................     
....................    i2c_MasterBuffer[2] = SE4_PD_mode_Diffin_Mode|input_gain_dB_value|input; 
05E6:  MOVF   45,W
05E8:  IORWF  44,W
05EA:  IORWF  43,W
05EC:  MOVWF  06
....................    _TDA7418_i2cWriteExecute(); 
05EE:  RCALL  05D2
05F0:  GOTO   0A22 (RETURN)
.................... } 
....................  
.................... void TDA7418__Loudness(int8 Loudness_dB_value, int8 Low_HighBoost) 
.................... { 
....................    _TDA7418_i2cWritePrepare(); 
05F4:  RCALL  00A6
....................    i2c_MasterBuffer[1] = TDA7418_SubAddr_Testing_Mode_OFF|TDA7418_SubAddr_Auto_Zero_Remain_OFF|TDA7418_SubAddr_Auto_Increment_Mode_OFF|TDA7418_SubAddr_Loud; 
05F6:  MOVLW  01
05F8:  MOVWF  05
....................    i2c_MasterBuffer[2] = TDA7418_LOUDNESS_SOFT_STEF_OFF|Low_HighBoost|TDA7418_CENTER_FREQ|Loudness_dB_value; 
05FA:  MOVF   44,W
05FC:  IORLW  80
05FE:  IORLW  10
0600:  IORWF  43,W
0602:  MOVWF  06
....................    _TDA7418_i2cWriteExecute(); 
0604:  RCALL  05D2
0606:  GOTO   0A2A (RETURN)
.................... } 
....................  
.................... void _TDA7418__Volume_Speaker_Attenuation(int8 Volume_dB_value, int8 Output_TDA7418_i2C_Addres) 
.................... { 
....................    _TDA7418_i2cWritePrepare(); 
060A:  RCALL  00A6
....................    i2c_MasterBuffer[1] = TDA7418_SubAddr_Testing_Mode_OFF|TDA7418_SubAddr_Auto_Zero_Remain_OFF|TDA7418_SubAddr_Auto_Increment_Mode_OFF|Output_TDA7418_i2C_Addres; 
060C:  MOVFF  45,05
....................    i2c_MasterBuffer[2] = TDA7418_VOLUME_SOFT_STEP|Volume_dB_value; 
0610:  MOVFF  44,06
....................    _TDA7418_i2cWriteExecute(); 
0614:  RCALL  05D2
0616:  RETURN 0
.................... } 
....................  
.................... void TDA7418__Volume(int8 Volume_dB_value) 
.................... { 
....................    _TDA7418__Volume_Speaker_Attenuation(Volume_dB_value, TDA7418_SubAddr_Vol); 
0618:  MOVFF  43,44
061C:  MOVLW  02
061E:  MOVWF  45
0620:  RCALL  060A
0622:  GOTO   0A30 (RETURN)
.................... } 
....................  
.................... void TDA7418__LeftFront(int8 Volume_dB_value) 
.................... { 
....................    _TDA7418__Volume_Speaker_Attenuation(Volume_dB_value, TDA7418_SubAddr_LF); 
*
066C:  MOVFF  43,44
0670:  MOVLW  07
0672:  MOVWF  45
0674:  RCALL  060A
0676:  GOTO   0A4A (RETURN)
.................... } 
....................  
.................... void TDA7418__LeftRear(int8 Volume_dB_value) 
.................... { 
....................    _TDA7418__Volume_Speaker_Attenuation(Volume_dB_value, TDA7418_SubAddr_LR); 
067A:  MOVFF  43,44
067E:  MOVLW  08
0680:  MOVWF  45
0682:  RCALL  060A
0684:  GOTO   0A50 (RETURN)
.................... } 
....................  
.................... void TDA7418__RightRear(int8 Volume_dB_value) 
.................... { 
....................    _TDA7418__Volume_Speaker_Attenuation(Volume_dB_value, TDA7418_SubAddr_RR); 
0688:  MOVFF  43,44
068C:  MOVLW  09
068E:  MOVWF  45
0690:  RCALL  060A
0692:  GOTO   0A56 (RETURN)
.................... } 
....................  
.................... void TDA7418__RightFront(int8 Volume_dB_value) 
.................... { 
....................    _TDA7418__Volume_Speaker_Attenuation(Volume_dB_value, TDA7418_SubAddr_RF); 
0696:  MOVFF  43,44
069A:  MOVLW  0A
069C:  MOVWF  45
069E:  RCALL  060A
06A0:  GOTO   0A5C (RETURN)
.................... } 
....................  
.................... void TDA7418__Subwoofer(int8 Volume_dB_value) 
.................... { 
....................    _TDA7418__Volume_Speaker_Attenuation(Volume_dB_value, TDA7418_SubAddr_SW ); 
06A4:  MOVFF  43,44
06A8:  MOVLW  0B
06AA:  MOVWF  45
06AC:  RCALL  060A
06AE:  GOTO   0A60 (RETURN)
.................... } 
.................... void TDA7418__Treble(int8 Treble_dB_value) 
.................... { 
....................    _TDA7418_i2cWritePrepare(); 
*
0626:  RCALL  00A6
....................    i2c_MasterBuffer[1] = TDA7418_SubAddr_Testing_Mode_OFF|TDA7418_SubAddr_Auto_Zero_Remain_OFF|TDA7418_SubAddr_Auto_Increment_Mode_OFF|TDA7418_SubAddr_Tre; 
0628:  MOVLW  03
062A:  MOVWF  05
....................    i2c_MasterBuffer[2] = TDA7418_TREBLE_BIT7|TDA7418_TREBLE_CENTRAL_FREQUENCY|Treble_dB_value; 
062C:  MOVF   43,W
062E:  IORLW  A0
0630:  MOVWF  06
....................    _TDA7418_i2cWriteExecute(); 
0632:  RCALL  05D2
0634:  GOTO   0A36 (RETURN)
.................... } 
....................  
.................... void TDA7418__Middle(int8 Middle_dB_value) 
.................... { 
....................    _TDA7418_i2cWritePrepare(); 
0638:  RCALL  00A6
....................    i2c_MasterBuffer[1] = TDA7418_SubAddr_Testing_Mode_OFF|TDA7418_SubAddr_Auto_Zero_Remain_OFF|TDA7418_SubAddr_Auto_Increment_Mode_OFF|TDA7418_SubAddr_Mid; 
063A:  MOVLW  04
063C:  MOVWF  05
....................    i2c_MasterBuffer[2] = TDA7418_MIDDLE_SOFT_STEP|TDA7418_MIDDLE_Q_FACTOR|Middle_dB_value; 
063E:  MOVF   43,W
0640:  IORLW  C0
0642:  MOVWF  06
....................    _TDA7418_i2cWriteExecute();    
0644:  RCALL  05D2
0646:  GOTO   0A3C (RETURN)
.................... } 
....................  
.................... void TDA7418__Bass(int8 Bass_dB_value) 
.................... {  
....................    _TDA7418_i2cWritePrepare(); 
064A:  RCALL  00A6
....................    i2c_MasterBuffer[1] = TDA7418_SubAddr_Testing_Mode_OFF|TDA7418_SubAddr_Auto_Zero_Remain_OFF|TDA7418_SubAddr_Auto_Increment_Mode_OFF|TDA7418_SubAddr_Bas; 
064C:  MOVLW  05
064E:  MOVWF  05
....................    i2c_MasterBuffer[2] = TDA7418_BASS_SOFT_STEP|TDA7418_BASS_Q_FACTOR|Bass_dB_value; 
0650:  MOVF   43,W
0652:  IORLW  80
0654:  MOVWF  06
....................    _TDA7418_i2cWriteExecute();  
0656:  RCALL  05D2
0658:  GOTO   0A42 (RETURN)
.................... } 
....................  
.................... void TDA7418__Middle_Bass_Fc_Select(void) 
.................... { 
....................    _TDA7418_i2cWritePrepare(); 
065C:  RCALL  00A6
....................    i2c_MasterBuffer[1] = TDA7418_SubAddr_Testing_Mode_OFF|TDA7418_SubAddr_Auto_Zero_Remain_OFF|TDA7418_SubAddr_Auto_Increment_Mode_OFF|TDA7418_SubAddr_FC; 
065E:  MOVLW  06
0660:  MOVWF  05
....................    i2c_MasterBuffer[2] = TDA7418_SMOOTHING_FILTER|TDA7418_BASS_DC_MODE|TDA7418_BASS_CENTER_FREQUENCY|TDA7418_MIDDLE_CENTER_FREQUENCY; 
0662:  MOVLW  0E
0664:  MOVWF  06
....................    _TDA7418_i2cWriteExecute();     
0666:  RCALL  05D2
0668:  GOTO   0A44 (RETURN)
.................... } 
....................  
.................... void TDA7418_Soft_Mut_Step_Time(void) 
.................... { 
....................    _TDA7418_i2cWritePrepare(); 
*
06B2:  RCALL  00A6
....................    i2c_MasterBuffer[1] = TDA7418_SubAddr_Testing_Mode_OFF|TDA7418_SubAddr_Auto_Zero_Remain_OFF|TDA7418_SubAddr_Auto_Increment_Mode_OFF|TDA7418_SubAddr_Soft_Mute; 
06B4:  MOVLW  0C
06B6:  MOVWF  05
....................    i2c_MasterBuffer[2] = TDA7418_SOFT_MUTE|TDA7418_SOFT_MUTE_TIME|TDA7418_SOFT_STEP_TIME|TDA7418_AZ_FUNCTION; 
06B8:  MOVLW  0D
06BA:  MOVWF  06
....................    _TDA7418_i2cWriteExecute();   
06BC:  RCALL  05D2
06BE:  GOTO   0A62 (RETURN)
.................... } 
....................  
.................... void _TDA7418_Audio_Processor_Testing_Mode(int8 mode, int8 miltiplekser, int8 SC_clock, int8 MUTE_Pin_Config) 
.................... { 
....................    _TDA7418_i2cWritePrepare(); 
06C2:  RCALL  00A6
....................    i2c_MasterBuffer[1] = TDA7418_SubAddr_Testing_Mode_OFF|TDA7418_SubAddr_Auto_Zero_Remain_OFF|TDA7418_SubAddr_Auto_Increment_Mode_OFF|TDA7418_SubAddr_Test_Processor ; 
06C4:  MOVLW  0D
06C6:  MOVWF  05
....................    i2c_MasterBuffer[2] = mode|miltiplekser|SC_clock|MUTE_Pin_Config; 
06C8:  MOVF   43,W
06CA:  IORWF  44,W
06CC:  IORWF  45,W
06CE:  IORWF  46,W
06D0:  MOVWF  06
....................    _TDA7418_i2cWriteExecute();   
06D2:  RCALL  05D2
06D4:  GOTO   06E2 (RETURN)
.................... } 
....................  
.................... void TDA7418_Audio_Processor_Operating_Mode(void) 
.................... { 
....................    _TDA7418_Audio_Processor_Testing_Mode(TDA7418_AUDIO_PROCESSOR_OPERATIING_MODE, 0, 0, 0); 
06D8:  CLRF   43
06DA:  CLRF   44
06DC:  CLRF   45
06DE:  CLRF   46
06E0:  BRA    06C2
06E2:  GOTO   0A64 (RETURN)
.................... } 
....................  
.................... //#include </core/PIC_EEPROM/pic_eeprom.c> 
....................  
.................... /*void _TDA7418_i2cWritePrepare (void) 
.................... { 
.................... ClearBuffers(&MasterBuffer,I2C_BUFSIZE); 
.................... *(MasterBuffer) = TDA7418_ADDRESS_Write; 
.................... } 
....................  
.................... void _TDA7418_i2cWriteExecute(void) 
.................... { 
....................    I2CWriteLength = 3; //i2cEngine write information 
....................    I2CReadLength = 0;  //i2cEngine read information 
....................    i2cEngine(); 
.................... }*/ 
....................  
.................... //unsigned int buffer =0; 
....................  
.................... /* 
.................... #INT_RDA 
.................... void INT_RDA_handler() 
.................... { 
....................  
.................... dbg_printf("%c", fgetc(Hardware__comm_port)); 
.................... }*/ 
....................  
.................... void main() 
*
09D2:  CLRF   FF8
09D4:  BCF    FD0.7
09D6:  BSF    F94.3
09D8:  BSF    F94.4
09DA:  MOVLW  31
09DC:  MOVWF  FC8
09DE:  MOVLW  28
09E0:  MOVWF  FC6
09E2:  BSF    FC7.7
09E4:  BCF    FC7.6
09E6:  BSF    FB8.3
09E8:  MOVLW  56
09EA:  MOVWF  FAF
09EC:  MOVLW  00
09EE:  MOVWF  FB0
09F0:  MOVLW  A6
09F2:  MOVWF  FAC
09F4:  MOVLW  90
09F6:  MOVWF  FAB
09F8:  NOP   
09FA:  NOP   
09FC:  BCF    F93.7
09FE:  BSF    F8A.7
0A00:  MOVF   FC1,W
0A02:  ANDLW  C0
0A04:  IORLW  0F
0A06:  MOVWF  FC1
0A08:  MOVLW  07
0A0A:  MOVWF  FB4
0A0C:  CLRF   38
0A0E:  CLRF   39
.................... { 
....................  
.................... //StartupVoltageStabilisation; 
.................... //unsigned int32 FMfreqency; 
....................  
....................  
....................  
.................... //MasterBuffer[0]=0x10; 
....................  
.................... //delay_ms(2000); 
.................... //dbg_printf("START"); 
.................... //disable_interrupts(GLOBAL); 
.................... enable_interrupts(INT_RDA); 
0A10:  BSF    F9D.5
.................... enable_interrupts(GLOBAL); 
0A12:  MOVLW  C0
0A14:  IORWF  FF2,F
....................  
....................  
....................  
....................  
.................... /*   int8  i2c_ACK=1; 
....................    unsigned int i2c_tryout_error = 0; 
....................    while(i2c_ACK!=0&&i2c_tryout_error <100) 
....................    {i2c_ACK = __i2cDeviceStatus(); 
....................    i2c_tryout_error = i2c_tryout_error +1; 
....................    } 
....................    */ 
....................     
.................... //i2cEngine(FALSE); 
....................  
.................... //dbg_printf("222"); 
.................... //delay_ms(1000); 
.................... //  AAntenna_ON(); 
.................... //delay_ms(1000); 
.................... /*   delay_ms(1000); 
....................    output_high(pin_b4); 
....................    delay_ms(1000); 
....................    fprintf(LOG_PORT,"tata"); 
....................    fprintf(LOG_PORT,"mama");*/ 
....................  
....................    TDA7418__SelectInput(TDA7418_INPUT_SE1, TDA7418_INPUT_GAIN_0dB, TDA7418_DIFFIN_MODE_DIFFERENTIAL); 
0A16:  MOVLW  01
0A18:  MOVWF  43
0A1A:  CLRF   44
0A1C:  MOVLW  80
0A1E:  MOVWF  45
0A20:  BRA    05E2
....................    TDA7418__Loudness (AUDIO_Loudness_attenuation[0], TDA7418_SHAPE_LOW_HIGH_BOOST);   
0A22:  CLRF   43
0A24:  MOVLW  20
0A26:  MOVWF  44
0A28:  BRA    05F4
....................    TDA7418__Volume(AUDIO_volume_attenuation[35]); 
0A2A:  MOVLW  11
0A2C:  MOVWF  43
0A2E:  BRA    0618
....................    TDA7418__Treble(AUDIO_Treble_Middle_Bass[16]); 
0A30:  MOVLW  1E
0A32:  MOVWF  43
0A34:  BRA    0626
....................    TDA7418__Middle(AUDIO_Treble_Middle_Bass[16]); 
0A36:  MOVLW  1E
0A38:  MOVWF  43
0A3A:  BRA    0638
....................    TDA7418__Bass(AUDIO_Treble_Middle_Bass[16]); 
0A3C:  MOVLW  1E
0A3E:  MOVWF  43
0A40:  BRA    064A
....................    TDA7418__Middle_Bass_Fc_Select(); 
0A42:  BRA    065C
....................    TDA7418__LeftFront(AUDIO_Treble_Middle_Bass[16]); 
0A44:  MOVLW  1E
0A46:  MOVWF  43
0A48:  BRA    066C
....................    TDA7418__LeftRear(AUDIO_Treble_Middle_Bass[16]); 
0A4A:  MOVLW  1E
0A4C:  MOVWF  43
0A4E:  BRA    067A
....................    TDA7418__RightRear(AUDIO_Treble_Middle_Bass[16]); 
0A50:  MOVLW  1E
0A52:  MOVWF  43
0A54:  BRA    0688
....................    TDA7418__RightFront(AUDIO_Treble_Middle_Bass[16]); 
0A56:  MOVLW  1E
0A58:  MOVWF  43
0A5A:  BRA    0696
....................    TDA7418__Subwoofer(AUDIO_Treble_Middle_Bass[0]);     //SW mute 
0A5C:  CLRF   43
0A5E:  BRA    06A4
....................    TDA7418_Soft_Mut_Step_Time(); 
0A60:  BRA    06B2
....................    TDA7418_Audio_Processor_Operating_Mode(); 
0A62:  BRA    06D8
....................  
.................... tea5767_init(100200000);   //(100200000); 
0A64:  MOVLW  05
0A66:  MOVWF  46
0A68:  MOVLW  F8
0A6A:  MOVWF  45
0A6C:  MOVLW  EE
0A6E:  MOVWF  44
0A70:  MOVLW  40
0A72:  MOVWF  43
0A74:  BRA    07EA
.................... delay_ms(5000); 
0A76:  MOVLW  14
0A78:  MOVWF  43
0A7A:  MOVLW  FA
0A7C:  MOVWF  44
0A7E:  BRA    0962
0A80:  DECFSZ 43,F
0A82:  BRA    0A7A
.................... tea5767_StandBy(1); 
0A84:  MOVLW  03
0A86:  MOVWF  43
0A88:  MOVLW  01
0A8A:  MOVWF  44
0A8C:  MOVLW  06
0A8E:  MOVWF  45
0A90:  BRA    098A
.................... tea5767SendData (&tea5767_config); 
0A92:  CLRF   4C
0A94:  MOVLW  3E
0A96:  MOVWF  4B
0A98:  RCALL  078C
....................  
.................... //TDA7418__SelectInput(TDA7418_INPUT_PD_SE4, TDA7418_INPUT_GAIN_0dB, TDA7418_DIFFIN_MODE_DIFFERENTIAL); 
.................... /*delay_ms(1000); 
.................... fprintf(LOG_PORT,"dekay"); 
.................... delay_ms(1000); 
.................... output_low(pin_b4); 
.................... delay_ms(1000); 
.................... fprintf(LOG_PORT,"low");*/ 
....................  
....................  
.................... while(1) 
.................... { 
0A9A:  BRA    0A9A
.................... //fprintf(LOG_PORT,"low"); 
.................... } 
.................... //dbg_printf("1111 "); 
....................  
.................... //*MasterBuffer=au_header; 
....................  
....................  
.................... } 
....................  
0A9C:  SLEEP 
....................  

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
