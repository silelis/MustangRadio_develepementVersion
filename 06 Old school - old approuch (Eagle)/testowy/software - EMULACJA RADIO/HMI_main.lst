CCS PCM C Compiler, Version 5.070, 5967               05-paŸ-17 09:43

               Filename:   F:\Elektronika_projekty\Car_Radio\testowy\software\HMI_main.lst

               ROM used:   4803 words (59%)
                           Largest free fragment is 2048
               RAM used:   127 (35%) at main() level
                           156 (42%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.3
002A:  GOTO   02D
002B:  BTFSC  0C.3
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   080
.................... #include </HMI_MCU_common_includes/HMI_i2c_slave_address/i2c_slave_address.h> 
.................... #define i2c_slave_address        0x10 
.................... #define i2c_slave_fake_address   0x12 
....................  
.................... #define i2c_slave_ready()            I2C_SlaveAddr(i2c_slave_address)            //ustawia w³aœciwy adres slave, wtedy master otrzymuje ACK = 0 czyli ok 
.................... #define i2c_slave_not_ready()        I2C_SlaveAddr(i2c_slave_fake_address)       //ustawia fa³szywy adres slave (jak ¿adnego innego urz¹dzenia w uk³adzie), wtedy master nie otrzymuje ¿adnego ACK 
....................  
....................  
.................... #ifndef __CONFIG_FILE__ 
....................    #include<HMI_main_SLAVE_CONFIG_FILE.h> 
.................... #ifndef __CONFIG_FILE__ 
....................       #define __CONFIG_FILE__ 
....................        
....................        
....................       #define slave_fw_version  "HMI_stepper_motor_calibrator_fw_v0_1 " 
....................        
....................       #define _USE_LOGPORT_               //chode one of _USE_LOGPORT_ or DEBUG_ENABLED 
....................       //#define DEBUG_ENABLED             //chode one of _USE_LOGPORT_ or DEBUG_ENABLED 
....................       //#define  _STEPPER_MOTOR_ON_INTERRUPTS_ 
.................... #endif 
....................  
.................... #endif 
....................  
.................... //hardware I2C SLAVE pins - can be changed 
....................    #define  i2c_SDA_pin       PIN_C4 
....................    #define  i2c_SCL_pin       PIN_C3 
.................... //hardware I2C SLAVE pins - can be changed 
....................  
.................... //hardware LEDS definition - can be changed 
....................    #define LED1_GREEN   PIN_A0 
....................    #define LED1_RED     PIN_A1    
....................    #define LED1_BLUE    PIN_A2 
....................  
....................    #define LED2_GREEN   PIN_A3 
....................    #define LED2_RED     PIN_A5 
....................    #define LED2_BLUE    PIN_E0 
....................     
....................    #define LED3_GREEN   PIN_E1 
....................    #define LED3_RED     PIN_E2 
....................    #define LED3_BLUE    PIN_C0 
.................... //hardware LEDS definition - can be changed 
....................  
.................... //Active antena selsctor - can be changed 
....................    #define  IS_FM_ANT_ACTIVE             PIN_B0 
....................    #define  IS_DAB_ANT_ACTIVE            PIN_B1 
....................    #define  IS_FM_DAB_CONVERTER_ACTIVE   PIN_B2 
.................... //Active antena selsctor - can be changed 
....................  
.................... //Steper motor pinout - can be changed 
....................    #define  A1  PIN_C5 
....................    #define  A2  PIN_C6 
....................    #define  A3  PIN_C7 
....................    #define  A4  PIN_D4 
....................    #define  use_EN_pins 
....................    #define  EN_12 PIN_D2 
....................    #define  EN_34 EN_12 
....................     
....................    #define one_fase_control    //chose one of one_fase_control  OR two_fase_control OR halfstep_control 
....................    // #define two_fase_control      //chose one of one_fase_control  OR two_fase_control OR halfstep_control 
....................    //#define halfstep_control    //chose one of one_fase_control  OR two_fase_control OR halfstep_control 
....................     
....................    #define steper_motor_left_end                PIN_D5 
....................    #define steper_motor_right_end               PIN_D6  
....................    #define steper_motor_sensor_enable_pin       PIN_D7    
....................     
.................... //Steper motor pinout - can be changed 
.................... #ifndef __RADIO_DEFAULTS_PARAMETERS__ 
....................    #include </HMI_MCU_common_includes/MCU_radio_default_parameters/radio_default_parameters.h> 
.................... #ifndef __RADIO_DEFAULTS_PARAMETERS__ 
....................    #define  __RADIO_DEFAULTS_PARAMETERS__ 
....................     
....................       /*--------------------------------------------*/ 
....................       /*-------- RADIO VARIABLE PARAMETERS ---------*/ 
....................       /*--------------------------------------------*/ 
....................        
.................... //      #ifndef __menu_module_function__ 
....................  //        #include</MCU_include/modules/menu_module/menu_module.c> 
....................   //    #endif 
....................          #define FM_freuency_DEFAULT_VAL       87500000 
....................          #define FM_freuency_step              100000 
....................          #if defined US_EU_FM_RADIO 
....................             #define FM_freuency_MIN_VAL        87500000 
....................             #define FM_freuency_MAX_VAL        108000000 
....................          #elif defined JAPAN_FM_RADIO 
....................             #define FM_freuency_MIN_VAL        76000000 
....................             #define FM_freuency_MAX_VAL        91000000 
....................          #endif 
....................           
....................          #if defined EU_AM_RADIO 
....................             #define AM_freuency_DEFAULT_VAL       522000    //TODO: SPRAWDZIÆ PRZELICZNIK CZÊSTOTLIWOŒCI                                 
....................             #define AM_freuency_step              9000 
....................             #define AM_freuency_MIN_VAL           522000    //TODO: SPRAWDZIÆ PRZELICZNIK CZÊSTOTLIWOŒCI 
....................             #define AM_freuency_MAX_VAL           1611000   //TODO: SPRAWDZIÆ PRZELICZNIK CZÊSTOTLIWOŒCI 
....................          #elif defined US_AM_RADIO 
....................             #define AM_freuency_DEFAULT_VAL       522000    //TODO: SPRAWDZIÆ PRZELICZNIK CZÊSTOTLIWOŒCI                                 
....................             #define AM_freuency_step              10000 
....................             #define AM_freuency_MIN_VAL           522000    //TODO: SPRAWDZIÆ PRZELICZNIK CZÊSTOTLIWOŒCI 
....................             #define AM_freuency_MAX_VAL           1710000   //TODO: SPRAWDZIÆ PRZELICZNIK CZÊSTOTLIWOŒCI   
....................          #endif    
....................           
....................          #define active_antena_MIN_VAL         0 
....................          #define active_antena_MAX_VAL         1 
....................           
....................          #define EQU_VOL_DEFAULT_VAL           5   
....................          #define EQU_VOL_MIN_VAL               0 
....................          #define EQU_VOL_MAX_VAL               40  //const int8 AUDIO_speaker_LeftRight_FrontRear[41], wiêc 41-1 
....................           
....................          #define EQU_Treble_DEFAULT_VAL        0     
....................          #define EQU_Treble_MIN_VAL            0    
....................          #define EQU_Treble_MAX_VAL            30  //const int8 AUDIO_Treble_Middle_Bass[31], wiêc 31-1 
....................           
....................          #define EQU_Middle_DEFAULT_VAL        0 
....................          #define EQU_Middle_MIN_VAL            0 
....................          #define EQU_Middle_MAX_VAL            30  //const int8 AUDIO_Treble_Middle_Bass[31], wiêc 31-1 
....................           
....................          #define EQU_Bass_DEFAULT_VAL          0 
....................          #define EQU_Bass_MIN_VAL              0 
....................          #define EQU_Bass_MAX_VAL              30  //const int8 AUDIO_Treble_Middle_Bass[31], wiêc 31-1   
....................           
....................          #define EQU_L_H_Boost_DEFAULT_VAL     0 
....................          #define EQU_L_H_Boost_MIN_VAL         0 
....................          #define EQU_L_H_Boost_MAX_VAL         1   //const int8 AUDIO_low_high_boost[2], wiêc 2-1 
....................           
....................          #define EQU_Left_Right_DEFAULT_VAL    0   
....................          #define EQU_Left_Right_MIN_VAL        -6 //0xFA      //-6 w hex 
....................          #define EQU_Left_Right_MAX_VAL        6         //const int8 AUDIO_speaker_LeftRight_FrontRear[7], wiêc 7-1 
....................           
....................          #define EQU_Front_Rear_DEFAULT_VAL    0 
....................          #define EQU_Front_Rear_MIN_VAL        -6 //0xFA      //-6 w hex 
....................          #define EQU_Front_Rear_MAX_VAL        6   //const int8 AUDIO_speaker_LeftRight_FrontRear[7], wiêc 7-1    
....................           
....................          #define Backlight_MAX_VAL             1 
....................          #define Backlight_DEFAULT_VAL         Backlight_MAX_VAL 
....................          #define Backlight_MIN_VAL             0 
....................           
....................           
....................           
....................           //TODO: DAB_freuency_value 
....................           //TODO: Backlight_value    
....................           
....................           
....................  /*        #ifndef __menu_module_function__ 
....................                #include</MCU_include/modules/menu_module/menu_module.c> 
....................          #endif*/ 
....................           
....................           
....................          #define audio_input_DEFAULT_VAL       0 
....................          #define audio_input_MIN_VAL           0 
....................          #define audio_input_MAX_VAL           MENU_MODULE_NOTSUPPORTED_input 
....................       /*--------------------------------------------*/ 
....................       /*-------- RADIO VARIABLE PARAMETERS ---------*/ 
....................       /*--------------------------------------------*/ 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <HMI_main.h> 
.................... //#include <16F877.h> 
.................... #include <16F77.h> 
.................... //////////// Standard Header file for the PIC16F77 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F77 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  00
0056:  RETLW  00
0057:  RETLW  00
0058:  RETLW  00
0059:  RETLW  01
005A:  RETLW  00
005B:  RETLW  00
005C:  RETLW  00
005D:  RETLW  00
005E:  RETLW  00
005F:  RETLW  01
0060:  RETLW  00
0061:  RETLW  00
0062:  RETLW  01
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  00
0068:  RETLW  01
0069:  DATA 53,2A
006A:  DATA 4F,28
006B:  DATA 3A,36
006C:  DATA 65,33
006D:  DATA 74,10
006E:  DATA 65,37
006F:  DATA 64,10
0070:  DATA F2,32
0071:  DATA E1,31
0072:  DATA E8,32
0073:  DATA 64,00
0074:  DATA 53,2A
0075:  DATA 4F,28
0076:  DATA 3A,39
0077:  DATA E9,33
0078:  DATA 68,3A
0079:  DATA A0,32
007A:  DATA 6E,32
007B:  DATA 20,39
007C:  DATA E5,30
007D:  DATA 63,34
007E:  DATA 65,32
007F:  DATA 00,00
*
00F1:  RETLW  48
00F2:  RETLW  4D
00F3:  RETLW  49
00F4:  RETLW  5F
00F5:  RETLW  73
00F6:  RETLW  74
00F7:  RETLW  65
00F8:  RETLW  70
00F9:  RETLW  70
00FA:  RETLW  65
00FB:  RETLW  72
00FC:  RETLW  5F
00FD:  RETLW  6D
00FE:  RETLW  6F
00FF:  RETLW  74
0100:  RETLW  6F
0101:  RETLW  72
0102:  RETLW  5F
0103:  RETLW  63
0104:  RETLW  61
0105:  RETLW  6C
0106:  RETLW  69
0107:  RETLW  62
0108:  RETLW  72
0109:  RETLW  61
010A:  RETLW  74
010B:  RETLW  6F
010C:  RETLW  72
010D:  RETLW  5F
010E:  RETLW  66
010F:  RETLW  77
0110:  RETLW  5F
0111:  RETLW  76
0112:  RETLW  30
0113:  RETLW  5F
0114:  RETLW  31
0115:  RETLW  20
0116:  RETLW  30
0117:  RETLW  35
0118:  RETLW  2D
0119:  RETLW  70
011A:  RETLW  61
011B:  RETLW  9F
011C:  RETLW  2D
011D:  RETLW  31
011E:  RETLW  37
011F:  RETLW  20
0120:  RETLW  30
0121:  RETLW  39
0122:  RETLW  3A
0123:  RETLW  34
0124:  RETLW  33
0125:  RETLW  3A
0126:  RETLW  32
0127:  RETLW  36
0128:  RETLW  00
0129:  DATA 53,3A
012A:  DATA 61,39
012B:  DATA 74,10
012C:  DATA C8,26
012D:  DATA 49,00
012E:  DATA 63,1D
012F:  DATA 30,3C
0130:  DATA 25,2C
0131:  DATA 20,00
0132:  DATA 63,36
0133:  DATA E5,30
0134:  DATA 72,10
0135:  DATA 61,36
0136:  DATA 6C,10
0137:  DATA F0,30
0138:  DATA E3,35
0139:  DATA 73,00
013A:  DATA 63,36
013B:  DATA E5,30
013C:  DATA 72,10
013D:  DATA A5,3A
013E:  DATA 20,38
013F:  DATA E1,31
0140:  DATA 6B,17
0141:  DATA 80,06
0142:  DATA D3,32
0143:  DATA 74,10
0144:  DATA 61,36
0145:  DATA 6C,10
0146:  DATA F0,30
0147:  DATA E3,35
0148:  DATA 73,10
0149:  DATA E3,37
014A:  DATA EC,37
014B:  DATA 75,39
014C:  DATA A0,12
014D:  DATA 75,00
014E:  DATA D3,32
014F:  DATA 74,10
0150:  DATA F0,30
0151:  DATA E3,35
0152:  DATA A0,12
0153:  DATA 75,10
0154:  DATA E3,37
0155:  DATA EC,37
0156:  DATA 75,39
0157:  DATA A0,12
0158:  DATA 75,00
0159:  DATA 42,36
015A:  DATA 69,37
015B:  DATA 6B,10
015C:  DATA 61,36
015D:  DATA 6C,10
015E:  DATA F0,30
015F:  DATA E3,35
0160:  DATA 73,10
0161:  DATA E3,37
0162:  DATA EC,37
0163:  DATA 75,39
0164:  DATA 3A,10
0165:  DATA A5,3A
0166:  DATA 20,1E
0167:  DATA 2D,1F
0168:  DATA A0,12
0169:  DATA 75,00
016A:  DATA 42,36
016B:  DATA 69,37
016C:  DATA 6B,10
016D:  DATA A5,3A
016E:  DATA 20,38
016F:  DATA E1,31
0170:  DATA 6B,10
0171:  DATA E3,37
0172:  DATA EC,37
0173:  DATA 75,39
0174:  DATA 3A,10
0175:  DATA A5,3A
0176:  DATA 20,1E
0177:  DATA 2D,1F
0178:  DATA A0,12
0179:  DATA 75,00
017A:  DATA D3,32
017B:  DATA 74,10
017C:  DATA E2,30
017D:  DATA E3,35
017E:  DATA EC,34
017F:  DATA 67,34
0180:  DATA 74,10
0181:  DATA A5,3A
0182:  DATA 00,01
0183:  DATA CD,37
0184:  DATA F4,37
0185:  DATA 72,10
0186:  DATA E7,37
0187:  DATA F4,37
0188:  DATA A0,12
0189:  DATA AE,19
018A:  DATA E6,12
018B:  DATA 25,00
018C:  DATA CD,37
018D:  DATA F4,37
018E:  DATA 72,10
018F:  DATA E7,37
0190:  DATA F4,37
0191:  DATA A0,12
0192:  DATA AE,19
0193:  DATA E6,12
0194:  DATA 25,00
0195:  DATA C3,20
0196:  DATA CC,24
0197:  DATA 42,29
0198:  DATA 41,2A
0199:  DATA 45,00
019A:  DATA C8,26
019B:  DATA 49,10
019C:  DATA F7,30
019D:  DATA 73,10
019E:  DATA E2,3A
019F:  DATA F3,39
01A0:  DATA 79,10
01A1:  DATA 61,37
01A2:  DATA 64,10
01A3:  DATA E4,37
01A4:  DATA 20,37
01A5:  DATA 6F,3A
01A6:  DATA 20,3A
01A7:  DATA EF,37
01A8:  DATA 6B,10
01A9:  DATA 69,19
01AA:  DATA 63,10
01AB:  DATA E4,30
01AC:  DATA F4,30
01AD:  DATA A1,10
01AE:  DATA 21,10
01AF:  DATA 00,01
01B0:  DATA 43,34
01B1:  DATA 61,37
01B2:  DATA E7,32
01B3:  DATA A0,36
01B4:  DATA E3,3A
01B5:  DATA A0,34
01B6:  DATA B2,31
01B7:  DATA A0,32
01B8:  DATA EE,33
01B9:  DATA 69,37
01BA:  DATA 65,10
01BB:  DATA 27,24
01BC:  DATA CD,24
01BD:  DATA DF,39
01BE:  DATA 6F,33
01BF:  DATA F4,3B
01C0:  DATA 61,39
01C1:  DATA E5,2F
01C2:  DATA E4,32
01C3:  DATA EC,30
01C4:  DATA F9,2F
01C5:  DATA ED,39
01C6:  DATA 27,10
01C7:  DATA F0,30
01C8:  DATA F2,30
01C9:  DATA ED,32
01CA:  DATA F4,32
01CB:  DATA 72,00
01CC:  DATA CE,37
01CD:  DATA 74,10
01CE:  DATA 6B,37
01CF:  DATA EF,3B
01D0:  DATA 6E,00
01D1:  DATA CE,32
01D2:  DATA 77,10
01D3:  DATA E7,37
01D4:  DATA F4,37
01D5:  DATA 3A,10
01D6:  DATA 25,26
01D7:  DATA 75,00
01D8:  DATA C3,30
01D9:  DATA EC,34
01DA:  DATA 62,39
01DB:  DATA 61,3A
01DC:  DATA E9,37
01DD:  DATA 6E,10
01DE:  DATA E6,34
01DF:  DATA EE,34
01E0:  DATA 73,34
01E1:  DATA 65,32
01E2:  DATA A0,3B
01E3:  DATA 69,3A
01E4:  DATA 68,10
01E5:  DATA 30,10
01E6:  DATA BC,16
01E7:  DATA 2D,1F
01E8:  DATA A0,12
01E9:  DATA CC,3A
01EA:  DATA A0,39
01EB:  DATA F4,32
01EC:  DATA F0,39
01ED:  DATA 00,01
01EE:  DATA C3,30
01EF:  DATA 72,39
01F0:  DATA E9,30
01F1:  DATA E7,32
01F2:  DATA A0,39
01F3:  DATA F4,37
01F4:  DATA 70,38
01F5:  DATA 65,32
01F6:  DATA A0,30
01F7:  DATA 74,10
01F8:  DATA 25,26
01F9:  DATA 75,10
01FA:  DATA 73,3A
01FB:  DATA 65,38
01FC:  DATA 2E,00
01FD:  DATA 47,3A
01FE:  DATA 53,17
01FF:  DATA 0D,05
0200:  DATA 00,00
*
0225:  MOVF   0B,W
0226:  BSF    03.5
0227:  MOVWF  3B
0228:  BCF    03.5
0229:  BCF    0B.7
022A:  BSF    03.5
022B:  BSF    03.6
022C:  BSF    0C.7
022D:  BSF    0C.0
022E:  NOP
022F:  NOP
0230:  BCF    03.6
0231:  BTFSS  3B.7
0232:  GOTO   236
0233:  BCF    03.5
0234:  BSF    0B.7
0235:  BSF    03.5
0236:  BCF    03.5
0237:  BSF    03.6
0238:  MOVF   0C,F
0239:  BTFSC  03.2
023A:  GOTO   25E
023B:  MOVF   0D,W
023C:  BSF    03.5
023D:  BCF    03.6
023E:  MOVWF  3B
023F:  BCF    03.5
0240:  BSF    03.6
0241:  MOVF   0F,W
0242:  BSF    03.5
0243:  BCF    03.6
0244:  MOVWF  3C
0245:  BCF    03.5
0246:  BSF    03.6
0247:  MOVF   0C,W
0248:  BSF    03.5
0249:  BCF    03.6
024A:  MOVWF  48
024B:  BCF    03.5
024C:  CALL   201
024D:  BSF    03.5
024E:  MOVF   3B,W
024F:  BCF    03.5
0250:  BSF    03.6
0251:  MOVWF  0D
0252:  BSF    03.5
0253:  BCF    03.6
0254:  MOVF   3C,W
0255:  BCF    03.5
0256:  BSF    03.6
0257:  MOVWF  0F
0258:  INCF   0D,F
0259:  BTFSC  03.2
025A:  INCF   0F,F
025B:  BCF    03.6
025C:  GOTO   225
025D:  BSF    03.6
025E:  BCF    03.6
025F:  BCF    0A.3
0260:  BSF    0A.4
0261:  GOTO   05C (RETURN)
*
0352:  MOVF   0B,W
0353:  BSF    03.5
0354:  MOVWF  3B
0355:  BCF    03.5
0356:  BCF    0B.7
0357:  BSF    03.5
0358:  BSF    03.6
0359:  BSF    0C.7
035A:  BSF    0C.0
035B:  NOP
035C:  NOP
035D:  BCF    03.6
035E:  BTFSS  3B.7
035F:  GOTO   363
0360:  BCF    03.5
0361:  BSF    0B.7
0362:  BSF    03.5
0363:  BCF    03.5
0364:  BSF    03.6
0365:  MOVF   0C,W
0366:  ANDLW  7F
0367:  BTFSC  03.2
0368:  GOTO   3C4
0369:  BSF    03.5
036A:  BCF    03.6
036B:  MOVWF  3B
036C:  BCF    03.5
036D:  BSF    03.6
036E:  MOVF   0D,W
036F:  BSF    03.5
0370:  BCF    03.6
0371:  MOVWF  3C
0372:  BCF    03.5
0373:  BSF    03.6
0374:  MOVF   0F,W
0375:  BSF    03.5
0376:  BCF    03.6
0377:  MOVWF  3D
0378:  MOVF   3B,W
0379:  MOVWF  48
037A:  BCF    03.5
037B:  CALL   201
037C:  BSF    03.5
037D:  MOVF   3C,W
037E:  BCF    03.5
037F:  BSF    03.6
0380:  MOVWF  0D
0381:  BSF    03.5
0382:  BCF    03.6
0383:  MOVF   3D,W
0384:  BCF    03.5
0385:  BSF    03.6
0386:  MOVWF  0F
0387:  BCF    03.6
0388:  MOVF   0B,W
0389:  BSF    03.5
038A:  MOVWF  3E
038B:  BCF    03.5
038C:  BCF    0B.7
038D:  BSF    03.5
038E:  BSF    03.6
038F:  BSF    0C.7
0390:  BSF    0C.0
0391:  NOP
0392:  NOP
0393:  BCF    03.6
0394:  BTFSS  3E.7
0395:  GOTO   399
0396:  BCF    03.5
0397:  BSF    0B.7
0398:  BSF    03.5
0399:  BCF    03.5
039A:  BSF    03.6
039B:  RLF    0C,W
039C:  RLF    0E,W
039D:  ANDLW  7F
039E:  BTFSC  03.2
039F:  GOTO   3C4
03A0:  BSF    03.5
03A1:  BCF    03.6
03A2:  MOVWF  3B
03A3:  BCF    03.5
03A4:  BSF    03.6
03A5:  MOVF   0D,W
03A6:  BSF    03.5
03A7:  BCF    03.6
03A8:  MOVWF  3C
03A9:  BCF    03.5
03AA:  BSF    03.6
03AB:  MOVF   0F,W
03AC:  BSF    03.5
03AD:  BCF    03.6
03AE:  MOVWF  3D
03AF:  MOVF   3B,W
03B0:  MOVWF  48
03B1:  BCF    03.5
03B2:  CALL   201
03B3:  BSF    03.5
03B4:  MOVF   3C,W
03B5:  BCF    03.5
03B6:  BSF    03.6
03B7:  MOVWF  0D
03B8:  BSF    03.5
03B9:  BCF    03.6
03BA:  MOVF   3D,W
03BB:  BCF    03.5
03BC:  BSF    03.6
03BD:  MOVWF  0F
03BE:  INCF   0D,F
03BF:  BTFSC  03.2
03C0:  INCF   0F,F
03C1:  BCF    03.6
03C2:  GOTO   352
03C3:  BSF    03.6
03C4:  BCF    03.6
03C5:  RETURN
*
0444:  BSF    03.5
0445:  MOVF   41,W
0446:  ANDLW  07
0447:  MOVWF  77
0448:  RRF    41,W
0449:  MOVWF  78
044A:  RRF    78,F
044B:  RRF    78,F
044C:  MOVLW  1F
044D:  ANDWF  78,F
044E:  MOVF   78,W
044F:  ADDWF  43,W
0450:  MOVWF  04
0451:  BCF    03.7
0452:  BTFSC  44.0
0453:  BSF    03.7
0454:  CLRF   78
0455:  INCF   78,F
0456:  INCF   77,F
0457:  GOTO   459
0458:  RLF    78,F
0459:  DECFSZ 77,F
045A:  GOTO   458
045B:  MOVF   42,F
045C:  BTFSC  03.2
045D:  GOTO   461
045E:  MOVF   78,W
045F:  IORWF  00,F
0460:  GOTO   464
0461:  COMF   78,F
0462:  MOVF   78,W
0463:  ANDWF  00,F
0464:  BCF    03.5
0465:  RETURN
*
0525:  MOVF   0B,W
0526:  BSF    03.5
0527:  MOVWF  3C
0528:  BCF    03.5
0529:  BCF    0B.7
052A:  BSF    03.5
052B:  BSF    03.6
052C:  BSF    0C.7
052D:  BSF    0C.0
052E:  NOP
052F:  NOP
0530:  BCF    03.6
0531:  BTFSS  3C.7
0532:  GOTO   536
0533:  BCF    03.5
0534:  BSF    0B.7
0535:  BSF    03.5
0536:  BTFSC  03.0
0537:  GOTO   56F
0538:  BCF    03.5
0539:  BSF    03.6
053A:  MOVF   0C,W
053B:  ANDLW  7F
053C:  BSF    03.5
053D:  BCF    03.6
053E:  MOVWF  3C
053F:  BCF    03.5
0540:  BSF    03.6
0541:  MOVF   0D,W
0542:  BSF    03.5
0543:  BCF    03.6
0544:  MOVWF  3D
0545:  BCF    03.5
0546:  BSF    03.6
0547:  MOVF   0F,W
0548:  BSF    03.5
0549:  BCF    03.6
054A:  MOVWF  3E
054B:  MOVF   3C,W
054C:  MOVWF  48
054D:  BCF    03.5
054E:  CALL   201
054F:  BSF    03.5
0550:  MOVF   3D,W
0551:  BCF    03.5
0552:  BSF    03.6
0553:  MOVWF  0D
0554:  BSF    03.5
0555:  BCF    03.6
0556:  MOVF   3E,W
0557:  BCF    03.5
0558:  BSF    03.6
0559:  MOVWF  0F
055A:  BCF    03.6
055B:  MOVF   0B,W
055C:  BSF    03.5
055D:  MOVWF  3F
055E:  BCF    03.5
055F:  BCF    0B.7
0560:  BSF    03.5
0561:  BSF    03.6
0562:  BSF    0C.7
0563:  BSF    0C.0
0564:  NOP
0565:  NOP
0566:  BCF    03.6
0567:  BTFSS  3F.7
0568:  GOTO   56C
0569:  BCF    03.5
056A:  BSF    0B.7
056B:  BSF    03.5
056C:  DECFSZ 3B,F
056D:  GOTO   56F
056E:  GOTO   59D
056F:  BCF    03.5
0570:  BSF    03.6
0571:  RLF    0C,W
0572:  RLF    0E,W
0573:  ANDLW  7F
0574:  BSF    03.5
0575:  BCF    03.6
0576:  MOVWF  3C
0577:  BCF    03.5
0578:  BSF    03.6
0579:  MOVF   0D,W
057A:  BSF    03.5
057B:  BCF    03.6
057C:  MOVWF  3D
057D:  BCF    03.5
057E:  BSF    03.6
057F:  MOVF   0F,W
0580:  BSF    03.5
0581:  BCF    03.6
0582:  MOVWF  3E
0583:  MOVF   3C,W
0584:  MOVWF  48
0585:  BCF    03.5
0586:  CALL   201
0587:  BSF    03.5
0588:  MOVF   3D,W
0589:  BCF    03.5
058A:  BSF    03.6
058B:  MOVWF  0D
058C:  BSF    03.5
058D:  BCF    03.6
058E:  MOVF   3E,W
058F:  BCF    03.5
0590:  BSF    03.6
0591:  MOVWF  0F
0592:  INCF   0D,F
0593:  BTFSC  03.2
0594:  INCF   0F,F
0595:  BCF    03.0
0596:  BSF    03.5
0597:  BCF    03.6
0598:  DECFSZ 3B,F
0599:  GOTO   59B
059A:  GOTO   59D
059B:  BCF    03.5
059C:  GOTO   525
059D:  BCF    03.5
059E:  RETURN
059F:  BSF    03.5
05A0:  BTFSC  3C.7
05A1:  GOTO   5B4
05A2:  MOVLW  0F
05A3:  MOVWF  77
05A4:  SWAPF  3B,W
05A5:  ANDWF  77,F
05A6:  MOVLW  0A
05A7:  SUBWF  77,W
05A8:  BTFSC  03.0
05A9:  GOTO   5AD
05AA:  MOVLW  30
05AB:  ADDWF  77,F
05AC:  GOTO   5AF
05AD:  MOVF   3C,W
05AE:  ADDWF  77,F
05AF:  MOVF   77,W
05B0:  MOVWF  48
05B1:  BCF    03.5
05B2:  CALL   201
05B3:  BSF    03.5
05B4:  MOVLW  0F
05B5:  ANDWF  3B,F
05B6:  MOVLW  0A
05B7:  SUBWF  3B,W
05B8:  BTFSC  03.0
05B9:  GOTO   5BC
05BA:  MOVLW  30
05BB:  GOTO   5BE
05BC:  BCF    3C.7
05BD:  MOVF   3C,W
05BE:  ADDWF  3B,F
05BF:  MOVF   3B,W
05C0:  MOVWF  48
05C1:  BCF    03.5
05C2:  CALL   201
05C3:  BCF    0A.3
05C4:  BSF    0A.4
05C5:  GOTO   107 (RETURN)
*
05E3:  BSF    03.5
05E4:  MOVF   3E,W
05E5:  CLRF   78
05E6:  SUBWF  3D,W
05E7:  BTFSC  03.0
05E8:  GOTO   5EC
05E9:  MOVF   3D,W
05EA:  MOVWF  77
05EB:  GOTO   5F8
05EC:  CLRF   77
05ED:  MOVLW  08
05EE:  MOVWF  3F
05EF:  RLF    3D,F
05F0:  RLF    77,F
05F1:  MOVF   3E,W
05F2:  SUBWF  77,W
05F3:  BTFSC  03.0
05F4:  MOVWF  77
05F5:  RLF    78,F
05F6:  DECFSZ 3F,F
05F7:  GOTO   5EF
05F8:  BCF    03.5
05F9:  RETURN
05FA:  MOVF   78,W
05FB:  BSF    03.5
05FC:  MOVF   3B,W
05FD:  MOVWF  3D
05FE:  MOVLW  64
05FF:  MOVWF  3E
0600:  BCF    03.5
0601:  CALL   5E3
0602:  MOVF   77,W
0603:  BSF    03.5
0604:  MOVWF  3B
0605:  MOVF   78,W
0606:  MOVLW  30
0607:  BTFSS  03.2
0608:  GOTO   610
0609:  BTFSS  3C.1
060A:  GOTO   619
060B:  BTFSC  3C.3
060C:  GOTO   619
060D:  BTFSC  3C.4
060E:  MOVLW  20
060F:  GOTO   613
0610:  BCF    3C.3
0611:  BCF    3C.4
0612:  BSF    3C.0
0613:  ADDWF  78,F
0614:  MOVF   78,W
0615:  MOVWF  48
0616:  BCF    03.5
0617:  CALL   201
0618:  BSF    03.5
0619:  MOVF   3B,W
061A:  MOVWF  3D
061B:  MOVLW  0A
061C:  MOVWF  3E
061D:  BCF    03.5
061E:  CALL   5E3
061F:  MOVF   77,W
0620:  BSF    03.5
0621:  MOVWF  3B
0622:  MOVF   78,W
0623:  MOVLW  30
0624:  BTFSS  03.2
0625:  GOTO   62C
0626:  BTFSC  3C.3
0627:  GOTO   632
0628:  BTFSS  3C.0
0629:  GOTO   632
062A:  BTFSC  3C.4
062B:  MOVLW  20
062C:  ADDWF  78,F
062D:  MOVF   78,W
062E:  MOVWF  48
062F:  BCF    03.5
0630:  CALL   201
0631:  BSF    03.5
0632:  MOVLW  30
0633:  ADDWF  3B,F
0634:  MOVF   3B,W
0635:  MOVWF  48
0636:  BCF    03.5
0637:  CALL   201
0638:  RETURN
*
0654:  BSF    03.5
0655:  MOVF   48,W
0656:  BTFSC  03.2
0657:  GOTO   6C5
0658:  MOVWF  50
0659:  MOVF   4C,W
065A:  BTFSC  03.2
065B:  GOTO   6C5
065C:  ADDWF  50,F
065D:  BTFSC  03.0
065E:  GOTO   666
065F:  MOVLW  7F
0660:  SUBWF  50,F
0661:  BTFSS  03.0
0662:  GOTO   6C5
0663:  BTFSC  03.2
0664:  GOTO   6C5
0665:  GOTO   66A
0666:  MOVLW  81
0667:  ADDWF  50,F
0668:  BTFSC  03.0
0669:  GOTO   6C5
066A:  MOVF   50,W
066B:  MOVWF  77
066C:  CLRF   78
066D:  CLRF   79
066E:  CLRF   7A
066F:  MOVF   49,W
0670:  MOVWF  54
0671:  BSF    54.7
0672:  MOVF   4A,W
0673:  MOVWF  53
0674:  MOVF   4B,W
0675:  MOVWF  52
0676:  MOVLW  18
0677:  MOVWF  50
0678:  CLRF   51
0679:  BTFSS  52.0
067A:  GOTO   693
067B:  MOVF   4F,W
067C:  ADDWF  7A,F
067D:  BTFSS  03.0
067E:  GOTO   685
067F:  INCF   79,F
0680:  BTFSS  03.2
0681:  GOTO   685
0682:  INCF   78,F
0683:  BTFSC  03.2
0684:  BSF    51.7
0685:  MOVF   4E,W
0686:  ADDWF  79,F
0687:  BTFSS  03.0
0688:  GOTO   68C
0689:  INCF   78,F
068A:  BTFSC  03.2
068B:  BSF    51.7
068C:  MOVF   4D,W
068D:  MOVWF  4A
068E:  BSF    4A.7
068F:  MOVF   4A,W
0690:  ADDWF  78,F
0691:  BTFSC  03.0
0692:  BSF    51.7
0693:  RLF    51,F
0694:  RRF    78,F
0695:  RRF    79,F
0696:  RRF    7A,F
0697:  RRF    54,F
0698:  RRF    53,F
0699:  RRF    52,F
069A:  BCF    03.0
069B:  DECFSZ 50,F
069C:  GOTO   678
069D:  MOVLW  01
069E:  ADDWF  77,F
069F:  BTFSC  03.0
06A0:  GOTO   6C5
06A1:  BTFSC  78.7
06A2:  GOTO   6AA
06A3:  RLF    54,F
06A4:  RLF    7A,F
06A5:  RLF    79,F
06A6:  RLF    78,F
06A7:  DECF   77,F
06A8:  BTFSC  03.2
06A9:  GOTO   6C5
06AA:  BTFSS  54.7
06AB:  GOTO   6BB
06AC:  INCF   7A,F
06AD:  BTFSS  03.2
06AE:  GOTO   6BB
06AF:  INCF   79,F
06B0:  BTFSS  03.2
06B1:  GOTO   6BB
06B2:  INCF   78,F
06B3:  BTFSS  03.2
06B4:  GOTO   6BB
06B5:  RRF    78,F
06B6:  RRF    79,F
06B7:  RRF    7A,F
06B8:  INCF   77,F
06B9:  BTFSC  03.2
06BA:  GOTO   6C5
06BB:  MOVF   49,W
06BC:  MOVWF  51
06BD:  MOVF   4D,W
06BE:  XORWF  51,F
06BF:  BTFSS  51.7
06C0:  GOTO   6C3
06C1:  BSF    78.7
06C2:  GOTO   6C9
06C3:  BCF    78.7
06C4:  GOTO   6C9
06C5:  CLRF   77
06C6:  CLRF   78
06C7:  CLRF   79
06C8:  CLRF   7A
06C9:  BCF    03.5
06CA:  RETURN
06CB:  BSF    03.5
06CC:  MOVF   48,W
06CD:  SUBLW  B6
06CE:  MOVWF  48
06CF:  CLRF   7A
06D0:  MOVF   49,W
06D1:  MOVWF  4C
06D2:  BSF    49.7
06D3:  BCF    03.0
06D4:  RRF    49,F
06D5:  RRF    4A,F
06D6:  RRF    4B,F
06D7:  RRF    7A,F
06D8:  RRF    79,F
06D9:  RRF    78,F
06DA:  RRF    77,F
06DB:  DECFSZ 48,F
06DC:  GOTO   6D3
06DD:  BTFSS  4C.7
06DE:  GOTO   6EA
06DF:  COMF   77,F
06E0:  COMF   78,F
06E1:  COMF   79,F
06E2:  COMF   7A,F
06E3:  INCF   77,F
06E4:  BTFSC  03.2
06E5:  INCF   78,F
06E6:  BTFSC  03.2
06E7:  INCF   79,F
06E8:  BTFSC  03.2
06E9:  INCF   7A,F
06EA:  BCF    03.5
06EB:  RETURN
06EC:  BTFSC  03.1
06ED:  GOTO   6F1
06EE:  MOVLW  D0
06EF:  MOVWF  04
06F0:  BCF    03.7
06F1:  CLRF   77
06F2:  CLRF   78
06F3:  CLRF   79
06F4:  CLRF   7A
06F5:  BSF    03.5
06F6:  CLRF   50
06F7:  CLRF   51
06F8:  CLRF   52
06F9:  CLRF   53
06FA:  MOVF   4F,W
06FB:  IORWF  4E,W
06FC:  IORWF  4D,W
06FD:  IORWF  4C,W
06FE:  BTFSC  03.2
06FF:  GOTO   730
0700:  MOVLW  20
0701:  MOVWF  54
0702:  BCF    03.0
0703:  RLF    48,F
0704:  RLF    49,F
0705:  RLF    4A,F
0706:  RLF    4B,F
0707:  RLF    50,F
0708:  RLF    51,F
0709:  RLF    52,F
070A:  RLF    53,F
070B:  MOVF   4F,W
070C:  SUBWF  53,W
070D:  BTFSS  03.2
070E:  GOTO   719
070F:  MOVF   4E,W
0710:  SUBWF  52,W
0711:  BTFSS  03.2
0712:  GOTO   719
0713:  MOVF   4D,W
0714:  SUBWF  51,W
0715:  BTFSS  03.2
0716:  GOTO   719
0717:  MOVF   4C,W
0718:  SUBWF  50,W
0719:  BTFSS  03.0
071A:  GOTO   72A
071B:  MOVF   4C,W
071C:  SUBWF  50,F
071D:  MOVF   4D,W
071E:  BTFSS  03.0
071F:  INCFSZ 4D,W
0720:  SUBWF  51,F
0721:  MOVF   4E,W
0722:  BTFSS  03.0
0723:  INCFSZ 4E,W
0724:  SUBWF  52,F
0725:  MOVF   4F,W
0726:  BTFSS  03.0
0727:  INCFSZ 4F,W
0728:  SUBWF  53,F
0729:  BSF    03.0
072A:  RLF    77,F
072B:  RLF    78,F
072C:  RLF    79,F
072D:  RLF    7A,F
072E:  DECFSZ 54,F
072F:  GOTO   702
0730:  MOVF   50,W
0731:  MOVWF  00
0732:  INCF   04,F
0733:  MOVF   51,W
0734:  MOVWF  00
0735:  INCF   04,F
0736:  MOVF   52,W
0737:  MOVWF  00
0738:  INCF   04,F
0739:  MOVF   53,W
073A:  MOVWF  00
073B:  BCF    03.5
073C:  RETURN
073D:  MOVLW  B6
073E:  MOVWF  77
073F:  CLRF   7A
0740:  CLRF   79
0741:  CLRF   78
0742:  BSF    03.5
0743:  MOVF   3F,W
0744:  IORWF  40,W
0745:  IORWF  41,W
0746:  IORWF  42,W
0747:  BTFSS  03.2
0748:  GOTO   74B
0749:  CLRF   77
074A:  GOTO   758
074B:  BCF    03.0
074C:  BTFSC  78.7
074D:  GOTO   757
074E:  RLF    3F,F
074F:  RLF    40,F
0750:  RLF    41,F
0751:  RLF    42,F
0752:  RLF    7A,F
0753:  RLF    79,F
0754:  RLF    78,F
0755:  DECFSZ 77,F
0756:  GOTO   74B
0757:  BCF    78.7
0758:  BCF    03.5
0759:  RETURN
*
07CB:  MOVLW  8E
07CC:  MOVWF  77
07CD:  BSF    03.5
07CE:  MOVF   3E,W
07CF:  MOVWF  78
07D0:  MOVF   3D,W
07D1:  MOVWF  79
07D2:  CLRF   7A
07D3:  MOVF   78,F
07D4:  BTFSS  03.2
07D5:  GOTO   7E0
07D6:  MOVF   79,W
07D7:  MOVWF  78
07D8:  CLRF   79
07D9:  MOVLW  08
07DA:  SUBWF  77,F
07DB:  MOVF   78,F
07DC:  BTFSS  03.2
07DD:  GOTO   7E0
07DE:  CLRF   77
07DF:  GOTO   7E8
07E0:  BCF    03.0
07E1:  BTFSC  78.7
07E2:  GOTO   7E7
07E3:  RLF    79,F
07E4:  RLF    78,F
07E5:  DECF   77,F
07E6:  GOTO   7E0
07E7:  BCF    78.7
07E8:  BCF    03.5
07E9:  BCF    0A.3
07EA:  BSF    0A.4
07EB:  GOTO   546 (RETURN)
*
0800:  MOVF   04,W
0801:  BSF    03.5
0802:  MOVWF  40
0803:  MOVF   3F,W
0804:  MOVWF  42
0805:  BTFSC  03.2
0806:  GOTO   024
0807:  MOVF   3E,W
0808:  MOVWF  4B
0809:  MOVF   3D,W
080A:  MOVWF  4A
080B:  MOVF   3C,W
080C:  MOVWF  49
080D:  MOVF   3B,W
080E:  MOVWF  48
080F:  CLRF   4F
0810:  CLRF   4E
0811:  MOVLW  20
0812:  MOVWF  4D
0813:  MOVLW  82
0814:  MOVWF  4C
0815:  BCF    0A.3
0816:  BCF    03.5
0817:  CALL   654
0818:  BSF    0A.3
0819:  MOVF   7A,W
081A:  BSF    03.5
081B:  MOVWF  3E
081C:  MOVF   79,W
081D:  MOVWF  3D
081E:  MOVF   78,W
081F:  MOVWF  3C
0820:  MOVF   77,W
0821:  MOVWF  3B
0822:  DECFSZ 42,F
0823:  GOTO   007
0824:  MOVF   3E,W
0825:  MOVWF  4B
0826:  MOVF   3D,W
0827:  MOVWF  4A
0828:  MOVF   3C,W
0829:  MOVWF  49
082A:  MOVF   3B,W
082B:  MOVWF  48
082C:  BCF    0A.3
082D:  BCF    03.5
082E:  CALL   6CB
082F:  BSF    0A.3
0830:  MOVF   7A,W
0831:  BSF    03.5
0832:  MOVWF  3E
0833:  MOVF   79,W
0834:  MOVWF  3D
0835:  MOVF   78,W
0836:  MOVWF  3C
0837:  MOVF   77,W
0838:  MOVWF  3B
0839:  BTFSS  3E.7
083A:  GOTO   048
083B:  DECF   40,F
083C:  BSF    40.5
083D:  COMF   3B,F
083E:  COMF   3C,F
083F:  COMF   3D,F
0840:  COMF   3E,F
0841:  INCF   3B,F
0842:  BTFSC  03.2
0843:  INCF   3C,F
0844:  BTFSC  03.2
0845:  INCF   3D,F
0846:  BTFSC  03.2
0847:  INCF   3E,F
0848:  MOVLW  3B
0849:  MOVWF  47
084A:  MOVLW  9A
084B:  MOVWF  46
084C:  MOVLW  CA
084D:  MOVWF  45
084E:  CLRF   44
084F:  MOVLW  0A
0850:  MOVWF  42
0851:  MOVF   3F,W
0852:  BTFSC  03.2
0853:  INCF   40,F
0854:  BSF    03.1
0855:  MOVLW  BB
0856:  MOVWF  04
0857:  BCF    03.7
0858:  MOVF   3E,W
0859:  MOVWF  4B
085A:  MOVF   3D,W
085B:  MOVWF  4A
085C:  MOVF   3C,W
085D:  MOVWF  49
085E:  MOVF   3B,W
085F:  MOVWF  48
0860:  MOVF   47,W
0861:  MOVWF  4F
0862:  MOVF   46,W
0863:  MOVWF  4E
0864:  MOVF   45,W
0865:  MOVWF  4D
0866:  MOVF   44,W
0867:  MOVWF  4C
0868:  BCF    0A.3
0869:  BCF    03.5
086A:  CALL   6EC
086B:  BSF    0A.3
086C:  MOVF   78,W
086D:  MOVF   77,F
086E:  BTFSS  03.2
086F:  GOTO   087
0870:  BSF    03.5
0871:  INCF   3F,W
0872:  SUBWF  42,W
0873:  BTFSS  03.2
0874:  GOTO   077
0875:  BCF    03.5
0876:  GOTO   087
0877:  MOVF   40,W
0878:  BTFSC  03.2
0879:  GOTO   08A
087A:  ANDLW  0F
087B:  SUBWF  42,W
087C:  BTFSC  03.2
087D:  GOTO   080
087E:  BTFSC  03.0
087F:  GOTO   0CA
0880:  BTFSC  40.7
0881:  GOTO   0CA
0882:  BTFSC  40.6
0883:  GOTO   08A
0884:  MOVLW  20
0885:  GOTO   0C2
0886:  BCF    03.5
0887:  MOVLW  20
0888:  BSF    03.5
0889:  ANDWF  40,F
088A:  BTFSS  40.5
088B:  GOTO   09C
088C:  BCF    40.5
088D:  MOVF   3F,W
088E:  BTFSS  03.2
088F:  DECF   40,F
0890:  MOVF   77,W
0891:  MOVWF  40
0892:  MOVLW  2D
0893:  MOVWF  48
0894:  BCF    0A.3
0895:  BCF    03.5
0896:  CALL   201
0897:  BSF    0A.3
0898:  BSF    03.5
0899:  MOVF   40,W
089A:  MOVWF  77
089B:  CLRF   40
089C:  MOVF   3F,W
089D:  SUBWF  42,W
089E:  BTFSS  03.2
089F:  GOTO   0AE
08A0:  MOVF   77,W
08A1:  MOVWF  40
08A2:  MOVLW  2E
08A3:  MOVWF  48
08A4:  BCF    0A.3
08A5:  BCF    03.5
08A6:  CALL   201
08A7:  BSF    0A.3
08A8:  BSF    03.5
08A9:  MOVF   40,W
08AA:  MOVWF  77
08AB:  MOVLW  20
08AC:  ANDWF  40,F
08AD:  MOVLW  00
08AE:  MOVLW  30
08AF:  BTFSS  40.5
08B0:  GOTO   0C2
08B1:  BCF    40.5
08B2:  MOVF   3F,W
08B3:  BTFSS  03.2
08B4:  DECF   40,F
08B5:  MOVF   77,W
08B6:  MOVWF  40
08B7:  MOVLW  2D
08B8:  MOVWF  48
08B9:  BCF    0A.3
08BA:  BCF    03.5
08BB:  CALL   201
08BC:  BSF    0A.3
08BD:  BSF    03.5
08BE:  MOVF   40,W
08BF:  MOVWF  77
08C0:  CLRF   40
08C1:  MOVLW  30
08C2:  ADDWF  77,F
08C3:  MOVF   77,W
08C4:  MOVWF  48
08C5:  BCF    0A.3
08C6:  BCF    03.5
08C7:  CALL   201
08C8:  BSF    0A.3
08C9:  BSF    03.5
08CA:  BCF    03.1
08CB:  MOVF   47,W
08CC:  MOVWF  4B
08CD:  MOVF   46,W
08CE:  MOVWF  4A
08CF:  MOVF   45,W
08D0:  MOVWF  49
08D1:  MOVF   44,W
08D2:  MOVWF  48
08D3:  CLRF   4F
08D4:  CLRF   4E
08D5:  CLRF   4D
08D6:  MOVLW  0A
08D7:  MOVWF  4C
08D8:  BCF    0A.3
08D9:  BCF    03.5
08DA:  CALL   6EC
08DB:  BSF    0A.3
08DC:  MOVF   7A,W
08DD:  BSF    03.5
08DE:  MOVWF  47
08DF:  MOVF   79,W
08E0:  MOVWF  46
08E1:  MOVF   78,W
08E2:  MOVWF  45
08E3:  MOVF   77,W
08E4:  MOVWF  44
08E5:  DECFSZ 42,F
08E6:  GOTO   054
08E7:  BCF    03.5
08E8:  RETURN
08E9:  BSF    03.5
08EA:  MOVF   4B,W
08EB:  BTFSC  03.2
08EC:  GOTO   1AF
08ED:  MOVWF  57
08EE:  MOVF   4F,W
08EF:  BTFSC  03.2
08F0:  GOTO   1AF
08F1:  SUBWF  57,F
08F2:  BTFSS  03.0
08F3:  GOTO   0F9
08F4:  MOVLW  7F
08F5:  ADDWF  57,F
08F6:  BTFSC  03.0
08F7:  GOTO   1AF
08F8:  GOTO   0FF
08F9:  MOVLW  81
08FA:  SUBWF  57,F
08FB:  BTFSS  03.0
08FC:  GOTO   1AF
08FD:  BTFSC  03.2
08FE:  GOTO   1AF
08FF:  MOVF   57,W
0900:  MOVWF  77
0901:  CLRF   78
0902:  CLRF   79
0903:  CLRF   7A
0904:  CLRF   56
0905:  MOVF   4C,W
0906:  MOVWF  55
0907:  BSF    55.7
0908:  MOVF   4D,W
0909:  MOVWF  54
090A:  MOVF   4E,W
090B:  MOVWF  53
090C:  MOVLW  19
090D:  MOVWF  57
090E:  MOVF   52,W
090F:  SUBWF  53,F
0910:  BTFSC  03.0
0911:  GOTO   122
0912:  MOVLW  01
0913:  SUBWF  54,F
0914:  BTFSC  03.0
0915:  GOTO   122
0916:  SUBWF  55,F
0917:  BTFSC  03.0
0918:  GOTO   122
0919:  SUBWF  56,F
091A:  BTFSC  03.0
091B:  GOTO   122
091C:  INCF   56,F
091D:  INCF   55,F
091E:  INCF   54,F
091F:  MOVF   52,W
0920:  ADDWF  53,F
0921:  GOTO   154
0922:  MOVF   51,W
0923:  SUBWF  54,F
0924:  BTFSC  03.0
0925:  GOTO   13D
0926:  MOVLW  01
0927:  SUBWF  55,F
0928:  BTFSC  03.0
0929:  GOTO   13D
092A:  SUBWF  56,F
092B:  BTFSC  03.0
092C:  GOTO   13D
092D:  INCF   56,F
092E:  INCF   55,F
092F:  MOVF   51,W
0930:  ADDWF  54,F
0931:  MOVF   52,W
0932:  ADDWF  53,F
0933:  BTFSS  03.0
0934:  GOTO   154
0935:  INCF   54,F
0936:  BTFSS  03.2
0937:  GOTO   154
0938:  INCF   55,F
0939:  BTFSS  03.2
093A:  GOTO   154
093B:  INCF   56,F
093C:  GOTO   154
093D:  MOVF   50,W
093E:  IORLW  80
093F:  SUBWF  55,F
0940:  BTFSC  03.0
0941:  GOTO   153
0942:  MOVLW  01
0943:  SUBWF  56,F
0944:  BTFSC  03.0
0945:  GOTO   153
0946:  INCF   56,F
0947:  MOVF   50,W
0948:  IORLW  80
0949:  ADDWF  55,F
094A:  MOVF   51,W
094B:  ADDWF  54,F
094C:  BTFSS  03.0
094D:  GOTO   131
094E:  INCF   55,F
094F:  BTFSS  03.2
0950:  GOTO   131
0951:  INCF   56,F
0952:  GOTO   131
0953:  BSF    7A.0
0954:  DECFSZ 57,F
0955:  GOTO   157
0956:  GOTO   162
0957:  BCF    03.0
0958:  RLF    53,F
0959:  RLF    54,F
095A:  RLF    55,F
095B:  RLF    56,F
095C:  BCF    03.0
095D:  RLF    7A,F
095E:  RLF    79,F
095F:  RLF    78,F
0960:  RLF    58,F
0961:  GOTO   10E
0962:  BTFSS  58.0
0963:  GOTO   16A
0964:  BCF    03.0
0965:  RRF    78,F
0966:  RRF    79,F
0967:  RRF    7A,F
0968:  RRF    58,F
0969:  GOTO   16D
096A:  DECF   77,F
096B:  BTFSC  03.2
096C:  GOTO   1AF
096D:  BTFSC  58.7
096E:  GOTO   196
096F:  BCF    03.0
0970:  RLF    53,F
0971:  RLF    54,F
0972:  RLF    55,F
0973:  RLF    56,F
0974:  MOVF   52,W
0975:  SUBWF  53,F
0976:  BTFSC  03.0
0977:  GOTO   182
0978:  MOVLW  01
0979:  SUBWF  54,F
097A:  BTFSC  03.0
097B:  GOTO   182
097C:  SUBWF  55,F
097D:  BTFSC  03.0
097E:  GOTO   182
097F:  SUBWF  56,F
0980:  BTFSS  03.0
0981:  GOTO   1A5
0982:  MOVF   51,W
0983:  SUBWF  54,F
0984:  BTFSC  03.0
0985:  GOTO   18D
0986:  MOVLW  01
0987:  SUBWF  55,F
0988:  BTFSC  03.0
0989:  GOTO   18D
098A:  SUBWF  56,F
098B:  BTFSS  03.0
098C:  GOTO   1A5
098D:  MOVF   50,W
098E:  IORLW  80
098F:  SUBWF  55,F
0990:  BTFSC  03.0
0991:  GOTO   196
0992:  MOVLW  01
0993:  SUBWF  56,F
0994:  BTFSS  03.0
0995:  GOTO   1A5
0996:  INCF   7A,F
0997:  BTFSS  03.2
0998:  GOTO   1A5
0999:  INCF   79,F
099A:  BTFSS  03.2
099B:  GOTO   1A5
099C:  INCF   78,F
099D:  BTFSS  03.2
099E:  GOTO   1A5
099F:  INCF   77,F
09A0:  BTFSC  03.2
09A1:  GOTO   1AF
09A2:  RRF    78,F
09A3:  RRF    79,F
09A4:  RRF    7A,F
09A5:  MOVF   4C,W
09A6:  MOVWF  57
09A7:  MOVF   50,W
09A8:  XORWF  57,F
09A9:  BTFSS  57.7
09AA:  GOTO   1AD
09AB:  BSF    78.7
09AC:  GOTO   1B3
09AD:  BCF    78.7
09AE:  GOTO   1B3
09AF:  CLRF   77
09B0:  CLRF   78
09B1:  CLRF   79
09B2:  CLRF   7A
09B3:  BCF    03.5
09B4:  RETURN
*
09D7:  MOVLW  80
09D8:  BTFSC  03.1
09D9:  XORWF  4C,F
09DA:  CLRF   51
09DB:  CLRF   52
09DC:  MOVF   48,W
09DD:  MOVWF  50
09DE:  MOVF   4C,W
09DF:  XORWF  50,F
09E0:  MOVF   47,W
09E1:  BTFSC  03.2
09E2:  GOTO   2C7
09E3:  MOVWF  4F
09E4:  MOVWF  77
09E5:  MOVF   4B,W
09E6:  BTFSC  03.2
09E7:  GOTO   2D0
09E8:  SUBWF  4F,F
09E9:  BTFSC  03.2
09EA:  GOTO   26C
09EB:  BTFSS  03.0
09EC:  GOTO   22A
09ED:  MOVF   4C,W
09EE:  MOVWF  55
09EF:  BSF    55.7
09F0:  MOVF   4D,W
09F1:  MOVWF  54
09F2:  MOVF   4E,W
09F3:  MOVWF  53
09F4:  CLRF   52
09F5:  BCF    03.0
09F6:  RRF    55,F
09F7:  RRF    54,F
09F8:  RRF    53,F
09F9:  RRF    52,F
09FA:  DECFSZ 4F,F
09FB:  GOTO   1F4
09FC:  BTFSS  50.7
09FD:  GOTO   201
09FE:  BSF    51.0
09FF:  GOTO   2E4
0A00:  BCF    51.0
0A01:  BCF    4F.0
0A02:  BSF    51.4
0A03:  MOVLW  CA
0A04:  MOVWF  04
0A05:  BCF    03.7
0A06:  GOTO   2F9
0A07:  BCF    51.4
0A08:  BTFSC  50.7
0A09:  GOTO   214
0A0A:  BTFSS  4F.0
0A0B:  GOTO   21F
0A0C:  RRF    55,F
0A0D:  RRF    54,F
0A0E:  RRF    53,F
0A0F:  RRF    52,F
0A10:  INCF   77,F
0A11:  BTFSC  03.2
0A12:  GOTO   2DF
0A13:  GOTO   21F
0A14:  BTFSC  55.7
0A15:  GOTO   222
0A16:  BCF    03.0
0A17:  RLF    52,F
0A18:  RLF    53,F
0A19:  RLF    54,F
0A1A:  RLF    55,F
0A1B:  DECF   77,F
0A1C:  BTFSC  03.2
0A1D:  GOTO   2DF
0A1E:  GOTO   214
0A1F:  BSF    51.6
0A20:  GOTO   28C
0A21:  BCF    51.6
0A22:  MOVF   48,W
0A23:  MOVWF  50
0A24:  BTFSS  50.7
0A25:  GOTO   228
0A26:  BSF    55.7
0A27:  GOTO   2D8
0A28:  BCF    55.7
0A29:  GOTO   2D8
0A2A:  MOVF   4B,W
0A2B:  MOVWF  4F
0A2C:  MOVWF  77
0A2D:  MOVF   47,W
0A2E:  SUBWF  4F,F
0A2F:  MOVF   48,W
0A30:  MOVWF  55
0A31:  BSF    55.7
0A32:  MOVF   49,W
0A33:  MOVWF  54
0A34:  MOVF   4A,W
0A35:  MOVWF  53
0A36:  CLRF   52
0A37:  BCF    03.0
0A38:  RRF    55,F
0A39:  RRF    54,F
0A3A:  RRF    53,F
0A3B:  RRF    52,F
0A3C:  DECFSZ 4F,F
0A3D:  GOTO   236
0A3E:  BTFSS  50.7
0A3F:  GOTO   243
0A40:  BSF    51.1
0A41:  GOTO   2E4
0A42:  BCF    51.1
0A43:  BCF    4F.0
0A44:  BSF    51.5
0A45:  MOVLW  CE
0A46:  MOVWF  04
0A47:  BCF    03.7
0A48:  GOTO   2F9
0A49:  BCF    51.5
0A4A:  BTFSC  50.7
0A4B:  GOTO   256
0A4C:  BTFSS  4F.0
0A4D:  GOTO   261
0A4E:  RRF    55,F
0A4F:  RRF    54,F
0A50:  RRF    53,F
0A51:  RRF    52,F
0A52:  INCF   77,F
0A53:  BTFSC  03.2
0A54:  GOTO   2DF
0A55:  GOTO   261
0A56:  BTFSC  55.7
0A57:  GOTO   264
0A58:  BCF    03.0
0A59:  RLF    52,F
0A5A:  RLF    53,F
0A5B:  RLF    54,F
0A5C:  RLF    55,F
0A5D:  DECF   77,F
0A5E:  BTFSC  03.2
0A5F:  GOTO   2DF
0A60:  GOTO   256
0A61:  BSF    51.7
0A62:  GOTO   28C
0A63:  BCF    51.7
0A64:  MOVF   4C,W
0A65:  MOVWF  50
0A66:  BTFSS  50.7
0A67:  GOTO   26A
0A68:  BSF    55.7
0A69:  GOTO   2D8
0A6A:  BCF    55.7
0A6B:  GOTO   2D8
0A6C:  MOVF   4C,W
0A6D:  MOVWF  55
0A6E:  BSF    55.7
0A6F:  MOVF   4D,W
0A70:  MOVWF  54
0A71:  MOVF   4E,W
0A72:  MOVWF  53
0A73:  BTFSS  50.7
0A74:  GOTO   279
0A75:  BCF    55.7
0A76:  BSF    51.2
0A77:  GOTO   2E4
0A78:  BCF    51.2
0A79:  CLRF   52
0A7A:  BCF    4F.0
0A7B:  MOVLW  CA
0A7C:  MOVWF  04
0A7D:  BCF    03.7
0A7E:  GOTO   2F9
0A7F:  BTFSC  50.7
0A80:  GOTO   2A2
0A81:  MOVF   48,W
0A82:  MOVWF  50
0A83:  BTFSS  4F.0
0A84:  GOTO   28C
0A85:  RRF    55,F
0A86:  RRF    54,F
0A87:  RRF    53,F
0A88:  RRF    52,F
0A89:  INCF   77,F
0A8A:  BTFSC  03.2
0A8B:  GOTO   2DF
0A8C:  BTFSS  52.7
0A8D:  GOTO   29D
0A8E:  INCF   53,F
0A8F:  BTFSS  03.2
0A90:  GOTO   29D
0A91:  INCF   54,F
0A92:  BTFSS  03.2
0A93:  GOTO   29D
0A94:  INCF   55,F
0A95:  BTFSS  03.2
0A96:  GOTO   29D
0A97:  RRF    55,F
0A98:  RRF    54,F
0A99:  RRF    53,F
0A9A:  INCF   77,F
0A9B:  BTFSC  03.2
0A9C:  GOTO   2DF
0A9D:  BTFSC  51.6
0A9E:  GOTO   221
0A9F:  BTFSC  51.7
0AA0:  GOTO   263
0AA1:  GOTO   2C1
0AA2:  MOVLW  80
0AA3:  XORWF  55,F
0AA4:  BTFSS  55.7
0AA5:  GOTO   2AA
0AA6:  GOTO   2E4
0AA7:  MOVF   4C,W
0AA8:  MOVWF  50
0AA9:  GOTO   2B7
0AAA:  MOVF   48,W
0AAB:  MOVWF  50
0AAC:  MOVF   55,F
0AAD:  BTFSS  03.2
0AAE:  GOTO   2B7
0AAF:  MOVF   54,F
0AB0:  BTFSS  03.2
0AB1:  GOTO   2B7
0AB2:  MOVF   53,F
0AB3:  BTFSS  03.2
0AB4:  GOTO   2B7
0AB5:  CLRF   77
0AB6:  GOTO   2D8
0AB7:  BTFSC  55.7
0AB8:  GOTO   2C1
0AB9:  BCF    03.0
0ABA:  RLF    52,F
0ABB:  RLF    53,F
0ABC:  RLF    54,F
0ABD:  RLF    55,F
0ABE:  DECFSZ 77,F
0ABF:  GOTO   2B7
0AC0:  GOTO   2DF
0AC1:  BTFSS  50.7
0AC2:  GOTO   2C5
0AC3:  BSF    55.7
0AC4:  GOTO   2D8
0AC5:  BCF    55.7
0AC6:  GOTO   2D8
0AC7:  MOVF   4B,W
0AC8:  MOVWF  77
0AC9:  MOVF   4C,W
0ACA:  MOVWF  55
0ACB:  MOVF   4D,W
0ACC:  MOVWF  54
0ACD:  MOVF   4E,W
0ACE:  MOVWF  53
0ACF:  GOTO   2D8
0AD0:  MOVF   47,W
0AD1:  MOVWF  77
0AD2:  MOVF   48,W
0AD3:  MOVWF  55
0AD4:  MOVF   49,W
0AD5:  MOVWF  54
0AD6:  MOVF   4A,W
0AD7:  MOVWF  53
0AD8:  MOVF   55,W
0AD9:  MOVWF  78
0ADA:  MOVF   54,W
0ADB:  MOVWF  79
0ADC:  MOVF   53,W
0ADD:  MOVWF  7A
0ADE:  GOTO   317
0ADF:  CLRF   77
0AE0:  CLRF   78
0AE1:  CLRF   79
0AE2:  CLRF   7A
0AE3:  GOTO   317
0AE4:  CLRF   52
0AE5:  COMF   53,F
0AE6:  COMF   54,F
0AE7:  COMF   55,F
0AE8:  COMF   52,F
0AE9:  INCF   52,F
0AEA:  BTFSS  03.2
0AEB:  GOTO   2F2
0AEC:  INCF   53,F
0AED:  BTFSS  03.2
0AEE:  GOTO   2F2
0AEF:  INCF   54,F
0AF0:  BTFSC  03.2
0AF1:  INCF   55,F
0AF2:  BTFSC  51.0
0AF3:  GOTO   200
0AF4:  BTFSC  51.1
0AF5:  GOTO   242
0AF6:  BTFSC  51.2
0AF7:  GOTO   278
0AF8:  GOTO   2A7
0AF9:  MOVF   00,W
0AFA:  ADDWF  53,F
0AFB:  BTFSS  03.0
0AFC:  GOTO   303
0AFD:  INCF   54,F
0AFE:  BTFSS  03.2
0AFF:  GOTO   303
0B00:  INCF   55,F
0B01:  BTFSC  03.2
0B02:  BSF    4F.0
0B03:  DECF   04,F
0B04:  MOVF   00,W
0B05:  ADDWF  54,F
0B06:  BTFSS  03.0
0B07:  GOTO   30B
0B08:  INCF   55,F
0B09:  BTFSC  03.2
0B0A:  BSF    4F.0
0B0B:  DECF   04,F
0B0C:  MOVF   00,W
0B0D:  BTFSS  00.7
0B0E:  XORLW  80
0B0F:  ADDWF  55,F
0B10:  BTFSC  03.0
0B11:  BSF    4F.0
0B12:  BTFSC  51.4
0B13:  GOTO   207
0B14:  BTFSC  51.5
0B15:  GOTO   249
0B16:  GOTO   27F
*
0B41:  MOVF   04,W
0B42:  BSF    03.5
0B43:  MOVWF  3F
0B44:  MOVLW  3B
0B45:  MOVWF  46
0B46:  MOVLW  9A
0B47:  MOVWF  45
0B48:  MOVLW  CA
0B49:  MOVWF  44
0B4A:  CLRF   43
0B4B:  MOVLW  0A
0B4C:  MOVWF  41
0B4D:  BSF    03.1
0B4E:  MOVLW  BB
0B4F:  MOVWF  04
0B50:  BCF    03.7
0B51:  MOVF   3E,W
0B52:  MOVWF  4B
0B53:  MOVF   3D,W
0B54:  MOVWF  4A
0B55:  MOVF   3C,W
0B56:  MOVWF  49
0B57:  MOVF   3B,W
0B58:  MOVWF  48
0B59:  MOVF   46,W
0B5A:  MOVWF  4F
0B5B:  MOVF   45,W
0B5C:  MOVWF  4E
0B5D:  MOVF   44,W
0B5E:  MOVWF  4D
0B5F:  MOVF   43,W
0B60:  MOVWF  4C
0B61:  BCF    0A.3
0B62:  BCF    03.5
0B63:  CALL   6EC
0B64:  BSF    0A.3
0B65:  MOVF   78,W
0B66:  MOVF   77,F
0B67:  BTFSS  03.2
0B68:  GOTO   380
0B69:  BSF    03.5
0B6A:  MOVF   41,W
0B6B:  XORLW  01
0B6C:  BTFSS  03.2
0B6D:  GOTO   370
0B6E:  BCF    03.5
0B6F:  GOTO   380
0B70:  MOVF   3F,W
0B71:  BTFSC  03.2
0B72:  GOTO   382
0B73:  ANDLW  0F
0B74:  SUBWF  41,W
0B75:  BTFSC  03.2
0B76:  GOTO   379
0B77:  BTFSC  03.0
0B78:  GOTO   38B
0B79:  BTFSC  3F.7
0B7A:  GOTO   38B
0B7B:  BTFSC  3F.6
0B7C:  GOTO   382
0B7D:  MOVLW  20
0B7E:  GOTO   383
0B7F:  BCF    03.5
0B80:  BSF    03.5
0B81:  CLRF   3F
0B82:  MOVLW  30
0B83:  ADDWF  77,F
0B84:  MOVF   77,W
0B85:  MOVWF  48
0B86:  BCF    0A.3
0B87:  BCF    03.5
0B88:  CALL   201
0B89:  BSF    0A.3
0B8A:  BSF    03.5
0B8B:  BCF    03.1
0B8C:  MOVF   46,W
0B8D:  MOVWF  4B
0B8E:  MOVF   45,W
0B8F:  MOVWF  4A
0B90:  MOVF   44,W
0B91:  MOVWF  49
0B92:  MOVF   43,W
0B93:  MOVWF  48
0B94:  CLRF   4F
0B95:  CLRF   4E
0B96:  CLRF   4D
0B97:  MOVLW  0A
0B98:  MOVWF  4C
0B99:  BCF    0A.3
0B9A:  BCF    03.5
0B9B:  CALL   6EC
0B9C:  BSF    0A.3
0B9D:  MOVF   7A,W
0B9E:  BSF    03.5
0B9F:  MOVWF  46
0BA0:  MOVF   79,W
0BA1:  MOVWF  45
0BA2:  MOVF   78,W
0BA3:  MOVWF  44
0BA4:  MOVF   77,W
0BA5:  MOVWF  43
0BA6:  DECFSZ 41,F
0BA7:  GOTO   34D
0BA8:  BCF    03.5
0BA9:  RETURN
0BAA:  BSF    03.5
0BAB:  MOVF   3E,W
0BAC:  MOVWF  45
0BAD:  MOVF   42,W
0BAE:  XORWF  45,F
0BAF:  BTFSS  45.7
0BB0:  GOTO   3B6
0BB1:  BCF    03.2
0BB2:  BCF    03.0
0BB3:  BTFSC  3E.7
0BB4:  BSF    03.0
0BB5:  GOTO   3E9
0BB6:  MOVF   3E,W
0BB7:  MOVWF  45
0BB8:  MOVF   41,W
0BB9:  MOVWF  46
0BBA:  MOVF   3D,W
0BBB:  SUBWF  46,F
0BBC:  BTFSC  03.2
0BBD:  GOTO   3C4
0BBE:  BTFSS  45.7
0BBF:  GOTO   3E9
0BC0:  MOVF   03,W
0BC1:  XORLW  01
0BC2:  MOVWF  03
0BC3:  GOTO   3E9
0BC4:  MOVF   42,W
0BC5:  MOVWF  46
0BC6:  MOVF   3E,W
0BC7:  SUBWF  46,F
0BC8:  BTFSC  03.2
0BC9:  GOTO   3D0
0BCA:  BTFSS  45.7
0BCB:  GOTO   3E9
0BCC:  MOVF   03,W
0BCD:  XORLW  01
0BCE:  MOVWF  03
0BCF:  GOTO   3E9
0BD0:  MOVF   43,W
0BD1:  MOVWF  46
0BD2:  MOVF   3F,W
0BD3:  SUBWF  46,F
0BD4:  BTFSC  03.2
0BD5:  GOTO   3DC
0BD6:  BTFSS  45.7
0BD7:  GOTO   3E9
0BD8:  MOVF   03,W
0BD9:  XORLW  01
0BDA:  MOVWF  03
0BDB:  GOTO   3E9
0BDC:  MOVF   44,W
0BDD:  MOVWF  46
0BDE:  MOVF   40,W
0BDF:  SUBWF  46,F
0BE0:  BTFSC  03.2
0BE1:  GOTO   3E8
0BE2:  BTFSS  45.7
0BE3:  GOTO   3E9
0BE4:  MOVF   03,W
0BE5:  XORLW  01
0BE6:  MOVWF  03
0BE7:  GOTO   3E9
0BE8:  BCF    03.0
0BE9:  BCF    03.5
0BEA:  BCF    0A.3
0BEB:  BSF    0A.4
0BEC:  GOTO   55C (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(crystal=20000000) 
*
026D:  MOVLW  BC
026E:  MOVWF  04
026F:  BCF    03.7
0270:  MOVF   00,W
0271:  BTFSC  03.2
0272:  GOTO   280
0273:  MOVLW  06
0274:  MOVWF  78
0275:  CLRF   77
0276:  DECFSZ 77,F
0277:  GOTO   276
0278:  DECFSZ 78,F
0279:  GOTO   275
027A:  MOVLW  7B
027B:  MOVWF  77
027C:  DECFSZ 77,F
027D:  GOTO   27C
027E:  DECFSZ 00,F
027F:  GOTO   273
0280:  RETURN
....................  
....................  
....................  
.................... //#if device=="PIC16F877" 
....................    #FUSES BROWNOUT   //TODO: WykasowaŠ w ostatecznej wersji programu dla gotowej p-yty MCU 
....................    #FUSES PROTECT 
....................    //#FUSES WDT 
.................... //#endif 
....................  
.................... #USE STANDARD_IO (A) 
.................... #USE STANDARD_IO (B) 
.................... #USE STANDARD_IO (C) 
.................... #USE STANDARD_IO (D) 
.................... #USE STANDARD_IO (E) 
....................  
.................... #use i2c(Slave,Fast,sda=i2c_SDA_pin,scl=i2c_SCL_pin,force_hw,address=i2c_slave_address) 
*
00D4:  BCF    03.5
00D5:  MOVF   13,W
00D6:  BSF    03.5
00D7:  MOVF   5B,W
00D8:  BCF    03.5
00D9:  MOVWF  13
00DA:  BSF    14.4
00DB:  BCF    0C.3
00DC:  BSF    03.5
00DD:  BTFSC  14.0
00DE:  GOTO   0DD
00DF:  CLRF   78
00E0:  BTFSS  11.6
00E1:  INCF   78,F
....................  
.................... //#ifndef _STEPPER_MOTOR_ON_INTERRUPTS_ 
....................    #use timer(timer=0, tick=1 ms, bits=16, NOISR, stream=Steper_motor_timer, define=TICKS_PER_SECOND_stepper) 
*
0335:  MOVF   3B,W
0336:  MOVWF  77
0337:  MOVF   3C,W
0338:  MOVWF  78
0339:  CLRF   79
033A:  BCF    03.0
033B:  RLF    77,F
033C:  RLF    78,F
033D:  RLF    79,F
033E:  BCF    03.0
033F:  RLF    77,F
0340:  RLF    78,F
0341:  RLF    79,F
0342:  BCF    03.0
0343:  RLF    77,F
0344:  RLF    78,F
0345:  RLF    79,F
0346:  BCF    03.0
0347:  RLF    77,F
0348:  RLF    78,F
0349:  RLF    79,F
034A:  MOVF   78,W
034B:  BCF    03.5
034C:  MOVWF  2C
034D:  MOVF   79,W
034E:  MOVWF  2D
034F:  MOVF   77,W
0350:  MOVWF  01
*
07AF:  MOVF   01,W
07B0:  BTFSS  0B.2
07B1:  GOTO   7B7
07B2:  INCF   2C,F
07B3:  BTFSC  03.2
07B4:  INCF   2D,F
07B5:  BCF    0B.2
07B6:  MOVF   01,W
07B7:  MOVWF  77
07B8:  MOVF   2C,W
07B9:  MOVWF  78
07BA:  MOVF   2D,W
07BB:  MOVWF  79
07BC:  RRF    79,F
07BD:  RRF    78,F
07BE:  RRF    77,F
07BF:  RRF    79,F
07C0:  RRF    78,F
07C1:  RRF    77,F
07C2:  RRF    79,F
07C3:  RRF    78,F
07C4:  RRF    77,F
07C5:  RRF    79,F
07C6:  RRF    78,F
07C7:  RRF    77,F
07C8:  BCF    0A.3
07C9:  BSF    0A.4
07CA:  GOTO   539 (RETURN)
....................    #warning STEPPER MOTOR tick per second: TICKS_PER_SECOND_stepper 
.................... //#endif 
.................... #use timer(timer=1, tick=750 ms, bits=16, NOISR, stream=LED_blink_timer, define=TICKS_PER_SECOND_led) 
*
0639:  BSF    03.5
063A:  MOVF   3B,W
063B:  MOVWF  77
063C:  MOVF   3C,W
063D:  MOVWF  78
063E:  CLRF   79
063F:  BCF    03.0
0640:  RLF    77,F
0641:  RLF    78,F
0642:  RLF    79,F
0643:  BCF    03.0
0644:  RLF    77,F
0645:  RLF    78,F
0646:  RLF    79,F
0647:  BCF    03.0
0648:  RLF    77,F
0649:  RLF    78,F
064A:  RLF    79,F
064B:  MOVF   78,W
064C:  BCF    03.5
064D:  MOVWF  2E
064E:  MOVF   79,W
064F:  MOVWF  2F
0650:  MOVF   77,W
0651:  MOVWF  0F
0652:  CLRF   0E
0653:  RETURN
*
075A:  MOVF   0F,W
075B:  MOVWF  7A
075C:  MOVF   0E,W
075D:  MOVWF  77
075E:  MOVF   0F,W
075F:  SUBWF  7A,W
0760:  BTFSS  03.2
0761:  GOTO   75A
0762:  MOVF   77,W
0763:  BTFSS  0C.0
0764:  GOTO   772
0765:  INCF   2E,F
0766:  BTFSC  03.2
0767:  INCF   2F,F
0768:  BCF    0C.0
0769:  MOVF   0F,W
076A:  MOVWF  7A
076B:  MOVF   0E,W
076C:  MOVWF  77
076D:  MOVF   0F,W
076E:  SUBWF  7A,W
076F:  BTFSS  03.2
0770:  GOTO   769
0771:  MOVF   77,W
0772:  MOVF   7A,W
0773:  MOVWF  77
0774:  MOVF   2E,W
0775:  MOVWF  78
0776:  MOVF   2F,W
0777:  MOVWF  79
0778:  RRF    79,F
0779:  RRF    78,F
077A:  RRF    77,F
077B:  RRF    79,F
077C:  RRF    78,F
077D:  RRF    77,F
077E:  RRF    79,F
077F:  RRF    78,F
0780:  RRF    77,F
....................  
.................... //#use timer(timer=1, tick=750 us, bits=8, NOISR, stream=LED_blink_timer, define=TICKS_PER_SECOND_led) 
.................... #warning LED blink tick per second: TICKS_PER_SECOND_led 
....................  
.................... #if Backlight_MAX_VAL!=1 
....................    #use timer(timer=2, tick=100 ms,bits=8, NOISR, stream=Backlight_blink_timer, define=TICKS_PER_SECOND_backlight) 
....................    #warning BACKLIGHT blink tick per second: TICKS_PER_SECOND_backlight 
.................... #endif 
....................  
.................... #if defined(DEBUG_ENABLED) 
....................    //#use rs232(ICD,stream=ICD_DBG,DISABLE_INTS) 
....................    #use rs232(baud=38400,parity=N,xmit=PIN_B7,rcv=PIN_B6,bits=8,stream=LOG_PORT, ICD) //, DISABLE_INTS) 
....................    #define dbg_return_carriage() fprintf_return_carriage() 
....................    #define dbg_printf(fmt,...)   fprintf(LOG_PORT,fmt,__VA_ARGS__); dbg_return_carriage() 
....................     
.................... #elif defined(_USE_LOGPORT_) 
....................    #use rs232(baud=38400,parity=N,xmit=PIN_B7,rcv=PIN_B6,bits=8,stream=LOG_PORT)//, DISABLE_INTS) 
*
0201:  BSF    03.5
0202:  BCF    06.7
0203:  BCF    03.5
0204:  BCF    06.7
0205:  MOVLW  08
0206:  MOVWF  78
0207:  GOTO   208
0208:  NOP
0209:  BSF    78.7
020A:  GOTO   21B
020B:  BCF    78.7
020C:  BSF    03.5
020D:  RRF    48,F
020E:  BCF    03.5
020F:  BTFSC  03.0
0210:  BSF    06.7
0211:  BTFSS  03.0
0212:  BCF    06.7
0213:  BSF    78.6
0214:  GOTO   21B
0215:  BCF    78.6
0216:  DECFSZ 78,F
0217:  GOTO   20C
0218:  GOTO   219
0219:  NOP
021A:  BSF    06.7
021B:  MOVLW  25
021C:  MOVWF  04
021D:  DECFSZ 04,F
021E:  GOTO   21D
021F:  NOP
0220:  BTFSC  78.7
0221:  GOTO   20B
0222:  BTFSC  78.6
0223:  GOTO   215
0224:  RETURN
....................    #define dbg_return_carriage() fprintf_return_carriage() 
....................    #define dbg_printf(fmt,...)   fprintf(LOG_PORT,fmt, __VA_ARGS__); dbg_return_carriage()//;  fprintf_return_carriage()//return_carrier//;  delay_ms(500) 
.................... #else 
....................    #define dbg_printf(fmt,...) 
....................    #define dbg_return_carriage() 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #use FIXED_IO( A_outputs=PIN_A0, PIN_A1, PIN_A2,PIN_A5) 
.................... #use FIXED_IO( B_outputs=PIN_B3) 
.................... //#use FIXED_IO( C_outputs=PIN_C0, PIN_C5, PIN_C6, PIN_C7) 
.................... #use FIXED_IO( C_outputs=PIN_C0,PIN_C1,PIN_C2, PIN_C5, PIN_C6, PIN_C7) 
.................... #use FIXED_IO( D_outputs=PIN_D2, PIN_D4, PIN_D7 ) 
.................... #use FIXED_IO( E_outputs=PIN_E0, PIN_E1, PIN_E2) 
....................  
.................... //#use PWM(CCP2, FREQUENCY=1kHz, DUTY=100)//, STREAM=backlight) 
....................  
.................... #if Backlight_MAX_VAL!=1 
....................    #use pwm(CCP2,TIMER=2,FREQUENCY=10kHz)//, STREAM=backlight) 
....................    #warning USE PWM backlight 
.................... #else 
....................    #define BACKLIGHT_pin   PIN_C2 
.................... #endif 
....................  
.................... void fprintf_return_carriage(void) 
.................... { 
....................    fprintf(LOG_PORT,"\r\n"); 
*
0262:  MOVLW  0D
0263:  BSF    03.5
0264:  MOVWF  48
0265:  BCF    03.5
0266:  CALL   201
0267:  MOVLW  0A
0268:  BSF    03.5
0269:  MOVWF  48
026A:  BCF    03.5
026B:  CALL   201
026C:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #ifndef __Actice_antena_select__ 
....................    #include </HMI_include/HW_drivers/Active_antena_selector/active_antena_selector.c> 
.................... #include <active_antena_selector.h> 
.................... #ifndef __Actice_antena_select__ 
....................    #define __Actice_antena_select__ 
....................     
....................    #ifndef _i2c_Slave_buffer_addresses_ 
....................       #include </HMI_MCU_common_includes/HMI_i2c_Slave_buffer_addresses/i2c_Slave_buffer_addresses.h> 
.................... #ifndef _i2c_Slave_buffer_addresses_ 
....................    #define _i2c_Slave_buffer_addresses_ 
.................... //****************************************************// 
.................... /*       i2c COMMANDS protocol and addresses          */ 
.................... //****************************************************// 
....................  
.................... // i2c protocle// 
....................      #define command_clrl_all_packs             0x0      //command - size 1/ 0x00           / 0x0             /  0x0            / 
....................      #define command_clrl_x_pack                0x1      //command - size 1/pack_no - size 1/ 0x0             /  0x0            / 
....................      #define command_set_all_packs              0x2      //command - size 1/ 0x0            /colour - size 1  /  0x0            / 
....................      #define command_set_x_pack                 0x3      //command - size 1/pack_no - size 1/colour - size 1  /  0x0            / 
....................      #define command_blink_all_packs            0x4      //command - size 1/ 0x0            /colour_1 - size 1/colour_2 - size 1/ 
....................      #define command_blink_x_pack               0x5      //command - size 1/pack_no - size 1/colour_1 - size 1/colour_2 - size 1/ 
....................      #define command_set_backlight              0x6      //command - size 1/backlight value - size 1/0x0      /  0x0            / 
....................      #define command_stepper_motor_percen       0x7      //command - size 1/percents value - size 4/  
....................      #define command_stepper_motor_abs_val      0x8      //command - size 1/min_value - size 4/ max_value - size 4/ goto value - size 4/ 
....................      //#define command_stepper_motor_rel_val      0x9 
....................      #define command_stepper_motor_calibrate    0xA 
....................      // zarezerwowane dla i2c HMI adress        0x10 
....................       
....................      #define command_address              0x00 
....................      #define pack_no_addres               0x01 
....................      #define colour_1_addres              0x02 
....................      #define colour_2_addres              0x03   
....................       
....................      #define command_len                  0x1 
....................      #define pack_no_len                  0x1 
....................      #define colour_no_len                0x1 
.................... // i2c protocle// 
....................  
.................... //****************************************************// 
.................... /*       i2c COMMANDS protocol and addresses          */ 
.................... //****************************************************// 
....................  
....................  
.................... //****************************************************// 
.................... /*                  LED i2c protocol                  */ 
.................... //****************************************************// 
....................  
.................... /* 
.................... //hardware LEDS definition - can be changed 
....................    #define LED1_GREEN   PIN_A0 
....................    #define LED1_RED     PIN_A1    
....................    #define LED1_BLUE    PIN_A2 
....................  
....................    #define LED2_GREEN   PIN_A3 
....................    #define LED2_RED     PIN_A5 
....................    #define LED2_BLUE    PIN_E0 
....................     
....................    #define LED3_GREEN   PIN_E1 
....................    #define LED3_RED     PIN_E2 
....................    #define LED3_BLUE    PIN_C0 
.................... //hardware LEDS definition - can be changed 
.................... */ 
....................         
....................    #define  unset_mask              0b10000000 
....................    #define  colour_BLUE             0b00000001 
....................    #define  colour_GREEN            0b00000010 
....................    #define  colour_RED              0b00000100 
....................    #define  colour_YELLOW           colour_RED|colour_GREEN 
....................    #define  colour_PURPLE           colour_RED|colour_BLUE 
....................    #define  colour_SKYBLUE          colour_GREEN|colour_BLUE 
....................    #define  colour_WHITE            colour_BLUE|colour_GREEN|colour_RED 
....................    #define  colour_BLACK            unset_mask|colour_WHITE 
....................     
....................    #define  unset_colour_BLUE       unset_mask|0b00000001 
....................    #define  unset_colour_GREEN      unset_mask|0b00000010 
....................    #define  unset_colour_RED        unset_mask|0b00000100 
....................    #define  unset_colour_YELLOW     unset_mask|colour_RED|colour_GREEN 
....................    #define  unset_colour_PURPLE     unset_mask|colour_RED|colour_BLUE 
....................    #define  unset_colour_SKYBLUE    unset_mask|colour_GREEN|colour_BLUE 
....................    #define  unset_colour_WHITE      unset_mask|colour_WHITE 
....................     
....................    #define  pack_1             0b00000001 
....................    #define  pack_2             0b00000010 
....................    #define  pack_3             0b00000011 
....................  
....................  
....................  
....................     
....................    #define SB_set_x_pack_no_address                0x01 
....................    #define SB_set_x_pack_no_len                    0x01 
....................    #define SB_set_x_pack_Val_address               0x02    
....................    #define SB_set_x_pack_Val_len                   0x01     
....................     
....................     
....................    #define set_1st_pack                            0x1 
....................    #define set_2nd_pack                            0x2 
....................    #define set_3rd_pack                            0x3    
....................     
....................    #define SB_set_all_leds_address                 0x01 
....................    #define SB_set_all_leds_len                     0x01 
....................     
....................    #define SB_set_led_number_address               0x01 
....................    #define SB_set_led_number_len                   0x01    
....................     
....................    #define SB_set_led_Val_address                  0x02 
....................    #define SB_set_led_Val_len                      0x01 
....................        
....................    #define SB_set_motor__percent_Val_address       0x01 
....................    #define SB_set_motor__percent_len               0x04 
....................     
....................    #define SB_set_abs_val_Val_address              0x01 
....................    #define SB_set_abs_val_len                      0x04 
....................     
....................    #define SB_set_motor_rel_val_min_Val_address    0x01 
....................    #define SB_set_motor_rel_val_min_len            0x04 
....................     
....................    #define SB_set_motor_rel_val_curr_Val_address   0x05 
....................    #define SB_set_motor_rel_val_curr_len           0x04 
....................     
....................    #define SB_set_motor_rel_val_max_Val_address    0x09 
....................    #define SB_sets_motor_rel_val_curr_len          0x04 
....................     
....................    #define SB_set_backlight_Val_address            0x01 
....................    #define SB_set_backlight_len                    0x01 
.................... //****************************************************// 
.................... /*                  LED i2c protocol                  */ 
.................... //****************************************************// 
....................  
....................  
.................... //****************************************************// 
.................... /*        BACKLIGHTY i2c protocol addresses           */ 
.................... //****************************************************// 
....................    #define SBL_Val_address               0x01    
....................    #define SBL_Val_address_len           0x01     
....................  
.................... //****************************************************// 
.................... /*        BACKLIGHTY i2c protocol addresses           */ 
.................... //****************************************************// 
....................  
....................  
.................... //****************************************************// 
.................... /*      STEPPER MOTOR i2c protocol addresses          */ 
.................... //****************************************************// 
....................    #define  STP_MOTTOR_percentage_addres  0x01 
....................    #define  STP_MOTTOR_percentage_len     0x04 
....................     
....................    #define STP_MOTTOR_min_range_address   0x01 
....................    #define STP_MOTTOR_min_range_len       0x04 
....................    #define STP_MOTTOR_max_range_address   0x05 
....................    #define STP_MOTTOR_max_range_len       0x04 
....................    #define STP_MOTTOR_goto_address        0x09 
....................    #define STP_MOTTOR_goto_len            0x04 
....................  
.................... //****************************************************// 
.................... /*      STEPPER MOTOR i2c protocol addresses          */ 
.................... //****************************************************// 
....................  
.................... //****************************************************// 
.................... /*      ACTIVE ANTENA i2c protocol addresses          */ 
.................... //****************************************************// 
....................  
....................    #define  IS_FM_ANT_ACTIVE_bit       0b00000001 
....................    #define  IS_DAB_ANT_ACTIVE_bit      0b00000010 
....................    #define  IS_FM_DAB_CONVERTER_bit    0b00000100 
....................  
....................  
.................... //****************************************************// 
.................... /*      ACTIVE ANTENA i2c protocol addresses          */ 
.................... //****************************************************// 
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................    #endif 
....................  
....................   #ifndef   IS_FM_ANT_ACTIVE 
....................    #define  IS_FM_ANT_ACTIVE              PIN_B0 
....................   #endif 
....................   #ifndef   IS_DAB_ANT_ACTIVE 
....................    #define  IS_DAB_ANT_ACTIVE             PIN_B1  
....................   #endif 
....................   #ifndef   IS_FM_DAB_CONVERTER_ACTIVE 
....................    #define IS_FM_DAB_CONVERTER_ACTIVE    PIN_B2 
....................   #endif 
....................   #ifndef   ANTENA_SWITCH_SUPPLY 
....................    #define ANTENA_SWITCH_SUPPLY    PIN_B3 
....................   #endif    
....................     
....................     
....................    int8 get_active_antenas_supply_setup(void); 
....................     
.................... #endif 
....................  
....................  
.................... int8 get_active_antenas_supply_setup(void) 
.................... // Funkcja sprawdz, ustawienie wskazuj¹cych przez u¿ytkownika na anteny, które powinny byæ zasilane 
.................... { 
....................    return ((input(IS_FM_ANT_ACTIVE)*IS_FM_ANT_ACTIVE_bit)+ 
....................             (input(IS_DAB_ANT_ACTIVE)*IS_DAB_ANT_ACTIVE_bit)+ 
....................             (input(IS_FM_DAB_CONVERTER_ACTIVE)*IS_FM_DAB_CONVERTER_bit)); 
*
00AD:  MOVLW  F7
00AE:  MOVWF  06
00AF:  MOVLW  00
00B0:  BCF    03.5
00B1:  BTFSC  06.0
00B2:  MOVLW  01
00B3:  BSF    03.5
00B4:  MOVWF  5A
00B5:  MOVLW  F7
00B6:  MOVWF  06
00B7:  MOVLW  00
00B8:  BCF    03.5
00B9:  BTFSC  06.1
00BA:  MOVLW  01
00BB:  MOVWF  77
00BC:  BCF    03.0
00BD:  RLF    77,F
00BE:  MOVF   77,W
00BF:  BSF    03.5
00C0:  ADDWF  5A,F
00C1:  MOVLW  F7
00C2:  MOVWF  06
00C3:  MOVLW  00
00C4:  BCF    03.5
00C5:  BTFSC  06.2
00C6:  MOVLW  01
00C7:  MOVWF  77
00C8:  RLF    77,F
00C9:  RLF    77,F
00CA:  MOVLW  FC
00CB:  ANDWF  77,F
00CC:  MOVF   77,W
00CD:  BSF    03.5
00CE:  ADDWF  5A,W
00CF:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #ifndef _I2C_ENGINE_SLAVE_ 
....................    #include </HMI_include/core/i2c_slave/i2c_slave.c> 
.................... /**************************************************************************/ 
.................... /*!  
....................     @file     i2c_slave.c 
....................     @author   D. Bankowski (d.bankowski@gmail.com) 
....................      
....................     @brief    Driver for i2c slave. 
....................     @section LICENSE 
....................     Software License Agreement (BSD License) 
....................     Copyright (c) 2017, D. Bankowski 
....................     All rights reserved. 
....................     Redistribution and use in source and binary forms, with or without 
....................     modification, are permitted provided that the following conditions are met: 
....................     1. Redistributions of source code must retain the above copyright 
....................     notice, this list of conditions and the following disclaimer. 
....................     2. Redistributions in binary form must reproduce the above copyright 
....................     notice, this list of conditions and the following disclaimer in the 
....................     documentation and/or other materials provided with the distribution. 
....................     3. Neither the name of the copyright holders nor the 
....................     names of its contributors may be used to endorse or promote products 
....................     derived from this software without specific prior written permission. 
....................     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY 
....................     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY 
....................     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
.................... */ 
.................... /**************************************************************************/ 
....................  
.................... #include <i2c_slave.h> 
.................... /**************************************************************************/ 
.................... /*!  
....................     @file     i2c_slave.h 
....................     @author   D. Bankowski (d.bankowski@gmail.com) 
....................      
....................     @brief    Driver for i2c slave. 
....................     @section LICENSE 
....................     Software License Agreement (BSD License) 
....................     Copyright (c) 2017, D. Bankowski 
....................     All rights reserved. 
....................     Redistribution and use in source and binary forms, with or without 
....................     modification, are permitted provided that the following conditions are met: 
....................     1. Redistributions of source code must retain the above copyright 
....................     notice, this list of conditions and the following disclaimer. 
....................     2. Redistributions in binary form must reproduce the above copyright 
....................     notice, this list of conditions and the following disclaimer in the 
....................     documentation and/or other materials provided with the distribution. 
....................     3. Neither the name of the copyright holders nor the 
....................     names of its contributors may be used to endorse or promote products 
....................     derived from this software without specific prior written permission. 
....................     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY 
....................     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY 
....................     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
.................... */ 
.................... /**************************************************************************/ 
....................  
.................... #ifndef _I2C_ENGINE_SLAVE_ 
....................    #define _I2C_ENGINE_SLAVE_ 
....................     
....................    #if getenv("SFR_VALID:SSPSTAT") 
....................       #byte SSP1STAT = getenv("SFR:SSPSTAT") 
....................       #bit SSP1STAT_STOP_SEEN=SSP1STAT.4  
....................       #WARNING "PIC_SSPSTAT REGISTER CONFIGURED" 
....................    #else 
....................       #ERROR "PIC_SSPSTAT REGISTER SHOULD BE DEFINED in i2c_slave.h" 
....................    #endif 
....................    
....................    #define  I2C_SLAVE_BUFSIZE       15 
....................     
....................    unsigned int8   Master_2_Slave_Buffer[I2C_SLAVE_BUFSIZE]; 
....................    unsigned int8   Slave_2_Master_Buffer[I2C_SLAVE_BUFSIZE]; 
....................    unsigned int    i2c_buffer_counter; 
....................     
....................    void clr_SSPSTAT(void); 
....................    void ClearBuffers (unsigned int, short int); 
....................    void set_i2c_interrupt_ready(void); 
....................    void i2c_slave_interrupt (void); 
.................... #endif 
....................  
....................  
....................  
.................... void clr_SSPSTAT(void)     //when data is counted by program and can read new data 
.................... { 
....................    SSP1STAT = 0; 
*
0410:  BSF    03.5
0411:  CLRF   14
....................    i2c_buffer_counter = 0; 
0412:  BCF    03.5
0413:  CLRF   4E
.................... } 
....................  
.................... void ClearBuffers (unsigned int *buffer, short int buffer_size) 
.................... { 
....................    unsigned int8 i; 
....................    for ( i = 0; i < buffer_size; i++ ) 
....................    { 
....................       *(buffer+i)= 0x00; 
....................    } 
.................... } 
....................  
.................... //unsigned int set_i2c_interrupt_ready(void) 
.................... void set_i2c_interrupt_ready(void) 
.................... { 
....................    clr_SSPSTAT(); 
....................    i2c_slave_ready(); 
0414:  MOVLW  10
0415:  BSF    03.5
0416:  MOVWF  13
0417:  BCF    03.5
0418:  RETURN
.................... } 
....................     
....................     
.................... void i2c_slave_interrupt (void) 
.................... { 
....................    unsigned int8 state; //, incoming; 
....................    state = i2c_isr_state(); 
*
0080:  BSF    03.5
0081:  BTFSC  14.5
0082:  GOTO   08B
0083:  BCF    03.5
0084:  CLRF   4F
0085:  BSF    03.5
0086:  BTFSS  14.2
0087:  GOTO   08B
0088:  BCF    03.5
0089:  BSF    4F.7
008A:  BSF    03.5
008B:  BCF    03.5
008C:  MOVF   4F,W
008D:  INCF   4F,F
008E:  BSF    03.5
008F:  MOVWF  59
....................    if (state < 0x80) 
0090:  MOVF   59,W
0091:  SUBLW  7F
0092:  BTFSS  03.0
0093:  GOTO   0A4
....................        { 
....................        Master_2_Slave_Buffer[i2c_buffer_counter]= i2c_read(); 
0094:  MOVLW  30
0095:  BCF    03.5
0096:  ADDWF  4E,W
0097:  MOVWF  04
0098:  BCF    03.7
0099:  BCF    14.6
009A:  BSF    03.5
009B:  BTFSS  14.0
009C:  GOTO   09B
009D:  BCF    03.5
009E:  MOVF   13,W
009F:  BSF    14.4
00A0:  MOVWF  00
....................        i2c_buffer_counter=i2c_buffer_counter+1; 
00A1:  MOVLW  01
00A2:  ADDWF  4E,F
00A3:  BSF    03.5
....................        } 
....................         
....................    if(state >= 0x80)                      //Master is requesting data do Your operations here 
00A4:  MOVF   59,W
00A5:  SUBLW  7F
00A6:  BTFSC  03.0
00A7:  GOTO   0E7
....................    { 
....................       output_bit( ANTENA_SWITCH_SUPPLY, 1); 
00A8:  BCF    03.5
00A9:  BSF    06.3
00AA:  MOVLW  F7
00AB:  BSF    03.5
00AC:  MOVWF  06
....................       i2c_write(get_active_antenas_supply_setup()); 
*
00D0:  MOVF   78,W
00D1:  MOVWF  5A
00D2:  MOVF   5A,W
00D3:  MOVWF  5B
....................       output_bit( ANTENA_SWITCH_SUPPLY, 0); 
*
00E2:  BCF    03.5
00E3:  BCF    06.3
00E4:  MOVLW  F7
00E5:  BSF    03.5
00E6:  MOVWF  06
....................    } 
....................    if (SSP1STAT_STOP_SEEN==1) 
00E7:  BTFSS  14.4
00E8:  GOTO   0EB
....................    { 
....................       i2c_slave_not_ready() ; 
00E9:  MOVLW  12
00EA:  MOVWF  13
....................    } 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef _led_module_ 
....................    #include </HMI_include/modules/led_module/led_module.c> 
.................... #include </HMI_include/modules/led_module/led_module.h> 
.................... #ifndef  _led_module_ 
....................    #define _led_module_ 
....................     
....................    #ifndef _i2c_Slave_buffer_addresses_ 
....................       #include </HMI_include/core/i2c_Slave_buffer_addresses/i2c_Slave_buffer_addresses.h> 
....................    #endif 
....................  
.................... void run_led_blink_timer(void); 
....................  
.................... void choose_LED_PAD(int8); 
.................... void led_ADD(int8); 
.................... void led_DELETE(int8); 
.................... void set_x_pack_colour(int8, int8); 
.................... void set_all_pack_colour(int8); 
.................... void set_x_pack_blink(int8, int8, int8); 
.................... void set_all_pack_blink(int8, int8); 
.................... void clear_x_pack(int8); 
.................... void clear_all_pack(void); 
....................     
.................... #endif 
....................  
....................  
....................  
.................... int16 pin_BLUE_no; 
.................... int16 pin_GREEN_no; 
.................... int16 pin_RED_no; 
....................  
.................... //unsigned int16 LED_PACK_blink_timer; 
.................... int1 blink_display_color_no1=TRUE; 
.................... int1 blink_time_2_switch_color; 
....................  
.................... #define led_blink_timeout 12000 
.................... #define led_blink_time_4_timer   229 
....................  
.................... void run_led_blink_timer(void) 
.................... { 
....................  
.................... if (get_ticks(LED_blink_timer)>=led_blink_time_4_timer) 
*
0781:  MOVF   78,W
0782:  BSF    03.5
0783:  MOVWF  3C
0784:  MOVF   77,W
0785:  MOVWF  3B
0786:  MOVF   3C,F
0787:  BTFSS  03.2
0788:  GOTO   78D
0789:  MOVF   3B,W
078A:  SUBLW  E4
078B:  BTFSC  03.0
078C:  GOTO   797
.................... { 
....................    blink_time_2_switch_color=true; 
078D:  BCF    03.5
078E:  BSF    56.1
....................    blink_display_color_no1=!blink_display_color_no1; 
078F:  MOVLW  01
0790:  XORWF  56,F
....................    set_ticks(LED_blink_timer,0); 
0791:  BSF    03.5
0792:  CLRF   3C
0793:  CLRF   3B
0794:  BCF    03.5
0795:  CALL   639
0796:  BSF    03.5
....................    } 
0797:  BCF    03.5
0798:  BCF    0A.3
0799:  BSF    0A.4
079A:  GOTO   47E (RETURN)
.................... } 
....................  
.................... void choose_LED_PAD(int8 pack_number) 
.................... { 
....................    switch ( pack_number){ 
*
0419:  BSF    03.5
041A:  MOVF   40,W
041B:  XORLW  01
041C:  BCF    03.5
041D:  BTFSC  03.2
041E:  GOTO   426
041F:  XORLW  03
0420:  BTFSC  03.2
0421:  GOTO   430
0422:  XORLW  01
0423:  BTFSC  03.2
0424:  GOTO   43A
0425:  GOTO   443
....................    case pack_1: 
....................       pin_BLUE_no =  LED1_BLUE; 
0426:  CLRF   51
0427:  MOVLW  2A
0428:  MOVWF  50
....................       pin_GREEN_no = LED1_GREEN; 
0429:  CLRF   53
042A:  MOVLW  28
042B:  MOVWF  52
....................       pin_RED_no =   LED1_RED; 
042C:  CLRF   55
042D:  MOVLW  29
042E:  MOVWF  54
....................       break; 
042F:  GOTO   443
....................    case pack_2: 
....................       pin_BLUE_no =  LED2_BLUE; 
0430:  CLRF   51
0431:  MOVLW  48
0432:  MOVWF  50
....................       pin_GREEN_no = LED2_GREEN; 
0433:  CLRF   53
0434:  MOVLW  2B
0435:  MOVWF  52
....................       pin_RED_no =   LED2_RED;       
0436:  CLRF   55
0437:  MOVLW  2D
0438:  MOVWF  54
....................       break; 
0439:  GOTO   443
....................    case pack_3: 
....................       pin_BLUE_no =  LED3_BLUE; 
043A:  CLRF   51
043B:  MOVLW  38
043C:  MOVWF  50
....................       pin_GREEN_no = LED3_GREEN; 
043D:  CLRF   53
043E:  MOVLW  49
043F:  MOVWF  52
....................       pin_RED_no =   LED3_RED;       
0440:  CLRF   55
0441:  MOVLW  4A
0442:  MOVWF  54
....................       break; 
....................    } 
0443:  RETURN
.................... } 
....................  
.................... void led_ADD(int8 _set_colour) 
.................... { 
....................       if ((_set_colour & colour_BLUE)!=0) 
*
04C5:  MOVF   40,W
04C6:  ANDLW  01
04C7:  BTFSC  03.2
04C8:  GOTO   4DD
....................          output_high(pin_BLUE_no); 
04C9:  BCF    03.5
04CA:  MOVF   50,W
04CB:  BSF    03.5
04CC:  MOVWF  41
04CD:  MOVLW  01
04CE:  MOVWF  42
04CF:  CLRF   44
04D0:  CLRF   43
04D1:  BCF    03.5
04D2:  CALL   444
04D3:  MOVF   50,W
04D4:  BSF    03.5
04D5:  MOVWF  41
04D6:  CLRF   42
04D7:  CLRF   44
04D8:  MOVLW  80
04D9:  MOVWF  43
04DA:  BCF    03.5
04DB:  CALL   444
04DC:  BSF    03.5
....................       if ((_set_colour & colour_GREEN)!=0)     
04DD:  MOVF   40,W
04DE:  ANDLW  02
04DF:  BTFSC  03.2
04E0:  GOTO   4F5
....................          output_high(pin_GREEN_no); 
04E1:  BCF    03.5
04E2:  MOVF   52,W
04E3:  BSF    03.5
04E4:  MOVWF  41
04E5:  MOVLW  01
04E6:  MOVWF  42
04E7:  CLRF   44
04E8:  CLRF   43
04E9:  BCF    03.5
04EA:  CALL   444
04EB:  MOVF   52,W
04EC:  BSF    03.5
04ED:  MOVWF  41
04EE:  CLRF   42
04EF:  CLRF   44
04F0:  MOVLW  80
04F1:  MOVWF  43
04F2:  BCF    03.5
04F3:  CALL   444
04F4:  BSF    03.5
....................       if ((_set_colour & colour_RED)!=0) 
04F5:  MOVF   40,W
04F6:  ANDLW  04
04F7:  BTFSC  03.2
04F8:  GOTO   50D
....................          output_high(pin_RED_no); 
04F9:  BCF    03.5
04FA:  MOVF   54,W
04FB:  BSF    03.5
04FC:  MOVWF  41
04FD:  MOVLW  01
04FE:  MOVWF  42
04FF:  CLRF   44
0500:  CLRF   43
0501:  BCF    03.5
0502:  CALL   444
0503:  MOVF   54,W
0504:  BSF    03.5
0505:  MOVWF  41
0506:  CLRF   42
0507:  CLRF   44
0508:  MOVLW  80
0509:  MOVWF  43
050A:  BCF    03.5
050B:  CALL   444
050C:  BSF    03.5
.................... } 
....................  
.................... void led_DELETE(int8 _uset_colour) 
.................... { 
....................       if ((_uset_colour & colour_BLUE)!=0) 
*
0466:  BSF    03.5
0467:  MOVF   40,W
0468:  ANDLW  01
0469:  BTFSC  03.2
046A:  GOTO   47E
....................          output_low(pin_BLUE_no); 
046B:  BCF    03.5
046C:  MOVF   50,W
046D:  BSF    03.5
046E:  MOVWF  41
046F:  CLRF   42
0470:  CLRF   44
0471:  CLRF   43
0472:  BCF    03.5
0473:  CALL   444
0474:  MOVF   50,W
0475:  BSF    03.5
0476:  MOVWF  41
0477:  CLRF   42
0478:  CLRF   44
0479:  MOVLW  80
047A:  MOVWF  43
047B:  BCF    03.5
047C:  CALL   444
047D:  BSF    03.5
....................       if ((_uset_colour & colour_GREEN)!=0)     
047E:  MOVF   40,W
047F:  ANDLW  02
0480:  BTFSC  03.2
0481:  GOTO   495
....................          output_low(pin_GREEN_no); 
0482:  BCF    03.5
0483:  MOVF   52,W
0484:  BSF    03.5
0485:  MOVWF  41
0486:  CLRF   42
0487:  CLRF   44
0488:  CLRF   43
0489:  BCF    03.5
048A:  CALL   444
048B:  MOVF   52,W
048C:  BSF    03.5
048D:  MOVWF  41
048E:  CLRF   42
048F:  CLRF   44
0490:  MOVLW  80
0491:  MOVWF  43
0492:  BCF    03.5
0493:  CALL   444
0494:  BSF    03.5
....................       if ((_uset_colour & colour_RED)!=0) 
0495:  MOVF   40,W
0496:  ANDLW  04
0497:  BTFSC  03.2
0498:  GOTO   4AC
....................          output_low(pin_RED_no); 
0499:  BCF    03.5
049A:  MOVF   54,W
049B:  BSF    03.5
049C:  MOVWF  41
049D:  CLRF   42
049E:  CLRF   44
049F:  CLRF   43
04A0:  BCF    03.5
04A1:  CALL   444
04A2:  MOVF   54,W
04A3:  BSF    03.5
04A4:  MOVWF  41
04A5:  CLRF   42
04A6:  CLRF   44
04A7:  MOVLW  80
04A8:  MOVWF  43
04A9:  BCF    03.5
04AA:  CALL   444
04AB:  BSF    03.5
04AC:  BCF    03.5
04AD:  RETURN
.................... } 
....................  
.................... void set_x_pack_colour(int8 pack_no, int8 colour) 
.................... { 
....................    choose_LED_PAD(pack_no); 
04AE:  BSF    03.5
04AF:  MOVF   3E,W
04B0:  MOVWF  40
04B1:  BCF    03.5
04B2:  CALL   419
....................    if ((colour & unset_mask) != 0) 
04B3:  BSF    03.5
04B4:  MOVF   3F,W
04B5:  ANDLW  80
04B6:  BTFSC  03.2
04B7:  GOTO   4BE
....................       led_DELETE(colour); 
04B8:  MOVF   3F,W
04B9:  MOVWF  40
04BA:  BCF    03.5
04BB:  CALL   466
04BC:  GOTO   50C
04BD:  BSF    03.5
....................    else 
....................       { 
....................       led_DELETE(colour_BLACK); 
04BE:  MOVLW  87
04BF:  MOVWF  40
04C0:  BCF    03.5
04C1:  CALL   466
....................       led_ADD(colour); 
04C2:  BSF    03.5
04C3:  MOVF   3F,W
04C4:  MOVWF  40
....................       } 
*
050D:  BCF    03.5
050E:  RETURN
.................... } 
....................  
.................... void set_all_pack_colour(int8 colour) 
.................... { 
....................    set_x_pack_colour(pack_1, colour); 
050F:  MOVLW  01
0510:  BSF    03.5
0511:  MOVWF  3E
0512:  MOVF   3B,W
0513:  MOVWF  3F
0514:  BCF    03.5
0515:  CALL   4AE
....................    set_x_pack_colour(pack_2, colour); 
0516:  MOVLW  02
0517:  BSF    03.5
0518:  MOVWF  3E
0519:  MOVF   3B,W
051A:  MOVWF  3F
051B:  BCF    03.5
051C:  CALL   4AE
....................    set_x_pack_colour(pack_3, colour); 
051D:  MOVLW  03
051E:  BSF    03.5
051F:  MOVWF  3E
0520:  MOVF   3B,W
0521:  MOVWF  3F
0522:  BCF    03.5
0523:  CALL   4AE
0524:  RETURN
.................... } 
....................  
.................... void set_x_pack_blink(int8 pack_no, int8 colour1, int8 colour2) 
.................... { 
....................    //choose_LED_PAD(pack_no); 
....................    if (blink_time_2_switch_color==true) 
*
079B:  BTFSS  56.1
079C:  GOTO   7AE
....................       { 
....................       if (blink_display_color_no1 ==TRUE) 
079D:  BTFSS  56.0
079E:  GOTO   7A7
....................          set_x_pack_colour(pack_no,colour1); 
079F:  BSF    03.5
07A0:  MOVF   3B,W
07A1:  MOVWF  3E
07A2:  MOVF   3C,W
07A3:  MOVWF  3F
07A4:  BCF    03.5
07A5:  CALL   4AE
07A6:  GOTO   7AE
....................       else 
....................          set_x_pack_colour(pack_no,colour2); 
07A7:  BSF    03.5
07A8:  MOVF   3B,W
07A9:  MOVWF  3E
07AA:  MOVF   3D,W
07AB:  MOVWF  3F
07AC:  BCF    03.5
07AD:  CALL   4AE
....................       } 
07AE:  RETURN
.................... } 
....................  
.................... void set_all_pack_blink(int8 colour1, int8 colour2) 
.................... { 
.................... set_x_pack_blink(pack_1, colour1, colour2); 
.................... set_x_pack_blink(pack_2, colour1, colour2); 
.................... set_x_pack_blink(pack_3, colour1, colour2); 
.................... } 
....................  
.................... void clear_x_pack(int8 pack_no) 
.................... { 
....................    choose_LED_PAD(pack_no); 
*
05C6:  BSF    03.5
05C7:  MOVF   3B,W
05C8:  MOVWF  40
05C9:  BCF    03.5
05CA:  CALL   419
....................    led_DELETE(colour_BLACK); 
05CB:  MOVLW  87
05CC:  BSF    03.5
05CD:  MOVWF  40
05CE:  BCF    03.5
05CF:  CALL   466
05D0:  RETURN
.................... } 
....................  
.................... void clear_all_pack(void) 
.................... { 
....................    clear_x_pack(pack_1); 
05D1:  MOVLW  01
05D2:  BSF    03.5
05D3:  MOVWF  3B
05D4:  BCF    03.5
05D5:  CALL   5C6
....................    clear_x_pack(pack_2); 
05D6:  MOVLW  02
05D7:  BSF    03.5
05D8:  MOVWF  3B
05D9:  BCF    03.5
05DA:  CALL   5C6
....................    clear_x_pack(pack_3); 
05DB:  MOVLW  03
05DC:  BSF    03.5
05DD:  MOVWF  3B
05DE:  BCF    03.5
05DF:  CALL   5C6
05E0:  BCF    0A.3
05E1:  BSF    0A.4
05E2:  GOTO   13A (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #ifndef  _stepper_motor_module_ 
....................    #include </HMI_include/modules/stepper_motor_module/module_stepper_motor.c> 
.................... #include <module_stepper_motor.h> 
.................... #ifndef  _stepper_motor_module_ 
....................    #define  _stepper_motor_module_ 
....................     
....................    #ifndef __l293d__ 
....................       #include </HMI_include/HW_drivers/L293/L293D.c> 
.................... #include <l293d.h> 
.................... #ifndef __l293d__ 
....................    #define __l293d__ 
....................    #ifndef A1 
....................       #define A1  PIN_C5 
....................    #endif 
....................    #ifndef A2 
....................       #define A2  PIN_C6 
....................    #endif 
....................    #ifndef A3 
....................       #define A3  PIN_C7 
....................    #endif 
....................    #ifndef A4 
....................       #define A4  PIN_D4 
....................    #endif 
....................    #define L293_OUTPUT_lag_time       1     //800 ns co daje 1 us 
....................    #ifdef use_EN_pins 
....................       #define  L293_EN_lag_time_ON    1     //800 ns co daje 1 us 
....................       #define  L293_EN_lag_time_OFF   1     //800 ns co daje 1 us 
....................       #ifndef  EN_12 
....................          #define  EN_12 PIN_D2       // define in Your program 
....................       #endif 
....................       #ifndef  EN_34 
....................          #define  EN_34 PIN_Y       // define in Your program 
....................       #endif 
....................    #endif 
....................     
....................    #define  ON    1 
....................    #define  OFF   0 
....................    #define  LEFT  0 
....................    #define  RIGHT 1 
....................    #define  STOP  2 
....................     
....................     
....................    #define  stop_phase  0 
....................    #define  first_phase 1 
....................     
....................    #ifdef   one_fase_control 
....................       //#define  last_phase 5 
....................       //const int8 stepper_motor_pase [last_phase][4] = //Wave or one-fase control 
....................       #define  max_phase 4 
....................       const int8 stepper_motor_pase [max_phase+1][4] = //Wave or one-fase control 
....................       { 
....................          //A1, A2, A3, A4 
....................          0,0,0,0,    //stop condition 
....................          1,0,0,0, 
....................          0,0,1,0, 
....................          0,1,0,0, 
....................          0,0,0,1 
....................       }; 
....................    //#endif 
....................     
....................    #ELIF defined   two_fase_control 
....................       //#define  last_phase  5 
....................       //const int8 stepper_motor_pase [last_phase][4] = //Fullstep or two-fase control 
....................       #define  max_phase  4 
....................       const int8 stepper_motor_pase [max_phase+1][4] = //Fullstep or two-fase control       
....................        
....................       { 
....................          //A1, A2, A3, A4 
....................          0,0,0,0,    //stop condition 
....................          1,0,1,0, 
....................          0,1,1,0, 
....................          0,1,0,1, 
....................          1,0,0,1 
....................       }; 
....................    //#endif 
....................     
....................    #ELIF defined   halfstep_control 
....................       //#define last_phase 9 
....................       //const int8 stepper_motor_pase [last_phase][4] = //Halfstep or two-faze + two-faze control 
....................        
....................       #define max_phase 8 
....................       const int8 stepper_motor_pase [max_phase+1][4] = //Halfstep or two-faze + two-faze control       
....................        
....................       { 
....................          //A1, A2, A3, A4 
....................          0,0,0,0,    //stop condition 
....................          1,0,0,0, 
....................          1,0,1,0, 
....................          0,0,1,0, 
....................          0,1,1,0, 
....................          0,1,0,0, 
....................          0,1,0,1, 
....................          0,0,0,1, 
....................          1,0,0,1 
....................       }; 
....................    #ELSE 
....................       #ERROR "PLEASE DEFINE STEPPER MOTOR CONTROL METHOD: one_fase_control or two_fase_control or halfstep_control" 
....................    #endif 
....................  
....................  
.................... void  enable_EN_12(void); 
.................... void  enable_EN_34(void); 
.................... void  disable_EN_12(void); 
.................... void  disable_EN_34(void); 
....................  
.................... int8 STEPPER_motor(int8, int1); 
.................... void DC_motor_Bidirectional(int8, int1); 
.................... void DC_motor_Unidirectional(int1, int16); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... int8 STEPPER_motor(int8 present_phase, int8 LEFT_RIGHT_STOP) 
.................... {    
....................    int8 output_order[4];   
....................    switch (LEFT_RIGHT_STOP) 
*
0298:  BSF    03.5
0299:  MOVF   3C,W
029A:  XORLW  00
029B:  BCF    03.5
029C:  BTFSC  03.2
029D:  GOTO   2A5
029E:  XORLW  01
029F:  BTFSC  03.2
02A0:  GOTO   2C6
02A1:  XORLW  03
02A2:  BTFSC  03.2
02A3:  GOTO   2E8
02A4:  GOTO   2EE
....................    { 
....................       case LEFT: 
....................          present_phase = present_phase -1; 
02A5:  MOVLW  01
02A6:  BSF    03.5
02A7:  SUBWF  3B,F
....................          if (present_phase<first_phase) 
02A8:  MOVF   3B,F
02A9:  BTFSS  03.2
02AA:  GOTO   2AD
....................          { 
....................             present_phase = max_phase; 
02AB:  MOVLW  04
02AC:  MOVWF  3B
....................          } 
....................          { 
....................             for(int8 i=0; i<4;i++) 
02AD:  CLRF   41
02AE:  MOVF   41,W
02AF:  SUBLW  03
02B0:  BTFSS  03.0
02B1:  GOTO   2C4
....................             { 
....................                output_order[i]=stepper_motor_pase[present_phase][i]; 
02B2:  MOVLW  BD
02B3:  ADDWF  41,W
02B4:  MOVWF  04
02B5:  BCF    03.7
02B6:  RLF    3B,W
02B7:  MOVWF  77
02B8:  RLF    77,F
02B9:  MOVLW  FC
02BA:  ANDWF  77,F
02BB:  MOVF   77,W
02BC:  ADDWF  41,W
02BD:  BCF    03.5
02BE:  CALL   051
02BF:  MOVWF  78
02C0:  MOVWF  00
02C1:  BSF    03.5
02C2:  INCF   41,F
02C3:  GOTO   2AE
....................             } 
....................          } 
....................           
....................          break; 
02C4:  BCF    03.5
02C5:  GOTO   2EE
....................       case RIGHT: 
....................          present_phase = present_phase +1; 
02C6:  MOVLW  01
02C7:  BSF    03.5
02C8:  ADDWF  3B,F
....................          if (present_phase>max_phase) 
02C9:  MOVF   3B,W
02CA:  SUBLW  04
02CB:  BTFSC  03.0
02CC:  GOTO   2CF
....................          { 
....................             present_phase = first_phase; 
02CD:  MOVLW  01
02CE:  MOVWF  3B
....................          } 
....................          { 
....................             for(int8 i=0; i<4;i++) 
02CF:  CLRF   42
02D0:  MOVF   42,W
02D1:  SUBLW  03
02D2:  BTFSS  03.0
02D3:  GOTO   2E6
....................             { 
....................                output_order[i]=stepper_motor_pase[present_phase][i]; 
02D4:  MOVLW  BD
02D5:  ADDWF  42,W
02D6:  MOVWF  04
02D7:  BCF    03.7
02D8:  RLF    3B,W
02D9:  MOVWF  77
02DA:  RLF    77,F
02DB:  MOVLW  FC
02DC:  ANDWF  77,F
02DD:  MOVF   77,W
02DE:  ADDWF  42,W
02DF:  BCF    03.5
02E0:  CALL   051
02E1:  MOVWF  78
02E2:  MOVWF  00
02E3:  BSF    03.5
02E4:  INCF   42,F
02E5:  GOTO   2D0
....................             }            
....................          } 
....................          break; 
02E6:  BCF    03.5
02E7:  GOTO   2EE
....................       case STOP:     //nie dzia³a za dobrze na symulatorze 
....................          { 
....................             output_order[0]=0; 
02E8:  BSF    03.5
02E9:  CLRF   3D
....................             output_order[1]=0; 
02EA:  CLRF   3E
....................             output_order[2]=0; 
02EB:  CLRF   3F
....................             output_order[3]=0;  
02EC:  CLRF   40
02ED:  BCF    03.5
....................          } 
....................    } 
....................    output_bit (A1, output_order[0]); 
02EE:  BSF    03.5
02EF:  MOVF   3D,F
02F0:  BTFSS  03.2
02F1:  GOTO   2F6
02F2:  BCF    03.5
02F3:  BCF    07.5
02F4:  GOTO   2F8
02F5:  BSF    03.5
02F6:  BCF    03.5
02F7:  BSF    07.5
02F8:  MOVLW  18
02F9:  BSF    03.5
02FA:  MOVWF  07
....................    output_bit (A2, output_order[1]); 
02FB:  MOVF   3E,F
02FC:  BTFSS  03.2
02FD:  GOTO   302
02FE:  BCF    03.5
02FF:  BCF    07.6
0300:  GOTO   304
0301:  BSF    03.5
0302:  BCF    03.5
0303:  BSF    07.6
0304:  MOVLW  18
0305:  BSF    03.5
0306:  MOVWF  07
....................    output_bit (A3, output_order[2]); 
0307:  MOVF   3F,F
0308:  BTFSS  03.2
0309:  GOTO   30E
030A:  BCF    03.5
030B:  BCF    07.7
030C:  GOTO   310
030D:  BSF    03.5
030E:  BCF    03.5
030F:  BSF    07.7
0310:  MOVLW  18
0311:  BSF    03.5
0312:  MOVWF  07
....................    output_bit (A4, output_order[3]); 
0313:  MOVF   40,F
0314:  BTFSS  03.2
0315:  GOTO   31A
0316:  BCF    03.5
0317:  BCF    08.4
0318:  GOTO   31C
0319:  BSF    03.5
031A:  BCF    03.5
031B:  BSF    08.4
031C:  MOVLW  6B
031D:  BSF    03.5
031E:  MOVWF  08
....................    delay_us(L293_OUTPUT_lag_time); 
031F:  GOTO   320
0320:  GOTO   321
0321:  NOP
....................    return present_phase; 
0322:  MOVF   3B,W
0323:  MOVWF  78
0324:  BCF    03.5
0325:  RETURN
.................... } 
....................  
....................  
.................... void DC_motor_Bidirectional(int8 LEFT_RIGHT_STOP, int1 morot_number) 
.................... { 
....................    int16 motor_pin_1; 
....................    int16 motor_pin_2; 
....................    if (morot_number ==0) 
....................    { 
....................       motor_pin_1 =A1; 
....................       motor_pin_2 =A2; 
....................    } 
....................    else 
....................    { 
....................       motor_pin_1 =A3; 
....................       motor_pin_2 =A4; 
....................     
....................    } 
....................    switch(LEFT_RIGHT_STOP) 
....................    { 
....................       case LEFT: 
....................          output_high(motor_pin_1); 
....................          output_low(motor_pin_2); 
....................          break; 
....................       case RIGHT: 
....................          output_low(motor_pin_1); 
....................          output_high(motor_pin_2);       
....................          break; 
....................       case STOP: 
....................          output_low(motor_pin_1); 
....................          output_low(motor_pin_2);     
....................    } 
.................... } 
....................  
.................... void DC_motor_Unidirectional(int1 ON_OFF, int16 motor_pin) 
.................... { 
.................... if (ON_OFF==1) 
....................    output_high(motor_pin); 
.................... else 
....................    output_low(motor_pin); 
.................... } 
....................  
.................... void  enable_EN_12(void) 
.................... { 
....................    #ifdef use_EN_pins 
....................       //delay_ms(L293_EN_lag_time_OFF); 
....................       delay_us(L293_EN_lag_time_OFF); 
0326:  GOTO   327
0327:  GOTO   328
0328:  NOP
....................       output_high(EN_12); 
0329:  MOVLW  6B
032A:  BSF    03.5
032B:  MOVWF  08
032C:  BCF    03.5
032D:  BSF    08.2
....................       //delay_us(L293_EN_lag_time_ON); 
....................       delay_us(L293_EN_lag_time_ON); 
032E:  GOTO   32F
032F:  GOTO   330
0330:  NOP
....................    #else 
0331:  RETURN
....................       ; 
....................    #endif 
.................... }    
....................  
.................... void  enable_EN_34(void) 
.................... { 
....................    #ifdef use_EN_pins 
....................       //delay_ms(L293_EN_lag_time_OFF); 
....................       delay_us(L293_EN_lag_time_OFF); 
....................       output_high(EN_34); 
....................       //delay_ms(L293_EN_lag_time_ON); 
....................       delay_us(L293_EN_lag_time_ON);    
....................    #else 
....................       ; 
....................    #endif 
.................... }    
....................     
.................... void  disable_EN_12(void) 
.................... { 
....................    #ifdef use_EN_pins 
....................       //delay_ms(L293_EN_lag_time_OFF); 
....................       delay_us(L293_EN_lag_time_OFF); 
*
028C:  GOTO   28D
028D:  GOTO   28E
028E:  NOP
....................       output_low(EN_12); 
028F:  MOVLW  6B
0290:  BSF    03.5
0291:  MOVWF  08
0292:  BCF    03.5
0293:  BCF    08.2
....................       //delay_ms(L293_EN_lag_time_OFF); 
....................       delay_us(L293_EN_lag_time_OFF); 
0294:  GOTO   295
0295:  GOTO   296
0296:  NOP
....................    #else 
0297:  RETURN
....................       ; 
....................    #endif 
.................... }       
....................     
.................... void  disable_EN_34(void) 
.................... { 
....................    #ifdef use_EN_pins 
....................      // delay_ms(L293_EN_lag_time_OFF); 
....................       delay_us(L293_EN_lag_time_OFF); 
....................       output_low(EN_12); 
....................       //delay_ms(L293_EN_lag_time_OFF); 
....................       delay_us(L293_EN_lag_time_OFF); 
....................        
....................    #else 
....................       ; 
....................    #endif 
.................... }       
....................  
....................  
....................    #endif 
....................     
....................    #ifndef steper_motor_left_end 
....................       #define steper_motor_left_end                PIN_D6 
....................    #endif 
....................    #ifndef  steper_motor_right_end 
....................       #define steper_motor_right_end               PIN_D5 
....................    #endif 
....................    
....................    #ifndef steper_motor_sensor_enable_pin 
....................       #define steper_motor_sensor_enable_pin       PIN_D7 
....................    #endif 
....................     
....................    #define stepper_motor_calibrated_NONE        0b00000000 
....................    #define stepper_motor_calibrated_left        0b00000001 
....................    #define stepper_motor_calibrated_right       0b00000010 
....................    #define stepper_motor_calibrated             0b00000011 
....................     
.................... //   #define L293_state_EN_disabled               0b00000000 
.................... //   #define L293_state_EN_enabled                0b00000001 
....................  
....................    #define steper_motor_LIMIT_SWITCH_reached       0    //for switch 1 for opto 0 
....................    #define steper_motor_LIMIT_SWITCH_NOT_reached   1    //for switch 0 for opto 1 
....................    //int8 L293_driver_state; 
....................    int8 steper_motor_calibration_state; 
....................    int8 stepper_motor_phase; 
....................    unsigned int32 stepper_motor_position; 
....................    unsigned int32 stepper_motor_position_max; 
....................     
....................    //void module_stepper_motor_disable_EN(void); 
....................    //oid module_stepper_motor_enable_EN(void); 
....................     
....................    void module_steper_motor_step_left(void); 
....................    void module_steper_motor_step_right(void); 
....................    void module_steper_motor_stop(void); 
....................    int1 steper_motor_sensor_enable(void); 
....................    int1 steper_motor_sensor_disable(void); 
....................    #ifndef _STEPPER_MOTOR_ON_INTERRUPTS_ 
....................       void __reset_L293D_conditions__(void); 
....................    #endif 
....................     
....................    #ifdef _STEPPER_MOTOR_ON_INTERRUPTS_ 
....................       #if getenv("SFR_VALID:INTCON") 
....................          #byte INTCON_register = getenv("SFR:INTCON") 
....................          #bit  timer0_interrupts_STATEMENT=INTCON_register.5 
....................          #WARNING "STEPPER MOTOR on TIMER0 interrups" 
....................        
....................        
....................       #else 
....................          #ERROR "PIC_INTCON REGISTER SHOULD BE DEFINED in module_stepper_motor.h" 
....................       #endif 
....................    #endif       
....................     
.................... #endif 
....................  
....................  
.................... /*void module_stepper_motor_disable_EN(void) 
.................... { 
....................    disable_EN_12();     //same pin as EN_34 
....................    //__reset_L293D_conditions__(); 
....................    dbg_printf("L293: disabled"); 
....................    dbg_return_carriage(); 
....................    //L293_driver_state = L293_state_EN_disabled; 
.................... }*/ 
....................  
.................... /*void module_stepper_motor_enable_EN(void) 
.................... { 
....................    enable_EN_12();      //same pin as EN_34 
....................    //__reset_L293D_conditions__(); 
....................    dbg_printf("L293: enabled"); 
....................    dbg_return_carriage(); 
....................    //L293_driver_state = L293_state_EN_enabled; 
.................... }*/ 
....................  
....................  
.................... void module_steper_motor_step_left(void) 
.................... { 
....................    //if (input(steper_motor_left_end)==0) 
....................     
....................    if (input(steper_motor_left_end)==steper_motor_LIMIT_SWITCH_NOT_reached) 
*
0BED:  MOVLW  6B
0BEE:  BSF    03.5
0BEF:  MOVWF  08
0BF0:  BCF    03.5
0BF1:  BTFSS  08.5
0BF2:  GOTO   415
....................    { 
....................       disable_EN_12(); 
0BF3:  BCF    0A.3
0BF4:  CALL   28C
0BF5:  BSF    0A.3
....................       stepper_motor_phase = STEPPER_motor(stepper_motor_phase, left); 
0BF6:  MOVF   58,W
0BF7:  BSF    03.5
0BF8:  MOVWF  3B
0BF9:  CLRF   3C
0BFA:  BCF    0A.3
0BFB:  BCF    03.5
0BFC:  CALL   298
0BFD:  BSF    0A.3
0BFE:  MOVF   78,W
0BFF:  MOVWF  58
....................       enable_EN_12(); 
0C00:  BCF    0A.3
0C01:  CALL   326
0C02:  BSF    0A.3
.................... //      #ifndef _STEPPER_MOTOR_ON_INTERRUPTS_ 
....................          __reset_L293D_conditions__(); 
0C03:  BCF    0A.3
0C04:  CALL   332
0C05:  BSF    0A.3
.................... //      #endif 
....................       stepper_motor_position = stepper_motor_position-1; 
0C06:  MOVLW  01
0C07:  SUBWF  59,F
0C08:  MOVLW  00
0C09:  BTFSS  03.0
0C0A:  MOVLW  01
0C0B:  SUBWF  5A,F
0C0C:  MOVLW  00
0C0D:  BTFSS  03.0
0C0E:  MOVLW  01
0C0F:  SUBWF  5B,F
0C10:  MOVLW  00
0C11:  BTFSS  03.0
0C12:  MOVLW  01
0C13:  SUBWF  5C,F
....................    } 
0C14:  GOTO   427
....................    else 
....................    { 
....................       dbg_printf("STOP:left end reached"); 
0C15:  MOVLW  69
0C16:  BSF    03.6
0C17:  MOVWF  0D
0C18:  MOVLW  00
0C19:  MOVWF  0F
0C1A:  BCF    0A.3
0C1B:  BCF    03.6
0C1C:  CALL   352
0C1D:  BSF    0A.3
0C1E:  BCF    0A.3
0C1F:  CALL   262
0C20:  BSF    0A.3
....................       dbg_return_carriage(); 
0C21:  BCF    0A.3
0C22:  CALL   262
0C23:  BSF    0A.3
....................       module_steper_motor_stop(); 
0C24:  BCF    0A.3
0C25:  CALL   3C6
0C26:  BSF    0A.3
....................    } 
0C27:  RETURN
.................... } 
....................  
.................... void module_steper_motor_step_right(void) 
.................... { 
....................    //if (input(steper_motor_right_end)==0) 
....................    if (input(steper_motor_right_end)==steper_motor_LIMIT_SWITCH_NOT_reached) 
*
03D9:  MOVLW  6B
03DA:  BSF    03.5
03DB:  MOVWF  08
03DC:  BCF    03.5
03DD:  BTFSS  08.6
03DE:  GOTO   3FA
....................     
....................    { 
....................       disable_EN_12(); 
03DF:  CALL   28C
....................       stepper_motor_phase = STEPPER_motor(stepper_motor_phase, right); 
03E0:  MOVF   58,W
03E1:  BSF    03.5
03E2:  MOVWF  3B
03E3:  MOVLW  01
03E4:  MOVWF  3C
03E5:  BCF    03.5
03E6:  CALL   298
03E7:  MOVF   78,W
03E8:  MOVWF  58
....................       enable_EN_12(); 
03E9:  CALL   326
.................... //      #ifndef _STEPPER_MOTOR_ON_INTERRUPTS_ 
....................          __reset_L293D_conditions__(); 
03EA:  CALL   332
.................... //      #endif 
....................       stepper_motor_position = stepper_motor_position+1; 
03EB:  MOVLW  01
03EC:  ADDWF  59,F
03ED:  MOVLW  00
03EE:  BTFSC  03.0
03EF:  MOVLW  01
03F0:  ADDWF  5A,F
03F1:  MOVLW  00
03F2:  BTFSC  03.0
03F3:  MOVLW  01
03F4:  ADDWF  5B,F
03F5:  MOVLW  00
03F6:  BTFSC  03.0
03F7:  MOVLW  01
03F8:  ADDWF  5C,F
....................    } 
03F9:  GOTO   404
....................    else 
....................    { 
....................       dbg_printf("STOP:right end reached"); 
03FA:  MOVLW  74
03FB:  BSF    03.6
03FC:  MOVWF  0D
03FD:  MOVLW  00
03FE:  MOVWF  0F
03FF:  BCF    03.6
0400:  CALL   352
0401:  CALL   262
....................       dbg_return_carriage(); 
0402:  CALL   262
....................       module_steper_motor_stop(); 
0403:  CALL   3C6
....................    } 
0404:  RETURN
....................     
.................... } 
....................  
.................... void module_steper_motor_stop(void) 
.................... { 
....................    disable_EN_12(); 
*
03C6:  CALL   28C
....................    stepper_motor_phase = STEPPER_motor(stepper_motor_phase, stop); 
03C7:  MOVF   58,W
03C8:  BSF    03.5
03C9:  MOVWF  3B
03CA:  MOVLW  02
03CB:  MOVWF  3C
03CC:  BCF    03.5
03CD:  CALL   298
03CE:  MOVF   78,W
03CF:  MOVWF  58
....................    enable_EN_12(); 
03D0:  CALL   326
....................    delay_ms(1); 
03D1:  MOVLW  01
03D2:  BSF    03.5
03D3:  MOVWF  3C
03D4:  BCF    03.5
03D5:  CALL   26D
.................... //   #ifndef _STEPPER_MOTOR_ON_INTERRUPTS_ 
....................       __reset_L293D_conditions__(); 
03D6:  CALL   332
.................... //   #endif 
....................    disable_EN_12(); 
03D7:  CALL   28C
03D8:  RETURN
.................... } 
....................  
.................... //#ifndef _STEPPER_MOTOR_ON_INTERRUPTS_ 
....................    void __reset_L293D_conditions__(void) 
....................    { 
....................       set_ticks(Steper_motor_timer,0); 
*
0332:  BSF    03.5
0333:  CLRF   3C
0334:  CLRF   3B
*
0351:  RETURN
....................       //motor_command_executed = true; 
....................    } 
.................... //#endif 
....................  
.................... int1 steper_motor_sensor_enable(void) 
.................... { 
....................    output_bit(steper_motor_sensor_enable_pin,1); 
*
0281:  BSF    08.7
0282:  MOVLW  6B
0283:  BSF    03.5
0284:  MOVWF  08
....................    delay_ms(1); 
0285:  MOVLW  01
0286:  MOVWF  3C
0287:  BCF    03.5
0288:  CALL   26D
....................    return TRUE; 
0289:  MOVLW  01
028A:  MOVWF  78
028B:  RETURN
.................... } 
....................  
....................  
.................... int1 steper_motor_sensor_disable(void) 
.................... { 
....................    output_bit(steper_motor_sensor_enable_pin,0); 
*
0405:  BCF    08.7
0406:  MOVLW  6B
0407:  BSF    03.5
0408:  MOVWF  08
....................    delay_ms(1); 
0409:  MOVLW  01
040A:  MOVWF  3C
040B:  BCF    03.5
040C:  CALL   26D
....................    return FALSE; 
040D:  MOVLW  00
040E:  MOVWF  78
040F:  RETURN
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef __silelis_math__ 
....................       #include </HMI_MCU_common_includes/SileliS_math/silelis_math.c> 
.................... #ifndef __silelis_math__ 
....................    #define __silelis_math__ 
....................     
....................    #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
1036:  BCF    03.5
1037:  CLRF   63
1038:  CLRF   64
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................     
....................    #ifndef _BIT_MATH_ 
.................... 	#include </BIT_MATH.c> 
.................... #include </BIT_MATH.h> 
.................... #ifndef _BIT_MATH_ 
....................    #define _BIT_MATH_ 
....................    unsigned int8 n_value_bits_to_x(unsigned int8 , int8, unsigned int8 ); 
....................    unsigned int8 nth_bit_to_x(unsigned int8, int8, unsigned int8); 
....................    unsigned int8 set_bit(unsigned int8, unsigned int8); 
....................    unsigned int8 clear_bit(unsigned int8, unsigned int8); 
....................    unsigned int8 toggle_bit(unsigned int8, unsigned int8); 
....................    int1 check_bit(unsigned int8, unsigned int8); 
....................    unsigned int MSB_to_LSM(unsigned int); 
.................... #endif 
....................  
....................  
.................... //BIT MATHEMATIC 
.................... //http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c 
....................  
.................... /* 
.................... Setting a bit 
....................  
.................... Use the bitwise OR operator (|) to set a bit. 
....................  
.................... number |= 1 << x; 
.................... That will set bit x. 
....................  
.................... Clearing a bit 
....................  
.................... Use the bitwise AND operator (&) to clear a bit. 
....................  
.................... number &= ~(1 << x); 
.................... That will clear bit x. You must invert the bit string with the bitwise NOT operator (~), then AND it. 
....................  
.................... Toggling a bit 
....................  
.................... The XOR operator (^) can be used to toggle a bit. 
....................  
.................... number ^= 1 << x; 
.................... That will toggle bit x. 
....................  
.................... Checking a bit 
....................  
.................... You didn't ask for this but I might as well add it. 
....................  
.................... To check a bit, shift the number x to the right, then bitwise AND it: 
....................  
.................... bit = (number >> x) & 1; 
.................... That will put the value of bit x into the variable bit. 
....................  
.................... Changing the nth bit to x 
....................  
.................... Setting the nth bit to either 1 or 0 can be achieved with the following: 
....................  
.................... number ^= (-x ^ number) & (1 << n); 
.................... */ 
....................  
.................... unsigned int8 nth_bit_to_x(unsigned int8 var_to_change, int8 x, unsigned int8 nth_bit) 
.................... { 
.................... /* zmienia na x konkretny bit*/ 
.................... var_to_change = (var_to_change & ~(1<<nth_bit)) | (x<<nth_bit); 
....................  
.................... return var_to_change; 
.................... } 
....................  
....................  
.................... unsigned int8 n_value_bits_to_x(unsigned int8 var_to_change, int8 x, unsigned int8 n_value) 
.................... { 
.................... /* zmienia na x bity daj¹ce wartoœæ n_value eg. 65 zminei bity 0?00000?*/ 
....................    // x ON = 1 
....................    // x OFF= 0 
....................    // nth as bitmask for ex. 7th bit 1<<7 
....................    var_to_change^= (-x ^ var_to_change) & n_value; 
.................... return var_to_change; 
.................... } 
....................  
....................  
.................... unsigned int8 set_bit(unsigned int8 var_to_change, unsigned int8 nth) 
.................... { 
....................    var_to_change |= 1 << nth; 
....................    return var_to_change; 
.................... } 
....................  
....................  
.................... unsigned int8 clear_bit(unsigned int8 var_to_change, unsigned int8 nth) 
.................... { 
....................    var_to_change &= ~(1 << nth); 
....................    return var_to_change; 
.................... } 
....................  
.................... unsigned int8 toggle_bit(unsigned int8 var_to_change, unsigned int8 nth) 
.................... { 
....................    var_to_change ^= 1 << nth; 
....................    return var_to_change; 
.................... } 
....................  
.................... int1 check_bit(unsigned int8 var_to_check, unsigned int8 nth) 
.................... { 
....................    int1 bit = (var_to_check >> nth) & 1; 
....................    return bit; 
.................... } 
....................  
....................  
.................... unsigned int MSB_to_LSM(unsigned int num) 
....................    /* function change bit order - i.e. required between PIC and 8051 mcu communication*/ 
.................... { 
....................     unsigned int  NO_OF_BITS = sizeof(num) * 8; 
....................     unsigned int reverse_num = 0, i, temp; 
....................   
....................     for (i = 0; i < NO_OF_BITS; i++) 
....................     { 
....................         temp = (num & (1 << i)); 
....................         if(temp) 
....................             reverse_num |= (1 << ((NO_OF_BITS - 1) - i)); 
....................     } 
....................    
....................     return reverse_num; 
.................... } 
....................  
....................    #endif 
....................     
....................    unsigned int random(unsigned int min, unsigned int  max) 
....................    { 
....................        unsigned int tmp; 
....................        if (max>=min) 
....................            max-= min; 
....................        else 
....................        { 
....................            tmp= min - max; 
....................            min= max; 
....................            max= tmp; 
....................        } 
....................        return max ? (rand() % max + min) : min; 
....................    } 
....................  
....................    unsigned int32 round_closest(float dividend, float divisor) 
....................    { 
....................        return (dividend + (divisor / 2)) / divisor; 
*
09B5:  BSF    03.5
09B6:  MOVF   46,W
09B7:  MOVWF  4E
09B8:  MOVF   45,W
09B9:  MOVWF  4D
09BA:  MOVF   44,W
09BB:  MOVWF  4C
09BC:  MOVF   43,W
09BD:  MOVWF  4B
09BE:  CLRF   52
09BF:  CLRF   51
09C0:  CLRF   50
09C1:  MOVLW  80
09C2:  MOVWF  4F
09C3:  BCF    03.5
09C4:  CALL   0E9
09C5:  BCF    03.1
09C6:  BSF    03.5
09C7:  MOVF   42,W
09C8:  MOVWF  4A
09C9:  MOVF   41,W
09CA:  MOVWF  49
09CB:  MOVF   40,W
09CC:  MOVWF  48
09CD:  MOVF   3F,W
09CE:  MOVWF  47
09CF:  MOVF   7A,W
09D0:  MOVWF  4E
09D1:  MOVF   79,W
09D2:  MOVWF  4D
09D3:  MOVF   78,W
09D4:  MOVWF  4C
09D5:  MOVF   77,W
09D6:  MOVWF  4B
*
0B17:  MOVF   7A,W
0B18:  MOVWF  4A
0B19:  MOVF   79,W
0B1A:  MOVWF  49
0B1B:  MOVF   78,W
0B1C:  MOVWF  48
0B1D:  MOVF   77,W
0B1E:  MOVWF  47
0B1F:  MOVF   4A,W
0B20:  MOVWF  4E
0B21:  MOVF   49,W
0B22:  MOVWF  4D
0B23:  MOVF   48,W
0B24:  MOVWF  4C
0B25:  MOVF   47,W
0B26:  MOVWF  4B
0B27:  MOVF   46,W
0B28:  MOVWF  52
0B29:  MOVF   45,W
0B2A:  MOVWF  51
0B2B:  MOVF   44,W
0B2C:  MOVWF  50
0B2D:  MOVF   43,W
0B2E:  MOVWF  4F
0B2F:  BCF    03.5
0B30:  CALL   0E9
0B31:  MOVF   7A,W
0B32:  BSF    03.5
0B33:  MOVWF  4B
0B34:  MOVF   79,W
0B35:  MOVWF  4A
0B36:  MOVF   78,W
0B37:  MOVWF  49
0B38:  MOVF   77,W
0B39:  MOVWF  48
0B3A:  BCF    0A.3
0B3B:  BCF    03.5
0B3C:  CALL   6CB
0B3D:  BSF    0A.3
0B3E:  BCF    0A.3
0B3F:  BSF    0A.4
0B40:  GOTO   502 (RETURN)
....................    } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... extern unsigned int8   Master_2_Slave_Buffer[I2C_SLAVE_BUFSIZE]; 
.................... extern unsigned int8   Slave_2_Master_Buffer[I2C_SLAVE_BUFSIZE]; 
.................... extern unsigned int    i2c_buffer_counter; 
....................  
....................  
....................  
....................  
.................... int1 i2c_data_to_PROCEED; 
.................... #INT_SSP 
.................... void  SSP_isr(void)  
.................... {   
....................    i2c_slave_interrupt (); 
....................    i2c_data_to_PROCEED=TRUE; 
*
00EB:  BCF    03.5
00EC:  BSF    56.2
.................... } 
....................  
.................... /*#INT_TIMER1 
.................... void timer() 
.................... { 
....................  
.................... dbg_printf("tim"); 
.................... clear_interrupt(int_timer1); 
.................... }*/ 
....................  
....................  
00ED:  BCF    0C.3
00EE:  BCF    0A.3
00EF:  BCF    0A.4
00F0:  GOTO   02D
.................... #define stepper_motor_delay_time_beetwen_steps 2 //ms 
....................  
.................... void main() 
.................... {   
....................  
....................    #if Backlight_MAX_VAL!=1 
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  FF
1004:  MOVWF  2B
1005:  BSF    2B.3
1006:  MOVF   2B,W
1007:  BSF    03.5
1008:  MOVWF  07
1009:  BCF    03.5
100A:  BSF    2B.4
100B:  MOVF   2B,W
100C:  BSF    03.5
100D:  MOVWF  07
100E:  MOVLW  10
100F:  MOVWF  13
1010:  MOVLW  36
1011:  BCF    03.5
1012:  MOVWF  14
1013:  BSF    03.5
1014:  BSF    11.7
1015:  BCF    03.5
1016:  CLRF   2D
1017:  CLRF   2C
1018:  BSF    03.5
1019:  MOVF   01,W
101A:  ANDLW  C0
101B:  IORLW  07
101C:  MOVWF  01
101D:  BCF    03.5
101E:  CLRF   01
101F:  BCF    0B.2
1020:  CLRF   2F
1021:  CLRF   2E
1022:  MOVLW  B5
1023:  MOVWF  10
1024:  CLRF   0E
1025:  CLRF   0F
1026:  CLRF   0E
1027:  BCF    0C.0
1028:  BSF    03.5
1029:  BCF    06.7
102A:  BCF    03.5
102B:  BSF    06.7
102C:  MOVLW  03
102D:  MOVWF  4F
102E:  BSF    56.0
102F:  CLRF   62
1030:  CLRF   61
1031:  BSF    03.5
1032:  BSF    1F.0
1033:  BSF    1F.1
1034:  BSF    1F.2
1035:  BCF    03.7
*
1039:  BCF    6B.0
103A:  BCF    6B.1
103B:  BCF    6B.2
103C:  BCF    6B.3
103D:  BCF    6B.4
103E:  BCF    6B.5
103F:  CLRF   7E
1040:  CLRF   7D
1041:  CLRF   7C
1042:  CLRF   7B
1043:  BSF    03.5
1044:  CLRF   23
1045:  CLRF   22
1046:  CLRF   21
1047:  CLRF   20
....................       pwm_set_duty_percent(0); 
....................    #endif 
....................     
....................     
.................... /*  { 
....................    int8 tris_value; 
....................    tris_value = get_tris_A(); 
....................    tris_value ^= 1 << 0; 
....................    tris_value ^= 1 << 1; 
....................    tris_value ^= 1 << 2; 
....................    tris_value ^= 1 << 5; 
....................    set_tris_A(tris_value); 
....................    tris_value = get_tris_B(); 
....................    tris_value ^= 1 << 1; 
....................    set_tris_B(tris_value); 
....................    tris_value = get_tris_C(); 
....................    tris_value ^= 1 << 0; 
....................    tris_value ^= 1 << 1; 
....................    tris_value ^= 1 << 2; 
....................    tris_value ^= 1 << 5; 
....................    tris_value ^= 1 << 6; 
....................    tris_value ^= 1 << 7; 
....................    set_tris_C(tris_value); 
....................    tris_value = get_tris_D(); 
....................    tris_value ^= 1 << 2; 
....................    tris_value ^= 1 << 4; 
....................    tris_value ^= 1 << 7; 
....................    set_tris_D(tris_value); 
....................    tris_value = get_tris_E(); 
....................    tris_value ^= 1 << 0; 
....................    tris_value ^= 1 << 1; 
....................    tris_value ^= 1 << 2; 
....................    set_tris_E(tris_value); 
....................    }*/ 
....................     
....................    int8 slave_buffer_colour_1; 
....................    int8 slave_buffer_colour_2;  
....................    
....................    int1 blink_STATEMENT = FALSE; 
....................    int1 blikn_1_pack_STATEMENT = FALSE; 
....................    int1 blikn_2_pack_STATEMENT = FALSE; 
....................    int1 blikn_3_pack_STATEMENT = FALSE; 
....................     
....................    int8 pack_1_blink_colour_1; 
....................    int8 pack_1_blink_colour_2; 
....................    int8 pack_2_blink_colour_1; 
....................    int8 pack_2_blink_colour_2; 
....................    int8 pack_3_blink_colour_1; 
....................    int8 pack_3_blink_colour_2; 
....................     
....................    int8 pack_colour; 
....................    int8 pack_number; 
....................     
....................    #if Backlight_MAX_VAL!=1 
....................       int1 backlight_max_blink_STATEMENT=FALSE;    //jeœli wartoœæ backlight osi¹gnie max to za³¹cza mrugniêcie 
....................       int8 backlight_max_STATEMENT_blink_count=0;  //iloœæ wykonanych mrugniêæ, jeœli zosta³a osi¹gniêta maksymalna wartoœæ backlight 
....................       #define backlight_blink_blink_timeout     4  //ile czasu ma trwaæ zmiana natê¿enie backlight przy max wartoœci 
....................       #define backlight_blink_count_max_value    5  // musi byæ nieparzyste 
....................    #endif 
....................     
....................    int1  recalculate_percentage_to_steps_STATEMENT = FALSE;    
....................    int1  stepper_motor_need_to_drive_STATEMENT=FALSE; 
....................    float stepper_motor_percents_goto =0;        //zmienna przechowuje informacjê otrzyman¹ z mcu na ile % powinna ustawiæ wskazowke w [%  W FORMACIE XXX.YYY] 
....................    unsigned int32  stepper_motor_steps_goto = 0;   //procenty usz¹ byæ przeliczone na kroki, gdy¿ ka¿dy silnik krokowy mo¿e byæ inny 
....................  
....................    extern unsigned int32  stepper_motor_position; //zmienna przechowuje informacje na temat aktualnego ustawienia wskazowki w [ krokach od lewej], wartoœæ 0 jest nadawana gdy wskazowka osiagnie podczas kalibracji lewy zderzak 
....................    extern unsigned int32  stepper_motor_position_max;    //po kalibracji zmienna przechowuje informacje na temat maksymalnej ilosci krokow na wskazowce w krokach od lewej], wartosc nadawana jest gdy wskazowka osi¹gnie prawy zderzak podczas kalibracji 
....................    extern int8  steper_motor_calibration_state;    
....................  
....................    stepper_motor_phase = 1; 
1048:  MOVLW  01
1049:  BCF    03.5
104A:  MOVWF  58
....................    stepper_motor_position = 0; 
104B:  CLRF   5C
104C:  CLRF   5B
104D:  CLRF   5A
104E:  CLRF   59
....................    stepper_motor_position_max = 0; 
104F:  CLRF   60
1050:  CLRF   5F
1051:  CLRF   5E
1052:  CLRF   5D
....................    steper_motor_calibration_state = stepper_motor_calibrated_NONE; 
1053:  CLRF   57
....................     
....................    dbg_printf(slave_fw_version __DATE__ " " __TIME__); 
1054:  MOVLW  F1
1055:  BSF    03.6
1056:  MOVWF  0D
1057:  MOVLW  00
1058:  MOVWF  0F
1059:  BCF    0A.4
105A:  BCF    03.6
105B:  GOTO   225
105C:  BSF    0A.4
105D:  BCF    0A.4
105E:  CALL   262
105F:  BSF    0A.4
.................... // zerowanie wartoœci silnika krokowego 
....................  
....................    delay_ms(250); 
1060:  MOVLW  FA
1061:  BSF    03.5
1062:  MOVWF  3C
1063:  BCF    0A.4
1064:  BCF    03.5
1065:  CALL   26D
1066:  BSF    0A.4
....................    //module_stepper_motor_enable_EN(); 
....................    int1 steper_motor_sensor_power_STATEMENT; 
....................    steper_motor_sensor_power_STATEMENT=steper_motor_sensor_enable(); 
1067:  BCF    0A.4
1068:  CALL   281
1069:  BSF    0A.4
106A:  BCF    6B.6
106B:  BTFSC  78.0
106C:  BSF    6B.6
....................    for (int i=1;i<=50;i++) 
106D:  MOVLW  01
106E:  MOVWF  74
106F:  MOVF   74,W
1070:  SUBLW  32
1071:  BTFSS  03.0
1072:  GOTO   07F
....................    { 
....................       module_steper_motor_step_right(); 
1073:  BCF    0A.4
1074:  CALL   3D9
1075:  BSF    0A.4
....................       delay_ms(2); 
1076:  MOVLW  02
1077:  BSF    03.5
1078:  MOVWF  3C
1079:  BCF    0A.4
107A:  BCF    03.5
107B:  CALL   26D
107C:  BSF    0A.4
107D:  INCF   74,F
107E:  GOTO   06F
....................     
....................    } 
....................    module_steper_motor_stop(); 
107F:  BCF    0A.4
1080:  CALL   3C6
1081:  BSF    0A.4
....................    steper_motor_sensor_disable() ; 
1082:  BCF    0A.4
1083:  CALL   405
1084:  BSF    0A.4
....................    steper_motor_sensor_power_STATEMENT=steper_motor_sensor_disable(); 
1085:  BCF    0A.4
1086:  CALL   405
1087:  BSF    0A.4
1088:  BCF    6B.6
1089:  BTFSC  78.0
108A:  BSF    6B.6
....................    delay_ms(500); 
108B:  MOVLW  02
108C:  BSF    03.5
108D:  MOVWF  30
108E:  MOVLW  FA
108F:  MOVWF  3C
1090:  BCF    0A.4
1091:  BCF    03.5
1092:  CALL   26D
1093:  BSF    0A.4
1094:  BSF    03.5
1095:  DECFSZ 30,F
1096:  GOTO   08E
....................  
....................    int8 backlight_current_value; 
....................  
....................  
....................    dbg_return_carriage(); 
1097:  BCF    0A.4
1098:  BCF    03.5
1099:  CALL   262
109A:  BSF    0A.4
....................    set_i2c_interrupt_ready(); 
109B:  BCF    0A.4
109C:  CALL   410
109D:  BSF    0A.4
....................     
....................    enable_interrupts(INT_SSP); 
109E:  BSF    03.5
109F:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
10A0:  MOVLW  C0
10A1:  BCF    03.5
10A2:  IORWF  0B,F
....................     
....................    set_all_pack_colour(colour_WHITE); 
10A3:  MOVLW  07
10A4:  BSF    03.5
10A5:  MOVWF  3B
10A6:  BCF    0A.4
10A7:  BCF    03.5
10A8:  CALL   50F
10A9:  BSF    0A.4
....................     
....................    i2c_data_to_PROCEED=FALSE; 
10AA:  BCF    56.2
....................    dbg_printf("Start HMI"); 
10AB:  MOVLW  29
10AC:  BSF    03.6
10AD:  MOVWF  0D
10AE:  MOVLW  01
10AF:  MOVWF  0F
10B0:  BCF    0A.4
10B1:  BCF    03.6
10B2:  CALL   352
10B3:  BSF    0A.4
10B4:  BCF    0A.4
10B5:  CALL   262
10B6:  BSF    0A.4
....................    dbg_return_carriage(); 
10B7:  BCF    0A.4
10B8:  CALL   262
10B9:  BSF    0A.4
....................    while(TRUE) 
....................    { 
....................    if (SSP1STAT_STOP_SEEN==1 && i2c_buffer_counter==1) 
10BA:  BSF    03.5
10BB:  BTFSS  14.4
10BC:  GOTO   0C8
10BD:  BCF    03.5
10BE:  DECFSZ 4E,W
10BF:  GOTO   0C1
10C0:  GOTO   0C3
10C1:  BSF    03.5
10C2:  GOTO   0C8
....................       { 
....................       set_i2c_interrupt_ready();    //i2c_engine() test condition only - NO DATA WAS SENT 
10C3:  BCF    0A.4
10C4:  CALL   410
10C5:  BSF    0A.4
....................        
....................       //i2c_data_to_PROCEED=TRUE; 
....................        
....................        
....................       } 
10C6:  GOTO   478
10C7:  BSF    03.5
....................    else if (SSP1STAT_STOP_SEEN==1&& i2c_buffer_counter>1) 
10C8:  BTFSS  14.4
10C9:  GOTO   479
10CA:  BCF    03.5
10CB:  MOVF   4E,W
10CC:  SUBLW  01
10CD:  BTFSS  03.0
10CE:  GOTO   0D1
10CF:  BSF    03.5
10D0:  GOTO   479
....................       { 
....................       memcpy (Master_2_Slave_Buffer, Master_2_Slave_Buffer+1,I2C_SLAVE_BUFSIZE-1); //first char is address 
10D1:  BSF    03.5
10D2:  CLRF   31
10D3:  MOVLW  30
10D4:  MOVWF  30
10D5:  CLRF   33
10D6:  MOVLW  31
10D7:  MOVWF  32
10D8:  MOVLW  0E
10D9:  MOVWF  78
10DA:  MOVF   32,W
10DB:  MOVWF  04
10DC:  BCF    03.7
10DD:  BTFSC  33.0
10DE:  BSF    03.7
10DF:  MOVF   00,W
10E0:  MOVWF  77
10E1:  MOVF   30,W
10E2:  MOVWF  04
10E3:  BCF    03.7
10E4:  BTFSC  31.0
10E5:  BSF    03.7
10E6:  MOVF   77,W
10E7:  MOVWF  00
10E8:  INCF   30,F
10E9:  BTFSC  03.2
10EA:  INCF   31,F
10EB:  INCF   32,F
10EC:  BTFSC  03.2
10ED:  INCF   33,F
10EE:  DECFSZ 78,F
10EF:  GOTO   0DA
....................       dbg_printf("c:0x%X ", Master_2_Slave_Buffer[0]); 
10F0:  MOVLW  2E
10F1:  BCF    03.5
10F2:  BSF    03.6
10F3:  MOVWF  0D
10F4:  MOVLW  01
10F5:  MOVWF  0F
10F6:  BCF    03.0
10F7:  MOVLW  04
10F8:  BSF    03.5
10F9:  BCF    03.6
10FA:  MOVWF  3B
10FB:  BCF    0A.4
10FC:  BCF    03.5
10FD:  CALL   525
10FE:  BSF    0A.4
10FF:  MOVF   30,W
1100:  BSF    03.5
1101:  MOVWF  3B
1102:  MOVLW  37
1103:  MOVWF  3C
1104:  BCF    0A.4
1105:  BCF    03.5
1106:  GOTO   59F
1107:  BSF    0A.4
1108:  MOVLW  20
1109:  BSF    03.5
110A:  MOVWF  48
110B:  BCF    0A.4
110C:  BCF    03.5
110D:  CALL   201
110E:  BSF    0A.4
110F:  BCF    0A.4
1110:  CALL   262
1111:  BSF    0A.4
....................       switch(Master_2_Slave_Buffer[command_address]) 
1112:  MOVF   30,W
1113:  BTFSC  03.2
1114:  GOTO   134
1115:  XORLW  01
1116:  BTFSC  03.2
1117:  GOTO   14B
1118:  XORLW  03
1119:  BTFSC  03.2
111A:  GOTO   198
111B:  XORLW  01
111C:  BTFSC  03.2
111D:  GOTO   1C5
111E:  XORLW  07
111F:  BTFSC  03.2
1120:  GOTO   223
1121:  XORLW  01
1122:  BTFSC  03.2
1123:  GOTO   271
1124:  XORLW  03
1125:  BTFSC  03.2
1126:  GOTO   2EA
1127:  XORLW  01
1128:  BTFSC  03.2
1129:  GOTO   314
112A:  XORLW  0F
112B:  BTFSC  03.2
112C:  GOTO   34C
112D:  XORLW  02
112E:  BTFSC  03.2
112F:  GOTO   430
1130:  XORLW  1A
1131:  BTFSC  03.2
1132:  GOTO   442
1133:  GOTO   464
....................          { 
....................          case command_clrl_all_packs: 
....................             //reset blinking conditions for pack// 
....................             blink_STATEMENT = blikn_1_pack_STATEMENT = blikn_2_pack_STATEMENT = blikn_3_pack_STATEMENT = FALSE; 
1134:  BCF    6B.3
1135:  BCF    6B.2
1136:  BCF    6B.1
1137:  BCF    6B.0
....................             //reset blinking conditions for pack// 
....................             clear_all_pack(); 
1138:  BCF    0A.4
1139:  GOTO   5D1
113A:  BSF    0A.4
....................             dbg_printf("clear all packs"); 
113B:  MOVLW  32
113C:  BSF    03.6
113D:  MOVWF  0D
113E:  MOVLW  01
113F:  MOVWF  0F
1140:  BCF    0A.4
1141:  BCF    03.6
1142:  CALL   352
1143:  BSF    0A.4
1144:  BCF    0A.4
1145:  CALL   262
1146:  BSF    0A.4
....................             dbg_return_carriage(); 
1147:  BCF    0A.4
1148:  CALL   262
1149:  BSF    0A.4
....................             break; 
114A:  GOTO   474
....................          case command_clrl_x_pack: 
....................             memcpy (&pack_number, Master_2_Slave_Buffer+pack_no_addres,pack_no_len); 
114B:  MOVF   31,W
114C:  MOVWF  73
....................             if (blink_STATEMENT == TRUE) 
114D:  BTFSS  6B.0
114E:  GOTO   165
....................             { 
....................                if (pack_number==pack_1) 
114F:  DECFSZ 73,W
1150:  GOTO   153
....................                { 
....................                   blikn_1_pack_STATEMENT = FALSE; 
1151:  BCF    6B.1
....................                } 
1152:  GOTO   15E
....................                else if (pack_number==pack_2) 
1153:  MOVF   73,W
1154:  SUBLW  02
1155:  BTFSS  03.2
1156:  GOTO   159
....................                { 
....................                   blikn_2_pack_STATEMENT = FALSE; 
1157:  BCF    6B.2
....................                } 
1158:  GOTO   15E
....................                else if (pack_number==pack_3) 
1159:  MOVF   73,W
115A:  SUBLW  03
115B:  BTFSS  03.2
115C:  GOTO   15E
....................                { 
....................                   blikn_3_pack_STATEMENT = FALSE; 
115D:  BCF    6B.3
....................                } 
....................                 
....................                if ((blikn_1_pack_STATEMENT == FALSE) && (blikn_2_pack_STATEMENT == FALSE) &&  (blikn_3_pack_STATEMENT == FALSE)) 
115E:  BTFSC  6B.1
115F:  GOTO   165
1160:  BTFSC  6B.2
1161:  GOTO   165
1162:  BTFSC  6B.3
1163:  GOTO   165
....................                { 
....................                   blink_STATEMENT= FALSE; 
1164:  BCF    6B.0
....................                } 
....................             } 
....................              //reset blinking conditions for pack//             
....................             clear_x_pack(pack_number); 
1165:  MOVF   73,W
1166:  BSF    03.5
1167:  MOVWF  3B
1168:  BCF    0A.4
1169:  BCF    03.5
116A:  CALL   5C6
116B:  BSF    0A.4
....................             dbg_printf("clear %u pack.", pack_number); 
116C:  MOVLW  3A
116D:  BSF    03.6
116E:  MOVWF  0D
116F:  MOVLW  01
1170:  MOVWF  0F
1171:  BCF    03.0
1172:  MOVLW  06
1173:  BSF    03.5
1174:  BCF    03.6
1175:  MOVWF  3B
1176:  BCF    0A.4
1177:  BCF    03.5
1178:  CALL   525
1179:  BSF    0A.4
117A:  MOVF   73,W
117B:  BSF    03.5
117C:  MOVWF  3B
117D:  MOVLW  1B
117E:  MOVWF  3C
117F:  BCF    0A.4
1180:  BCF    03.5
1181:  CALL   5FA
1182:  BSF    0A.4
1183:  MOVLW  3E
1184:  BSF    03.6
1185:  MOVWF  0D
1186:  MOVLW  01
1187:  MOVWF  0F
1188:  BCF    03.0
1189:  MOVLW  06
118A:  BSF    03.5
118B:  BCF    03.6
118C:  MOVWF  3B
118D:  BCF    0A.4
118E:  BCF    03.5
118F:  CALL   525
1190:  BSF    0A.4
1191:  BCF    0A.4
1192:  CALL   262
1193:  BSF    0A.4
....................             dbg_return_carriage(); 
1194:  BCF    0A.4
1195:  CALL   262
1196:  BSF    0A.4
....................             break; 
1197:  GOTO   474
....................          case command_set_all_packs: 
....................             memcpy (&slave_buffer_colour_1, Master_2_Slave_Buffer+colour_1_addres,colour_no_len); 
1198:  MOVF   32,W
1199:  MOVWF  69
....................             pack_colour=slave_buffer_colour_1; 
119A:  MOVF   69,W
119B:  MOVWF  72
....................             //reset blinking conditions for pack// 
....................             blink_STATEMENT = blikn_1_pack_STATEMENT = blikn_2_pack_STATEMENT = blikn_3_pack_STATEMENT = FALSE; 
119C:  BCF    6B.3
119D:  BCF    6B.2
119E:  BCF    6B.1
119F:  BCF    6B.0
....................             //reset blinking conditions for pack// 
....................             set_all_pack_colour(pack_colour); 
11A0:  MOVF   72,W
11A1:  BSF    03.5
11A2:  MOVWF  3B
11A3:  BCF    0A.4
11A4:  BCF    03.5
11A5:  CALL   50F
11A6:  BSF    0A.4
....................             dbg_printf("Set all packs colour %u", pack_colour); 
11A7:  MOVLW  42
11A8:  BSF    03.6
11A9:  MOVWF  0D
11AA:  MOVLW  01
11AB:  MOVWF  0F
11AC:  BCF    03.0
11AD:  MOVLW  15
11AE:  BSF    03.5
11AF:  BCF    03.6
11B0:  MOVWF  3B
11B1:  BCF    0A.4
11B2:  BCF    03.5
11B3:  CALL   525
11B4:  BSF    0A.4
11B5:  MOVF   72,W
11B6:  BSF    03.5
11B7:  MOVWF  3B
11B8:  MOVLW  1B
11B9:  MOVWF  3C
11BA:  BCF    0A.4
11BB:  BCF    03.5
11BC:  CALL   5FA
11BD:  BSF    0A.4
11BE:  BCF    0A.4
11BF:  CALL   262
11C0:  BSF    0A.4
....................             dbg_return_carriage(); 
11C1:  BCF    0A.4
11C2:  CALL   262
11C3:  BSF    0A.4
....................             break; 
11C4:  GOTO   474
....................          case command_set_x_pack: 
....................             memcpy (&pack_number, Master_2_Slave_Buffer+pack_no_addres,pack_no_len); 
11C5:  MOVF   31,W
11C6:  MOVWF  73
....................             memcpy (&slave_buffer_colour_1, Master_2_Slave_Buffer+colour_1_addres,colour_no_len); 
11C7:  MOVF   32,W
11C8:  MOVWF  69
....................             pack_colour = slave_buffer_colour_1; 
11C9:  MOVF   69,W
11CA:  MOVWF  72
....................             if (blink_STATEMENT == TRUE) 
11CB:  BTFSS  6B.0
11CC:  GOTO   1E5
....................                { 
....................                switch (pack_number){ 
11CD:  MOVF   73,W
11CE:  XORLW  01
11CF:  BTFSC  03.2
11D0:  GOTO   1D8
11D1:  XORLW  03
11D2:  BTFSC  03.2
11D3:  GOTO   1DA
11D4:  XORLW  01
11D5:  BTFSC  03.2
11D6:  GOTO   1DC
11D7:  GOTO   1DE
....................                   case pack_1: 
....................                      blikn_1_pack_STATEMENT = FALSE; 
11D8:  BCF    6B.1
....................                      break; 
11D9:  GOTO   1DE
....................                   case pack_2: 
....................                      blikn_2_pack_STATEMENT = FALSE; 
11DA:  BCF    6B.2
....................                      break; 
11DB:  GOTO   1DE
....................                   case pack_3: 
....................                      blikn_3_pack_STATEMENT = FALSE; 
11DC:  BCF    6B.3
....................                      break; 
11DD:  GOTO   1DE
....................                } 
....................                if ((blikn_1_pack_STATEMENT == FALSE) && (blikn_2_pack_STATEMENT == FALSE) &&  (blikn_3_pack_STATEMENT == FALSE)) 
11DE:  BTFSC  6B.1
11DF:  GOTO   1E5
11E0:  BTFSC  6B.2
11E1:  GOTO   1E5
11E2:  BTFSC  6B.3
11E3:  GOTO   1E5
....................                   blink_STATEMENT= FALSE; 
11E4:  BCF    6B.0
....................                } 
....................              //reset blinking conditions for pack// 
....................             set_x_pack_colour(pack_number, pack_colour); 
11E5:  MOVF   73,W
11E6:  BSF    03.5
11E7:  MOVWF  3E
11E8:  MOVF   72,W
11E9:  MOVWF  3F
11EA:  BCF    0A.4
11EB:  BCF    03.5
11EC:  CALL   4AE
11ED:  BSF    0A.4
....................             dbg_printf("Set pack %u colour %u", pack_number, pack_colour); 
11EE:  MOVLW  4E
11EF:  BSF    03.6
11F0:  MOVWF  0D
11F1:  MOVLW  01
11F2:  MOVWF  0F
11F3:  BCF    03.0
11F4:  MOVLW  09
11F5:  BSF    03.5
11F6:  BCF    03.6
11F7:  MOVWF  3B
11F8:  BCF    0A.4
11F9:  BCF    03.5
11FA:  CALL   525
11FB:  BSF    0A.4
11FC:  MOVF   73,W
11FD:  BSF    03.5
11FE:  MOVWF  3B
11FF:  MOVLW  1B
1200:  MOVWF  3C
1201:  BCF    0A.4
1202:  BCF    03.5
1203:  CALL   5FA
1204:  BSF    0A.4
1205:  MOVLW  53
1206:  BSF    03.6
1207:  MOVWF  0D
1208:  MOVLW  01
1209:  MOVWF  0F
120A:  BSF    03.0
120B:  MOVLW  08
120C:  BSF    03.5
120D:  BCF    03.6
120E:  MOVWF  3B
120F:  BCF    0A.4
1210:  BCF    03.5
1211:  CALL   525
1212:  BSF    0A.4
1213:  MOVF   72,W
1214:  BSF    03.5
1215:  MOVWF  3B
1216:  MOVLW  1B
1217:  MOVWF  3C
1218:  BCF    0A.4
1219:  BCF    03.5
121A:  CALL   5FA
121B:  BSF    0A.4
121C:  BCF    0A.4
121D:  CALL   262
121E:  BSF    0A.4
....................             dbg_return_carriage(); 
121F:  BCF    0A.4
1220:  CALL   262
1221:  BSF    0A.4
....................             break; 
1222:  GOTO   474
....................          case command_blink_all_packs: 
....................             //if (blink_STATEMENT == FALSE) 
....................                { 
....................                //LED_PACK_blink_timer = led_blink_timeout-1; 
....................                set_ticks(LED_blink_timer,(led_blink_time_4_timer-1)); 
1223:  BSF    03.5
1224:  CLRF   3C
1225:  MOVLW  E4
1226:  MOVWF  3B
1227:  BCF    0A.4
1228:  BCF    03.5
1229:  CALL   639
122A:  BSF    0A.4
....................                blink_display_color_no1=FALSE; 
122B:  BCF    56.0
....................                } 
....................             memcpy (&slave_buffer_colour_1, Master_2_Slave_Buffer+colour_1_addres,colour_no_len); 
122C:  MOVF   32,W
122D:  MOVWF  69
....................             memcpy (&slave_buffer_colour_2, Master_2_Slave_Buffer+colour_2_addres,colour_no_len);     
122E:  MOVF   33,W
122F:  MOVWF  6A
....................             pack_1_blink_colour_1 = pack_2_blink_colour_1 = pack_3_blink_colour_1 = slave_buffer_colour_1; 
1230:  MOVF   69,W
1231:  MOVWF  70
1232:  MOVWF  6E
1233:  MOVWF  6C
....................             pack_1_blink_colour_2 = pack_2_blink_colour_2 = pack_3_blink_colour_2 = slave_buffer_colour_2; 
1234:  MOVF   6A,W
1235:  MOVWF  71
1236:  MOVWF  6F
1237:  MOVWF  6D
....................             blink_STATEMENT = blikn_1_pack_STATEMENT = blikn_2_pack_STATEMENT = blikn_3_pack_STATEMENT = TRUE; 
1238:  BSF    6B.3
1239:  BSF    6B.2
123A:  BSF    6B.1
123B:  BSF    6B.0
....................             dbg_printf("Blink all packs colour: %u <-> %u", pack_1_blink_colour_1, pack_1_blink_colour_2); 
123C:  MOVLW  59
123D:  BSF    03.6
123E:  MOVWF  0D
123F:  MOVLW  01
1240:  MOVWF  0F
1241:  BCF    03.0
1242:  MOVLW  18
1243:  BSF    03.5
1244:  BCF    03.6
1245:  MOVWF  3B
1246:  BCF    0A.4
1247:  BCF    03.5
1248:  CALL   525
1249:  BSF    0A.4
124A:  MOVF   6C,W
124B:  BSF    03.5
124C:  MOVWF  3B
124D:  MOVLW  1B
124E:  MOVWF  3C
124F:  BCF    0A.4
1250:  BCF    03.5
1251:  CALL   5FA
1252:  BSF    0A.4
1253:  MOVLW  66
1254:  BSF    03.6
1255:  MOVWF  0D
1256:  MOVLW  01
1257:  MOVWF  0F
1258:  BCF    03.0
1259:  MOVLW  05
125A:  BSF    03.5
125B:  BCF    03.6
125C:  MOVWF  3B
125D:  BCF    0A.4
125E:  BCF    03.5
125F:  CALL   525
1260:  BSF    0A.4
1261:  MOVF   6D,W
1262:  BSF    03.5
1263:  MOVWF  3B
1264:  MOVLW  1B
1265:  MOVWF  3C
1266:  BCF    0A.4
1267:  BCF    03.5
1268:  CALL   5FA
1269:  BSF    0A.4
126A:  BCF    0A.4
126B:  CALL   262
126C:  BSF    0A.4
....................             dbg_return_carriage(); 
126D:  BCF    0A.4
126E:  CALL   262
126F:  BSF    0A.4
....................             break; 
1270:  GOTO   474
....................          case command_blink_x_pack: 
....................             //if (blink_STATEMENT == FALSE) 
....................                { 
....................                //LED_PACK_blink_timer = led_blink_timeout-1; 
....................                set_ticks(LED_blink_timer,(led_blink_time_4_timer-1)); 
1271:  BSF    03.5
1272:  CLRF   3C
1273:  MOVLW  E4
1274:  MOVWF  3B
1275:  BCF    0A.4
1276:  BCF    03.5
1277:  CALL   639
1278:  BSF    0A.4
....................                blink_display_color_no1=FALSE; 
1279:  BCF    56.0
....................                } 
....................             blink_STATEMENT = TRUE; 
127A:  BSF    6B.0
....................             memcpy (&pack_number, Master_2_Slave_Buffer+pack_no_addres,pack_no_len); 
127B:  MOVF   31,W
127C:  MOVWF  73
....................             memcpy (&slave_buffer_colour_1, Master_2_Slave_Buffer+colour_1_addres,colour_no_len); 
127D:  MOVF   32,W
127E:  MOVWF  69
....................             memcpy (&slave_buffer_colour_2, Master_2_Slave_Buffer+colour_2_addres,colour_no_len);              
127F:  MOVF   33,W
1280:  MOVWF  6A
....................              
....................             switch (pack_number){ 
1281:  MOVF   73,W
1282:  XORLW  01
1283:  BTFSC  03.2
1284:  GOTO   28C
1285:  XORLW  03
1286:  BTFSC  03.2
1287:  GOTO   292
1288:  XORLW  01
1289:  BTFSC  03.2
128A:  GOTO   298
128B:  GOTO   29E
....................             case pack_1: 
....................                pack_1_blink_colour_1 = slave_buffer_colour_1; 
128C:  MOVF   69,W
128D:  MOVWF  6C
....................                pack_1_blink_colour_2 = slave_buffer_colour_2;             
128E:  MOVF   6A,W
128F:  MOVWF  6D
....................                blikn_1_pack_STATEMENT = TRUE; 
1290:  BSF    6B.1
....................                break; 
1291:  GOTO   29E
....................                 
....................             case pack_2: 
....................                pack_2_blink_colour_1 = slave_buffer_colour_1; 
1292:  MOVF   69,W
1293:  MOVWF  6E
....................                pack_2_blink_colour_2 = slave_buffer_colour_2; 
1294:  MOVF   6A,W
1295:  MOVWF  6F
....................                blikn_2_pack_STATEMENT = TRUE; 
1296:  BSF    6B.2
....................                break;                
1297:  GOTO   29E
....................                 
....................             case pack_3: 
....................                pack_3_blink_colour_1 = slave_buffer_colour_1; 
1298:  MOVF   69,W
1299:  MOVWF  70
....................                pack_3_blink_colour_2 = slave_buffer_colour_2;             
129A:  MOVF   6A,W
129B:  MOVWF  71
....................                blikn_3_pack_STATEMENT = TRUE;               
129C:  BSF    6B.3
....................                break; 
129D:  GOTO   29E
....................             } 
....................             dbg_printf("Blink %u pack colour: %u <-> %u", pack_number, pack_1_blink_colour_1, pack_1_blink_colour_2); 
129E:  MOVLW  6A
129F:  BSF    03.6
12A0:  MOVWF  0D
12A1:  MOVLW  01
12A2:  MOVWF  0F
12A3:  BCF    03.0
12A4:  MOVLW  06
12A5:  BSF    03.5
12A6:  BCF    03.6
12A7:  MOVWF  3B
12A8:  BCF    0A.4
12A9:  BCF    03.5
12AA:  CALL   525
12AB:  BSF    0A.4
12AC:  MOVF   73,W
12AD:  BSF    03.5
12AE:  MOVWF  3B
12AF:  MOVLW  1B
12B0:  MOVWF  3C
12B1:  BCF    0A.4
12B2:  BCF    03.5
12B3:  CALL   5FA
12B4:  BSF    0A.4
12B5:  MOVLW  6E
12B6:  BSF    03.6
12B7:  MOVWF  0D
12B8:  MOVLW  01
12B9:  MOVWF  0F
12BA:  BCF    03.0
12BB:  MOVLW  0E
12BC:  BSF    03.5
12BD:  BCF    03.6
12BE:  MOVWF  3B
12BF:  BCF    0A.4
12C0:  BCF    03.5
12C1:  CALL   525
12C2:  BSF    0A.4
12C3:  MOVF   6C,W
12C4:  BSF    03.5
12C5:  MOVWF  3B
12C6:  MOVLW  1B
12C7:  MOVWF  3C
12C8:  BCF    0A.4
12C9:  BCF    03.5
12CA:  CALL   5FA
12CB:  BSF    0A.4
12CC:  MOVLW  76
12CD:  BSF    03.6
12CE:  MOVWF  0D
12CF:  MOVLW  01
12D0:  MOVWF  0F
12D1:  BCF    03.0
12D2:  MOVLW  05
12D3:  BSF    03.5
12D4:  BCF    03.6
12D5:  MOVWF  3B
12D6:  BCF    0A.4
12D7:  BCF    03.5
12D8:  CALL   525
12D9:  BSF    0A.4
12DA:  MOVF   6D,W
12DB:  BSF    03.5
12DC:  MOVWF  3B
12DD:  MOVLW  1B
12DE:  MOVWF  3C
12DF:  BCF    0A.4
12E0:  BCF    03.5
12E1:  CALL   5FA
12E2:  BSF    0A.4
12E3:  BCF    0A.4
12E4:  CALL   262
12E5:  BSF    0A.4
....................             dbg_return_carriage(); 
12E6:  BCF    0A.4
12E7:  CALL   262
12E8:  BSF    0A.4
....................             break; 
12E9:  GOTO   474
....................          case command_set_backlight: 
....................             memcpy(&backlight_current_value,Master_2_Slave_Buffer+SBL_Val_address,SBL_Val_address_len); 
12EA:  MOVF   31,W
12EB:  MOVWF  75
....................             #if Backlight_MAX_VAL!=1 
....................                pwm_set_duty_percent(backlight_current_value*100); 
....................       /*           #ifndef __RADIO_DEFAULTS_PARAMETERS__ 
....................                      #include </HMI_MCU_common_includes/MCU_radio_default_parameters/radio_default_parameters.h> 
....................                   #endif*/ 
....................                   if ((backlight_current_value == Backlight_MAX_VAL)&&(backlight_max_STATEMENT_blink_count==0)) 
....................                   { 
....................                      backlight_max_blink_STATEMENT=True; 
....................                      set_ticks(Backlight_blink_timer,(backlight_blink_blink_timeout-1)); 
....................                   } 
....................                   else if ((backlight_current_value != Backlight_MAX_VAL) && (backlight_max_blink_STATEMENT==True)) 
....................                   { 
....................                      backlight_max_blink_STATEMENT=False; 
....................                      backlight_max_STATEMENT_blink_count=0; 
....................                   } 
....................                 dbg_printf("Set backlight %u0%%", backlight_current_value); 
....................                dbg_return_carriage(); 
....................                    
....................              #else 
....................                output_bit( BACKLIGHT_pin, backlight_current_value); 
12EC:  MOVF   75,F
12ED:  BTFSS  03.2
12EE:  GOTO   2F1
12EF:  BCF    07.2
12F0:  GOTO   2F2
12F1:  BSF    07.2
12F2:  MOVLW  18
12F3:  BSF    03.5
12F4:  MOVWF  07
....................                dbg_printf("Set backlight %u", backlight_current_value); 
12F5:  MOVLW  7A
12F6:  BCF    03.5
12F7:  BSF    03.6
12F8:  MOVWF  0D
12F9:  MOVLW  01
12FA:  MOVWF  0F
12FB:  BCF    03.0
12FC:  MOVLW  0E
12FD:  BSF    03.5
12FE:  BCF    03.6
12FF:  MOVWF  3B
1300:  BCF    0A.4
1301:  BCF    03.5
1302:  CALL   525
1303:  BSF    0A.4
1304:  MOVF   75,W
1305:  BSF    03.5
1306:  MOVWF  3B
1307:  MOVLW  1B
1308:  MOVWF  3C
1309:  BCF    0A.4
130A:  BCF    03.5
130B:  CALL   5FA
130C:  BSF    0A.4
130D:  BCF    0A.4
130E:  CALL   262
130F:  BSF    0A.4
....................                dbg_return_carriage(); 
1310:  BCF    0A.4
1311:  CALL   262
1312:  BSF    0A.4
....................              #endif 
....................             break; 
1313:  GOTO   474
....................          case command_stepper_motor_percen:  
....................             memcpy (&stepper_motor_percents_goto, Master_2_Slave_Buffer+STP_MOTTOR_percentage_addres,STP_MOTTOR_percentage_len); 
1314:  MOVF   31,W
1315:  MOVWF  7B
1316:  MOVF   32,W
1317:  MOVWF  7C
1318:  MOVF   33,W
1319:  MOVWF  7D
131A:  MOVF   34,W
131B:  MOVWF  7E
....................             //stepper_morot_goto__PERCENT_STATEMENT = TRUE; 
....................             recalculate_percentage_to_steps_STATEMENT=TRUE; 
131C:  BSF    6B.4
....................             dbg_printf("Motor goto %.3f%%", stepper_motor_percents_goto); 
131D:  MOVLW  83
131E:  BSF    03.6
131F:  MOVWF  0D
1320:  MOVLW  01
1321:  MOVWF  0F
1322:  BCF    03.0
1323:  MOVLW  0B
1324:  BSF    03.5
1325:  BCF    03.6
1326:  MOVWF  3B
1327:  BCF    0A.4
1328:  BCF    03.5
1329:  CALL   525
132A:  BSF    0A.4
132B:  MOVLW  89
132C:  MOVWF  04
132D:  MOVF   7E,W
132E:  BSF    03.5
132F:  MOVWF  3E
1330:  MOVF   7D,W
1331:  MOVWF  3D
1332:  MOVF   7C,W
1333:  MOVWF  3C
1334:  MOVF   7B,W
1335:  MOVWF  3B
1336:  MOVLW  03
1337:  MOVWF  3F
1338:  BCF    0A.4
1339:  BSF    0A.3
133A:  BCF    03.5
133B:  CALL   000
133C:  BSF    0A.4
133D:  BCF    0A.3
133E:  MOVLW  25
133F:  BSF    03.5
1340:  MOVWF  48
1341:  BCF    0A.4
1342:  BCF    03.5
1343:  CALL   201
1344:  BSF    0A.4
1345:  BCF    0A.4
1346:  CALL   262
1347:  BSF    0A.4
....................             dbg_return_carriage(); 
1348:  BCF    0A.4
1349:  CALL   262
134A:  BSF    0A.4
....................             break; 
134B:  GOTO   474
....................          case command_stepper_motor_abs_val: 
....................             { 
....................             int32 STP_MOTTOR_min_range_temp_value;// =*& Master_2_Slave_Buffer+STP_MOTTOR_min_range_address; 
....................             int32 STP_MOTTOR_max_range_temp_value; // =*& Master_2_Slave_Buffer+STP_MOTTOR_max_range_address; 
....................             int32 STP_MOTTOR_goto_temp_value;// =*& Master_2_Slave_Buffer+STP_MOTTOR_goto_address; 
....................             memcpy (&STP_MOTTOR_min_range_temp_value, Master_2_Slave_Buffer+STP_MOTTOR_min_range_address,STP_MOTTOR_min_range_len); 
134C:  MOVF   31,W
134D:  BSF    03.5
134E:  MOVWF  24
134F:  BCF    03.5
1350:  MOVF   32,W
1351:  BSF    03.5
1352:  MOVWF  25
1353:  BCF    03.5
1354:  MOVF   33,W
1355:  BSF    03.5
1356:  MOVWF  26
1357:  BCF    03.5
1358:  MOVF   34,W
1359:  BSF    03.5
135A:  MOVWF  27
....................             memcpy (&STP_MOTTOR_max_range_temp_value, Master_2_Slave_Buffer+STP_MOTTOR_max_range_address ,STP_MOTTOR_max_range_len); 
135B:  BCF    03.5
135C:  MOVF   35,W
135D:  BSF    03.5
135E:  MOVWF  28
135F:  BCF    03.5
1360:  MOVF   36,W
1361:  BSF    03.5
1362:  MOVWF  29
1363:  BCF    03.5
1364:  MOVF   37,W
1365:  BSF    03.5
1366:  MOVWF  2A
1367:  BCF    03.5
1368:  MOVF   38,W
1369:  BSF    03.5
136A:  MOVWF  2B
....................             memcpy (&STP_MOTTOR_goto_temp_value, Master_2_Slave_Buffer+STP_MOTTOR_goto_address, STP_MOTTOR_goto_len); 
136B:  BCF    03.5
136C:  MOVF   39,W
136D:  BSF    03.5
136E:  MOVWF  2C
136F:  BCF    03.5
1370:  MOVF   3A,W
1371:  BSF    03.5
1372:  MOVWF  2D
1373:  BCF    03.5
1374:  MOVF   3B,W
1375:  BSF    03.5
1376:  MOVWF  2E
1377:  BCF    03.5
1378:  MOVF   3C,W
1379:  BSF    03.5
137A:  MOVWF  2F
....................             stepper_motor_percents_goto =(float)((double)(STP_MOTTOR_goto_temp_value-STP_MOTTOR_min_range_temp_value)/(STP_MOTTOR_max_range_temp_value-STP_MOTTOR_min_range_temp_value))*100; 
137B:  MOVF   24,W
137C:  SUBWF  2C,W
137D:  MOVWF  77
137E:  MOVF   2D,W
137F:  MOVWF  78
1380:  MOVF   25,W
1381:  BTFSS  03.0
1382:  INCFSZ 25,W
1383:  SUBWF  78,F
1384:  MOVF   2E,W
1385:  MOVWF  79
1386:  MOVF   26,W
1387:  BTFSS  03.0
1388:  INCFSZ 26,W
1389:  SUBWF  79,F
138A:  MOVF   2F,W
138B:  MOVWF  7A
138C:  MOVF   27,W
138D:  BTFSS  03.0
138E:  INCFSZ 27,W
138F:  SUBWF  7A,F
1390:  MOVF   7A,W
1391:  MOVWF  42
1392:  MOVF   79,W
1393:  MOVWF  41
1394:  MOVF   78,W
1395:  MOVWF  40
1396:  MOVF   77,W
1397:  MOVWF  3F
1398:  BCF    0A.4
1399:  BCF    03.5
139A:  CALL   73D
139B:  BSF    0A.4
139C:  MOVF   7A,W
139D:  BSF    03.5
139E:  MOVWF  33
139F:  MOVF   79,W
13A0:  MOVWF  32
13A1:  MOVF   78,W
13A2:  MOVWF  31
13A3:  MOVF   77,W
13A4:  MOVWF  30
13A5:  MOVF   24,W
13A6:  SUBWF  28,W
13A7:  MOVWF  77
13A8:  MOVF   29,W
13A9:  MOVWF  78
13AA:  MOVF   25,W
13AB:  BTFSS  03.0
13AC:  INCFSZ 25,W
13AD:  SUBWF  78,F
13AE:  MOVF   2A,W
13AF:  MOVWF  79
13B0:  MOVF   26,W
13B1:  BTFSS  03.0
13B2:  INCFSZ 26,W
13B3:  SUBWF  79,F
13B4:  MOVF   2B,W
13B5:  MOVWF  7A
13B6:  MOVF   27,W
13B7:  BTFSS  03.0
13B8:  INCFSZ 27,W
13B9:  SUBWF  7A,F
13BA:  MOVF   7A,W
13BB:  MOVWF  42
13BC:  MOVF   79,W
13BD:  MOVWF  41
13BE:  MOVF   78,W
13BF:  MOVWF  40
13C0:  MOVF   77,W
13C1:  MOVWF  3F
13C2:  BCF    0A.4
13C3:  BCF    03.5
13C4:  CALL   73D
13C5:  BSF    0A.4
13C6:  BSF    03.5
13C7:  MOVF   33,W
13C8:  MOVWF  4E
13C9:  MOVF   32,W
13CA:  MOVWF  4D
13CB:  MOVF   31,W
13CC:  MOVWF  4C
13CD:  MOVF   30,W
13CE:  MOVWF  4B
13CF:  MOVF   7A,W
13D0:  MOVWF  52
13D1:  MOVF   79,W
13D2:  MOVWF  51
13D3:  MOVF   78,W
13D4:  MOVWF  50
13D5:  MOVF   77,W
13D6:  MOVWF  4F
13D7:  BCF    0A.4
13D8:  BSF    0A.3
13D9:  BCF    03.5
13DA:  CALL   0E9
13DB:  BSF    0A.4
13DC:  BCF    0A.3
13DD:  MOVF   7A,W
13DE:  BSF    03.5
13DF:  MOVWF  33
13E0:  MOVF   79,W
13E1:  MOVWF  32
13E2:  MOVF   78,W
13E3:  MOVWF  31
13E4:  MOVF   77,W
13E5:  MOVWF  30
13E6:  MOVF   33,W
13E7:  MOVWF  4B
13E8:  MOVF   32,W
13E9:  MOVWF  4A
13EA:  MOVF   31,W
13EB:  MOVWF  49
13EC:  MOVF   30,W
13ED:  MOVWF  48
13EE:  CLRF   4F
13EF:  CLRF   4E
13F0:  MOVLW  48
13F1:  MOVWF  4D
13F2:  MOVLW  85
13F3:  MOVWF  4C
13F4:  BCF    0A.4
13F5:  BCF    03.5
13F6:  CALL   654
13F7:  BSF    0A.4
13F8:  MOVF   7A,W
13F9:  MOVWF  7E
13FA:  MOVF   79,W
13FB:  MOVWF  7D
13FC:  MOVF   78,W
13FD:  MOVWF  7C
13FE:  MOVF   77,W
13FF:  MOVWF  7B
....................             } 
....................             recalculate_percentage_to_steps_STATEMENT=TRUE; 
1400:  BSF    6B.4
....................             dbg_printf("Motor goto %.3f%%", stepper_motor_percents_goto); 
1401:  MOVLW  8C
1402:  BSF    03.6
1403:  MOVWF  0D
1404:  MOVLW  01
1405:  MOVWF  0F
1406:  BCF    03.0
1407:  MOVLW  0B
1408:  BSF    03.5
1409:  BCF    03.6
140A:  MOVWF  3B
140B:  BCF    0A.4
140C:  BCF    03.5
140D:  CALL   525
140E:  BSF    0A.4
140F:  MOVLW  89
1410:  MOVWF  04
1411:  MOVF   7E,W
1412:  BSF    03.5
1413:  MOVWF  3E
1414:  MOVF   7D,W
1415:  MOVWF  3D
1416:  MOVF   7C,W
1417:  MOVWF  3C
1418:  MOVF   7B,W
1419:  MOVWF  3B
141A:  MOVLW  03
141B:  MOVWF  3F
141C:  BCF    0A.4
141D:  BSF    0A.3
141E:  BCF    03.5
141F:  CALL   000
1420:  BSF    0A.4
1421:  BCF    0A.3
1422:  MOVLW  25
1423:  BSF    03.5
1424:  MOVWF  48
1425:  BCF    0A.4
1426:  BCF    03.5
1427:  CALL   201
1428:  BSF    0A.4
1429:  BCF    0A.4
142A:  CALL   262
142B:  BSF    0A.4
....................             dbg_return_carriage();         
142C:  BCF    0A.4
142D:  CALL   262
142E:  BSF    0A.4
....................             break; 
142F:  GOTO   474
....................          //case command_stepper_motor_rel_val: 
....................          //   //todo 
....................          //   //i2c_buffer_counter = set_i2c_interrupt_ready();        //przejœcie motora trwa d³u¿ej niæ komunikacja i mo¿e w ka¿dej chwili siê zmieniæ zadany parametr 
....................          //   //stepper_morot_goto_STATEMENT = TRUE; 
....................          //recalculate_percentage_to_steps=TRUE; 
....................          //   break; 
....................          case command_stepper_motor_calibrate: 
....................             recalculate_percentage_to_steps_STATEMENT=FALSE; 
1430:  BCF    6B.4
....................             steper_motor_calibration_state = stepper_motor_calibrated_NONE; 
1431:  CLRF   57
....................             dbg_printf("CALIBRATE"); 
1432:  MOVLW  95
1433:  BSF    03.6
1434:  MOVWF  0D
1435:  MOVLW  01
1436:  MOVWF  0F
1437:  BCF    0A.4
1438:  BCF    03.6
1439:  CALL   352
143A:  BSF    0A.4
143B:  BCF    0A.4
143C:  CALL   262
143D:  BSF    0A.4
....................             dbg_return_carriage(); 
143E:  BCF    0A.4
143F:  CALL   262
1440:  BSF    0A.4
....................             break; 
1441:  GOTO   474
....................          case i2c_slave_address:       
....................             dbg_return_carriage(); 
1442:  BCF    0A.4
1443:  CALL   262
1444:  BSF    0A.4
....................             dbg_printf("HMI was bussy and do not took i2c data!!! "); 
1445:  MOVLW  9A
1446:  BSF    03.6
1447:  MOVWF  0D
1448:  MOVLW  01
1449:  MOVWF  0F
144A:  BCF    0A.4
144B:  BCF    03.6
144C:  CALL   352
144D:  BSF    0A.4
144E:  BCF    0A.4
144F:  CALL   262
1450:  BSF    0A.4
....................             dbg_return_carriage(); 
1451:  BCF    0A.4
1452:  CALL   262
1453:  BSF    0A.4
....................             dbg_printf("Change mcu i2c engine 'HMI_software_delay_ms' parameter"); 
1454:  MOVLW  B0
1455:  BSF    03.6
1456:  MOVWF  0D
1457:  MOVLW  01
1458:  MOVWF  0F
1459:  BCF    0A.4
145A:  BCF    03.6
145B:  CALL   352
145C:  BSF    0A.4
145D:  BCF    0A.4
145E:  CALL   262
145F:  BSF    0A.4
....................             dbg_return_carriage(); 
1460:  BCF    0A.4
1461:  CALL   262
1462:  BSF    0A.4
....................             break; 
1463:  GOTO   474
....................          default: 
....................             dbg_printf("Not known"); 
1464:  MOVLW  CC
1465:  BSF    03.6
1466:  MOVWF  0D
1467:  MOVLW  01
1468:  MOVWF  0F
1469:  BCF    0A.4
146A:  BCF    03.6
146B:  CALL   352
146C:  BSF    0A.4
146D:  BCF    0A.4
146E:  CALL   262
146F:  BSF    0A.4
....................             dbg_return_carriage(); 
1470:  BCF    0A.4
1471:  CALL   262
1472:  BSF    0A.4
....................             break; 
1473:  GOTO   474
....................          } 
....................          set_i2c_interrupt_ready(); 
1474:  BCF    0A.4
1475:  CALL   410
1476:  BSF    0A.4
....................           
....................          i2c_data_to_PROCEED=FALSE; 
1477:  BCF    56.2
1478:  BSF    03.5
....................       } 
....................  
.................... /*-----------------------------------------------------------*/ 
....................       /* LEDS BLINKING handling */ 
.................... /*-----------------------------------------------------------*/ 
....................       if ((blink_STATEMENT == TRUE))//&&(SSP1STAT==0))  // lub ((blink_STATEMENT == TRUE)&&(i2c_buffer_counter==0))  //((blink_STATEMENT == TRUE)&&(SSP1STAT==0)) 
1479:  BCF    03.5
147A:  BTFSS  6B.0
147B:  GOTO   4AF
....................          { 
....................          run_led_blink_timer(); 
147C:  BCF    0A.4
147D:  GOTO   75A
147E:  BSF    0A.4
....................          if (blikn_1_pack_STATEMENT == TRUE) 
147F:  BTFSS  6B.1
1480:  GOTO   490
....................             { 
....................             set_x_pack_blink(pack_1, pack_1_blink_colour_1, pack_1_blink_colour_2); 
1481:  MOVLW  01
1482:  BSF    03.5
1483:  MOVWF  3B
1484:  BCF    03.5
1485:  MOVF   6C,W
1486:  BSF    03.5
1487:  MOVWF  3C
1488:  BCF    03.5
1489:  MOVF   6D,W
148A:  BSF    03.5
148B:  MOVWF  3D
148C:  BCF    0A.4
148D:  BCF    03.5
148E:  CALL   79B
148F:  BSF    0A.4
....................             } 
....................          if (blikn_2_pack_STATEMENT == TRUE) 
1490:  BTFSS  6B.2
1491:  GOTO   4A1
....................             { 
....................             set_x_pack_blink(pack_2, pack_2_blink_colour_1, pack_2_blink_colour_2); 
1492:  MOVLW  02
1493:  BSF    03.5
1494:  MOVWF  3B
1495:  BCF    03.5
1496:  MOVF   6E,W
1497:  BSF    03.5
1498:  MOVWF  3C
1499:  BCF    03.5
149A:  MOVF   6F,W
149B:  BSF    03.5
149C:  MOVWF  3D
149D:  BCF    0A.4
149E:  BCF    03.5
149F:  CALL   79B
14A0:  BSF    0A.4
....................             }             
....................          if (blikn_3_pack_STATEMENT == TRUE) 
14A1:  BTFSS  6B.3
14A2:  GOTO   4AE
....................             { 
....................             set_x_pack_blink(pack_3, pack_3_blink_colour_1, pack_3_blink_colour_2);     
14A3:  MOVLW  03
14A4:  BSF    03.5
14A5:  MOVWF  3B
14A6:  MOVF   70,W
14A7:  MOVWF  3C
14A8:  MOVF   71,W
14A9:  MOVWF  3D
14AA:  BCF    0A.4
14AB:  BCF    03.5
14AC:  CALL   79B
14AD:  BSF    0A.4
....................             }  
....................          blink_time_2_switch_color=false; 
14AE:  BCF    56.1
....................          } 
.................... /*-----------------------------------------------------------*/ 
....................       /* LEDS BLINKING handling */ 
.................... /*-----------------------------------------------------------*/ 
....................  
.................... /*-----------------------------------------------------------*/ 
....................       /* Backlight max value blink */ 
.................... /*-----------------------------------------------------------*/ 
....................    #if Backlight_MAX_VAL!=1 
....................    if ((backlight_max_blink_STATEMENT==TRUE)&&(get_ticks(Backlight_blink_timer)>3)) 
....................    { 
....................       set_ticks(Backlight_blink_timer,0); 
....................       if ((backlight_max_STATEMENT_blink_count%2)==0) 
....................          { 
....................             pwm_set_duty_percent(backlight_current_value*100); 
....................             dbg_printf("Backlight max 100"); 
....................             dbg_return_carriage(); 
....................          } 
....................          else 
....................          { 
....................             pwm_set_duty_percent((backlight_current_value*100)/4); 
....................             dbg_printf("Backlight max 25"); 
....................             dbg_return_carriage(); 
....................          } 
....................       backlight_max_STATEMENT_blink_count=backlight_max_STATEMENT_blink_count+1; 
....................        
....................       if (backlight_max_STATEMENT_blink_count==backlight_blink_count_max_value) 
....................       { 
....................          backlight_max_blink_STATEMENT=FALSE; 
....................          backlight_max_STATEMENT_blink_count=0; 
....................          dbg_printf("Backlight max exit"); 
....................          dbg_return_carriage(); 
....................       } 
....................    } 
....................    #endif 
.................... /*-----------------------------------------------------------*/ 
....................       /* Backlight max value blink */ 
.................... /*-----------------------------------------------------------*/ 
....................  
.................... /*-----------------------------------------------------------*/      
....................       /* STEPPER MOTOR HANDLING */ 
.................... /*-----------------------------------------------------------*/     
....................        
....................  
....................       { 
....................  
....................  
....................          //przeliczenie wartoœci % na goto 
....................         if ((recalculate_percentage_to_steps_STATEMENT == TRUE) && (steper_motor_calibration_state == stepper_motor_calibrated)&&(SSP1STAT_STOP_SEEN==0)) 
14AF:  BTFSS  6B.4
14B0:  GOTO   537
14B1:  MOVF   57,W
14B2:  SUBLW  03
14B3:  BTFSS  03.2
14B4:  GOTO   537
14B5:  BSF    03.5
14B6:  BTFSS  14.4
14B7:  GOTO   4BA
14B8:  BCF    03.5
14B9:  GOTO   537
....................          { 
....................             i2c_slave_not_ready(); 
14BA:  MOVLW  12
14BB:  MOVWF  13
....................             //disable_interrupts(GLOBAL); 
....................             recalculate_percentage_to_steps_STATEMENT=FALSE; 
14BC:  BCF    03.5
14BD:  BCF    6B.4
....................             stepper_motor_need_to_drive_STATEMENT = TRUE; 
14BE:  BSF    6B.5
....................             stepper_motor_steps_goto = round_closest(stepper_motor_position_max * stepper_motor_percents_goto, 100); 
14BF:  MOVF   60,W
14C0:  BSF    03.5
14C1:  MOVWF  42
14C2:  BCF    03.5
14C3:  MOVF   5F,W
14C4:  BSF    03.5
14C5:  MOVWF  41
14C6:  BCF    03.5
14C7:  MOVF   5E,W
14C8:  BSF    03.5
14C9:  MOVWF  40
14CA:  BCF    03.5
14CB:  MOVF   5D,W
14CC:  BSF    03.5
14CD:  MOVWF  3F
14CE:  BCF    0A.4
14CF:  BCF    03.5
14D0:  CALL   73D
14D1:  BSF    0A.4
14D2:  MOVF   7A,W
14D3:  BSF    03.5
14D4:  MOVWF  4B
14D5:  MOVF   79,W
14D6:  MOVWF  4A
14D7:  MOVF   78,W
14D8:  MOVWF  49
14D9:  MOVF   77,W
14DA:  MOVWF  48
14DB:  MOVF   7E,W
14DC:  MOVWF  4F
14DD:  MOVF   7D,W
14DE:  MOVWF  4E
14DF:  MOVF   7C,W
14E0:  MOVWF  4D
14E1:  MOVF   7B,W
14E2:  MOVWF  4C
14E3:  BCF    0A.4
14E4:  BCF    03.5
14E5:  CALL   654
14E6:  BSF    0A.4
14E7:  MOVF   7A,W
14E8:  BSF    03.5
14E9:  MOVWF  33
14EA:  MOVF   79,W
14EB:  MOVWF  32
14EC:  MOVF   78,W
14ED:  MOVWF  31
14EE:  MOVF   77,W
14EF:  MOVWF  30
14F0:  MOVF   33,W
14F1:  MOVWF  42
14F2:  MOVF   32,W
14F3:  MOVWF  41
14F4:  MOVF   31,W
14F5:  MOVWF  40
14F6:  MOVF   30,W
14F7:  MOVWF  3F
14F8:  CLRF   46
14F9:  CLRF   45
14FA:  MOVLW  48
14FB:  MOVWF  44
14FC:  MOVLW  85
14FD:  MOVWF  43
14FE:  BCF    0A.4
14FF:  BSF    0A.3
1500:  BCF    03.5
1501:  GOTO   1B5
1502:  BSF    0A.4
1503:  BCF    0A.3
1504:  MOVF   7A,W
1505:  BSF    03.5
1506:  MOVWF  23
1507:  MOVF   79,W
1508:  MOVWF  22
1509:  MOVF   78,W
150A:  MOVWF  21
150B:  MOVF   77,W
150C:  MOVWF  20
....................             dbg_printf("New goto: %Lu",stepper_motor_steps_goto); 
150D:  MOVLW  D1
150E:  BCF    03.5
150F:  BSF    03.6
1510:  MOVWF  0D
1511:  MOVLW  01
1512:  MOVWF  0F
1513:  BCF    03.0
1514:  MOVLW  0A
1515:  BSF    03.5
1516:  BCF    03.6
1517:  MOVWF  3B
1518:  BCF    0A.4
1519:  BCF    03.5
151A:  CALL   525
151B:  BSF    0A.4
151C:  MOVLW  41
151D:  MOVWF  04
151E:  BSF    03.5
151F:  MOVF   23,W
1520:  MOVWF  3E
1521:  MOVF   22,W
1522:  MOVWF  3D
1523:  MOVF   21,W
1524:  MOVWF  3C
1525:  MOVF   20,W
1526:  MOVWF  3B
1527:  BCF    0A.4
1528:  BSF    0A.3
1529:  BCF    03.5
152A:  CALL   341
152B:  BSF    0A.4
152C:  BCF    0A.3
152D:  BCF    0A.4
152E:  CALL   262
152F:  BSF    0A.4
....................             dbg_return_carriage(); 
1530:  BCF    0A.4
1531:  CALL   262
1532:  BSF    0A.4
....................            i2c_slave_ready(); 
1533:  MOVLW  10
1534:  BSF    03.5
1535:  MOVWF  13
1536:  BCF    03.5
....................          } 
....................        
....................        
....................         //przeliczenie wartoœci % na goto 
....................         //obs³uga silnika krokowego - kalibracja i wskazówki  
....................          if  (get_ticks(Steper_motor_timer)>(stepper_motor_delay_time_beetwen_steps*1.2)) 
1537:  BCF    0A.4
1538:  GOTO   7AF
1539:  BSF    0A.4
153A:  MOVF   78,W
153B:  BSF    03.5
153C:  MOVWF  31
153D:  MOVF   77,W
153E:  MOVWF  30
153F:  MOVF   31,W
1540:  MOVWF  3E
1541:  MOVF   30,W
1542:  MOVWF  3D
1543:  BCF    0A.4
1544:  BCF    03.5
1545:  GOTO   7CB
1546:  BSF    0A.4
1547:  MOVLW  9A
1548:  BSF    03.5
1549:  MOVWF  40
154A:  MOVLW  99
154B:  MOVWF  3F
154C:  MOVLW  19
154D:  MOVWF  3E
154E:  MOVLW  80
154F:  MOVWF  3D
1550:  MOVF   7A,W
1551:  MOVWF  44
1552:  MOVF   79,W
1553:  MOVWF  43
1554:  MOVF   78,W
1555:  MOVWF  42
1556:  MOVF   77,W
1557:  MOVWF  41
1558:  BCF    0A.4
1559:  BSF    0A.3
155A:  BCF    03.5
155B:  GOTO   3AA
155C:  BSF    0A.4
155D:  BCF    0A.3
155E:  BTFSS  03.0
155F:  GOTO   696
....................          {     
....................            if ((steper_motor_calibration_state!=stepper_motor_calibrated)||(stepper_motor_need_to_drive_STATEMENT==TRUE)&&(SSP1STAT_STOP_SEEN==0)) 
1560:  MOVF   57,W
1561:  SUBLW  03
1562:  BTFSS  03.2
1563:  GOTO   56C
1564:  BTFSS  6B.5
1565:  GOTO   696
1566:  BSF    03.5
1567:  BTFSS  14.4
1568:  GOTO   56B
1569:  BCF    03.5
156A:  GOTO   696
156B:  BCF    03.5
....................            { 
....................             
....................            i2c_slave_not_ready(); 
156C:  MOVLW  12
156D:  BSF    03.5
156E:  MOVWF  13
....................             
....................            if (steper_motor_sensor_power_STATEMENT==FALSE) 
156F:  BCF    03.5
1570:  BTFSC  6B.6
1571:  GOTO   578
....................            { 
....................                steper_motor_sensor_power_STATEMENT=steper_motor_sensor_enable(); 
1572:  BCF    0A.4
1573:  CALL   281
1574:  BSF    0A.4
1575:  BCF    6B.6
1576:  BTFSC  78.0
1577:  BSF    6B.6
....................            } 
....................  
....................            if (steper_motor_calibration_state!=stepper_motor_calibrated) 
1578:  MOVF   57,W
1579:  SUBLW  03
157A:  BTFSC  03.2
157B:  GOTO   5F1
....................            { 
....................               switch (steper_motor_calibration_state) 
157C:  MOVF   57,W
157D:  BTFSC  03.2
157E:  GOTO   586
157F:  XORLW  01
1580:  BTFSC  03.2
1581:  GOTO   598
1582:  XORLW  03
1583:  BTFSC  03.2
1584:  GOTO   5AC
1585:  GOTO   5F0
....................               { 
....................                   case stepper_motor_calibrated_NONE: 
....................                         module_steper_motor_step_left(); 
1586:  BCF    0A.4
1587:  BSF    0A.3
1588:  CALL   3ED
1589:  BSF    0A.4
158A:  BCF    0A.3
....................                         //if (input(steper_motor_left_end)==1) 
....................                         if (input(steper_motor_left_end)==steper_motor_LIMIT_SWITCH_reached) 
158B:  MOVLW  6B
158C:  BSF    03.5
158D:  MOVWF  08
158E:  BCF    03.5
158F:  BTFSC  08.5
1590:  GOTO   597
....................                         { 
....................                            steper_motor_calibration_state =stepper_motor_calibrated_left; 
1591:  MOVLW  01
1592:  MOVWF  57
....................                            stepper_motor_position=0; 
1593:  CLRF   5C
1594:  CLRF   5B
1595:  CLRF   5A
1596:  CLRF   59
....................                         } 
....................                         break; 
1597:  GOTO   5F0
....................                    case stepper_motor_calibrated_left: 
....................                         module_steper_motor_step_right(); 
1598:  BCF    0A.4
1599:  CALL   3D9
159A:  BSF    0A.4
....................                         //if (input(steper_motor_right_end)==1) 
....................                         if (input(steper_motor_right_end)==steper_motor_LIMIT_SWITCH_reached) 
159B:  MOVLW  6B
159C:  BSF    03.5
159D:  MOVWF  08
159E:  BCF    03.5
159F:  BTFSC  08.6
15A0:  GOTO   5AB
....................                         { 
....................                            steper_motor_calibration_state =stepper_motor_calibrated_right; 
15A1:  MOVLW  02
15A2:  MOVWF  57
....................                            stepper_motor_position_max=stepper_motor_position; 
15A3:  MOVF   5C,W
15A4:  MOVWF  60
15A5:  MOVF   5B,W
15A6:  MOVWF  5F
15A7:  MOVF   5A,W
15A8:  MOVWF  5E
15A9:  MOVF   59,W
15AA:  MOVWF  5D
....................                         } 
....................                         break; 
15AB:  GOTO   5F0
....................                   case stepper_motor_calibrated_right: 
....................                         module_steper_motor_stop(); 
15AC:  BCF    0A.4
15AD:  CALL   3C6
15AE:  BSF    0A.4
....................                         steper_motor_calibration_state =stepper_motor_calibrated; 
15AF:  MOVLW  03
15B0:  MOVWF  57
....................                         //module_stepper_motor_disable_EN(); 
....................                         steper_motor_sensor_power_STATEMENT=steper_motor_sensor_disable(); 
15B1:  BCF    0A.4
15B2:  CALL   405
15B3:  BSF    0A.4
15B4:  BCF    6B.6
15B5:  BTFSC  78.0
15B6:  BSF    6B.6
....................                         dbg_printf("Calibration finished with 0 <--> %Lu steps",stepper_motor_position_max); 
15B7:  MOVLW  D8
15B8:  BSF    03.6
15B9:  MOVWF  0D
15BA:  MOVLW  01
15BB:  MOVWF  0F
15BC:  BCF    03.0
15BD:  MOVLW  21
15BE:  BSF    03.5
15BF:  BCF    03.6
15C0:  MOVWF  3B
15C1:  BCF    0A.4
15C2:  BCF    03.5
15C3:  CALL   525
15C4:  BSF    0A.4
15C5:  MOVLW  41
15C6:  MOVWF  04
15C7:  MOVF   60,W
15C8:  BSF    03.5
15C9:  MOVWF  3E
15CA:  BCF    03.5
15CB:  MOVF   5F,W
15CC:  BSF    03.5
15CD:  MOVWF  3D
15CE:  BCF    03.5
15CF:  MOVF   5E,W
15D0:  BSF    03.5
15D1:  MOVWF  3C
15D2:  BCF    03.5
15D3:  MOVF   5D,W
15D4:  BSF    03.5
15D5:  MOVWF  3B
15D6:  BCF    0A.4
15D7:  BSF    0A.3
15D8:  BCF    03.5
15D9:  CALL   341
15DA:  BSF    0A.4
15DB:  BCF    0A.3
15DC:  MOVLW  EA
15DD:  BSF    03.6
15DE:  MOVWF  0D
15DF:  MOVLW  01
15E0:  MOVWF  0F
15E1:  BCF    03.0
15E2:  MOVLW  06
15E3:  BSF    03.5
15E4:  BCF    03.6
15E5:  MOVWF  3B
15E6:  BCF    0A.4
15E7:  BCF    03.5
15E8:  CALL   525
15E9:  BSF    0A.4
15EA:  BCF    0A.4
15EB:  CALL   262
15EC:  BSF    0A.4
....................                         dbg_return_carriage(); 
15ED:  BCF    0A.4
15EE:  CALL   262
15EF:  BSF    0A.4
....................               } 
....................            } 
15F0:  GOTO   692
....................            // kalibracja - KONIEC 
....................             
....................            //obs³uga wskazówki 
....................            else if (stepper_motor_need_to_drive_STATEMENT==TRUE) 
15F1:  BTFSS  6B.5
15F2:  GOTO   692
....................            { 
....................                if (stepper_motor_steps_goto==stepper_motor_position) 
15F3:  MOVF   59,W
15F4:  BSF    03.5
15F5:  SUBWF  20,W
15F6:  BTFSS  03.2
15F7:  GOTO   64A
15F8:  BCF    03.5
15F9:  MOVF   5A,W
15FA:  BSF    03.5
15FB:  SUBWF  21,W
15FC:  BTFSS  03.2
15FD:  GOTO   64A
15FE:  BCF    03.5
15FF:  MOVF   5B,W
1600:  BSF    03.5
1601:  SUBWF  22,W
1602:  BTFSS  03.2
1603:  GOTO   64A
1604:  BCF    03.5
1605:  MOVF   5C,W
1606:  BSF    03.5
1607:  SUBWF  23,W
1608:  BTFSS  03.2
1609:  GOTO   64A
....................                { 
....................                   stepper_motor_need_to_drive_STATEMENT=FALSE; 
160A:  BCF    03.5
160B:  BCF    6B.5
....................                   module_steper_motor_stop(); 
160C:  BCF    0A.4
160D:  CALL   3C6
160E:  BSF    0A.4
....................                   steper_motor_sensor_power_STATEMENT=steper_motor_sensor_disable(); 
160F:  BCF    0A.4
1610:  CALL   405
1611:  BSF    0A.4
1612:  BCF    6B.6
1613:  BTFSC  78.0
1614:  BSF    6B.6
....................                   dbg_printf("Carriage stopped at %Lu step.",stepper_motor_steps_goto); 
1615:  MOVLW  EE
1616:  BSF    03.6
1617:  MOVWF  0D
1618:  MOVLW  01
1619:  MOVWF  0F
161A:  BCF    03.0
161B:  MOVLW  14
161C:  BSF    03.5
161D:  BCF    03.6
161E:  MOVWF  3B
161F:  BCF    0A.4
1620:  BCF    03.5
1621:  CALL   525
1622:  BSF    0A.4
1623:  MOVLW  41
1624:  MOVWF  04
1625:  BSF    03.5
1626:  MOVF   23,W
1627:  MOVWF  3E
1628:  MOVF   22,W
1629:  MOVWF  3D
162A:  MOVF   21,W
162B:  MOVWF  3C
162C:  MOVF   20,W
162D:  MOVWF  3B
162E:  BCF    0A.4
162F:  BSF    0A.3
1630:  BCF    03.5
1631:  CALL   341
1632:  BSF    0A.4
1633:  BCF    0A.3
1634:  MOVLW  F9
1635:  BSF    03.6
1636:  MOVWF  0D
1637:  MOVLW  01
1638:  MOVWF  0F
1639:  BSF    03.0
163A:  MOVLW  06
163B:  BSF    03.5
163C:  BCF    03.6
163D:  MOVWF  3B
163E:  BCF    0A.4
163F:  BCF    03.5
1640:  CALL   525
1641:  BSF    0A.4
1642:  BCF    0A.4
1643:  CALL   262
1644:  BSF    0A.4
....................                   dbg_return_carriage(); 
1645:  BCF    0A.4
1646:  CALL   262
1647:  BSF    0A.4
....................                } 
1648:  GOTO   692
1649:  BSF    03.5
....................                else if(stepper_motor_steps_goto<stepper_motor_position) 
164A:  MOVF   23,W
164B:  BCF    03.5
164C:  SUBWF  5C,W
164D:  BTFSS  03.0
164E:  GOTO   66F
164F:  BTFSS  03.2
1650:  GOTO   669
1651:  BSF    03.5
1652:  MOVF   22,W
1653:  BCF    03.5
1654:  SUBWF  5B,W
1655:  BTFSS  03.0
1656:  GOTO   66F
1657:  BTFSS  03.2
1658:  GOTO   669
1659:  BSF    03.5
165A:  MOVF   21,W
165B:  BCF    03.5
165C:  SUBWF  5A,W
165D:  BTFSS  03.0
165E:  GOTO   66F
165F:  BTFSS  03.2
1660:  GOTO   669
1661:  MOVF   59,W
1662:  BSF    03.5
1663:  SUBWF  20,W
1664:  BTFSS  03.0
1665:  GOTO   668
1666:  BCF    03.5
1667:  GOTO   66F
1668:  BCF    03.5
....................                   module_steper_motor_step_left(); 
1669:  BCF    0A.4
166A:  BSF    0A.3
166B:  CALL   3ED
166C:  BSF    0A.4
166D:  BCF    0A.3
166E:  GOTO   692
....................                else if (stepper_motor_steps_goto>stepper_motor_position) 
166F:  MOVF   5C,W
1670:  BSF    03.5
1671:  SUBWF  23,W
1672:  BTFSS  03.0
1673:  GOTO   693
1674:  BTFSS  03.2
1675:  GOTO   68E
1676:  BCF    03.5
1677:  MOVF   5B,W
1678:  BSF    03.5
1679:  SUBWF  22,W
167A:  BTFSS  03.0
167B:  GOTO   693
167C:  BTFSS  03.2
167D:  GOTO   68E
167E:  BCF    03.5
167F:  MOVF   5A,W
1680:  BSF    03.5
1681:  SUBWF  21,W
1682:  BTFSS  03.0
1683:  GOTO   693
1684:  BTFSS  03.2
1685:  GOTO   68E
1686:  MOVF   20,W
1687:  BCF    03.5
1688:  SUBWF  59,W
1689:  BTFSS  03.0
168A:  GOTO   68D
168B:  BSF    03.5
168C:  GOTO   693
168D:  BSF    03.5
....................                   module_steper_motor_step_right(); 
168E:  BCF    0A.4
168F:  BCF    03.5
1690:  CALL   3D9
1691:  BSF    0A.4
1692:  BSF    03.5
....................            } 
....................            //obs³uga wskazówki  
....................            //dbg_printf("%Lu", stepper_motor_position); 
....................            //dbg_return_carriage(); 
....................            i2c_slave_ready(); 
1693:  MOVLW  10
1694:  MOVWF  13
1695:  BCF    03.5
....................            } 
....................          } 
....................  
....................       } 
....................        
.................... /*-----------------------------------------------------------*/ 
....................       /* STEPPER MOTOR HANDLING */ 
.................... /*-----------------------------------------------------------*/  
....................     
.................... if ((i2c_data_to_PROCEED==FALSE)&&(stepper_motor_need_to_drive_STATEMENT==FALSE)&&(steper_motor_calibration_state ==stepper_motor_calibrated)&&(blink_STATEMENT == FALSE)) 
1696:  BTFSC  56.2
1697:  GOTO   6AD
1698:  BTFSC  6B.5
1699:  GOTO   6AD
169A:  MOVF   57,W
169B:  SUBLW  03
169C:  BTFSS  03.2
169D:  GOTO   6AD
169E:  BTFSC  6B.0
169F:  GOTO   6AD
.................... { 
....................    dbg_printf("GtS.\r\n"); 
16A0:  MOVLW  FD
16A1:  BSF    03.6
16A2:  MOVWF  0D
16A3:  MOVLW  01
16A4:  MOVWF  0F
16A5:  BCF    0A.4
16A6:  BCF    03.6
16A7:  CALL   352
16A8:  BSF    0A.4
16A9:  BCF    0A.4
16AA:  CALL   262
16AB:  BSF    0A.4
....................    //set_timer1(0); 
....................    //enable_interrupts(INT_TIMER1); 
....................    sleep(); 
16AC:  SLEEP
.................... } 
16AD:  GOTO   0BA
....................     
.................... /*   #if Backlight_MAX_VAL!=1 
....................       if ((stepper_motor_need_to_drive_STATEMENT==FALSE)&&(steper_motor_calibration_state ==stepper_motor_calibrated)&&(backlight_max_blink_STATEMENT==FALSE)&&(blink_STATEMENT == FALSE)&&(SSP1STAT == 0)) 
....................    #else 
....................       if ((stepper_motor_need_to_drive_STATEMENT==FALSE)&&(steper_motor_calibration_state ==stepper_motor_calibrated)&&(blink_STATEMENT == FALSE)&&(SSP1STAT == 0)) 
....................    #endif 
....................    { 
....................       dbg_printf("Going to sleep mode"); 
....................       dbg_return_carriage(); 
....................       sleep(); 
....................    }*/ 
....................     
....................     
....................    } 
.................... } 
16AE:  SLEEP

Configuration Fuses:
   Word  1: 3FE2   HS NOWDT PUT PROTECT BROWNOUT
